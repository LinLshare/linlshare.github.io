{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/favicon.png","path":"favicon.png","modified":0,"renderable":0},{"_id":"source/README.md","path":"README.md","modified":0,"renderable":0},{"_id":"source/music.png","path":"music.png","modified":0,"renderable":0},{"_id":"source/robots.txt","path":"robots.txt","modified":0,"renderable":0},{"_id":"themes/kiss/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/kiss/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/kiss/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/kiss/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/kiss/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/kiss/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/kiss/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/kiss/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/kiss/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/kiss/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"themes/kiss/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/kiss/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/kiss/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/kiss/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/kiss/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/kiss/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/kiss/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/kiss/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/kiss/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/kiss/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/kiss/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/kiss/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/kiss/source/css/images/moon.jpg","path":"css/images/moon.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"source/favicon.png","hash":"d642aaac06571bf73b09872d57213a50e5ace563","modified":1601797714830},{"_id":"source/.DS_Store","hash":"c903b48b2733f9622d8b44697d7f4f31552676d6","modified":1601797714817},{"_id":"source/README.md","hash":"933b824f5bee4a6d4f81fc25d0a683aec450918b","modified":1601800018918},{"_id":"themes/kiss/.git","hash":"3235b2752a63cce552c06289853fc013c13f4ca6","modified":1601799641065},{"_id":"themes/kiss/.gitignore","hash":"58d26d4b5f2f94c2d02a4e4a448088e4a2527c77","modified":1601799641133},{"_id":"source/music.png","hash":"3ca73e04c922de92ffb44d6fe4c698720f85b041","modified":1601998288571},{"_id":"source/robots.txt","hash":"be8d5ab7132ac74a9375439e438b00b8c91e50b4","modified":1601797714830},{"_id":"themes/kiss/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1601799641133},{"_id":"themes/kiss/LICENSE","hash":"62aacb980e619f9d4f3d1a99fd314536ae3333d8","modified":1601799641133},{"_id":"themes/kiss/README.md","hash":"a6c41fdac85d719362210c24c85d41a3fe001d01","modified":1601799641133},{"_id":"themes/kiss/_config.yml","hash":"55450a5728d3e1769eb73fd55f6eb868e89b61ab","modified":1601799641134},{"_id":"themes/kiss/package.json","hash":"d771b2411f09120c0c5f9ce5bcd103052bab841c","modified":1601799641139},{"_id":"themes/kiss/package-lock.json","hash":"d5294dbb618f8add88f91ec1188a2663d14fc95d","modified":1601799641139},{"_id":"source/_posts/.DS_Store","hash":"d61d1098bec1490318d6f802a03b8c2d4700fde9","modified":1606890079949},{"_id":"source/_posts/Hello.md","hash":"04e8f02d1fa4488e2cbb0ddcea3e52487f10a5bb","modified":1601799937030},{"_id":"themes/kiss/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1601799641134},{"_id":"themes/kiss/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1601799641134},{"_id":"themes/kiss/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1601799641134},{"_id":"themes/kiss/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1601799641134},{"_id":"themes/kiss/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1601799641134},{"_id":"themes/kiss/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1601799641134},{"_id":"themes/kiss/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1601799641134},{"_id":"themes/kiss/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":1601799641134},{"_id":"themes/kiss/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1601799641135},{"_id":"themes/kiss/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1601799641135},{"_id":"themes/kiss/languages/zh-CN.yml","hash":"f8267838bda21fe171cc48be2685fe06ecbb1710","modified":1601799641135},{"_id":"themes/kiss/languages/zh-TW.yml","hash":"12dd28bb29235f824f2a37cf375c1da0f4f29118","modified":1601799641135},{"_id":"themes/kiss/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1601799641138},{"_id":"themes/kiss/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1601799641139},{"_id":"themes/kiss/layout/layout.ejs","hash":"f155824ca6130080bb057fa3e868a743c69c4cf5","modified":1601799641139},{"_id":"themes/kiss/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1601799641139},{"_id":"themes/kiss/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1601799641139},{"_id":"themes/kiss/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1601799641139},{"_id":"themes/kiss/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1601799641139},{"_id":"themes/kiss/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1601799641140},{"_id":"source/_posts/it/.DS_Store","hash":"c03c0c240bf5c1f8ad0e26b885edaa748d1b410b","modified":1606890093695},{"_id":"source/_posts/music/listen-chopin-raindrop.md","hash":"7fb35e7aa7b25c8e84ccb612e932c13765702406","modified":1602431193810},{"_id":"themes/kiss/layout/_partial/after-footer.ejs","hash":"c8a0b16aa29466bf4c288b48a4b458b2ac69ada7","modified":1601799641135},{"_id":"themes/kiss/layout/_partial/archive.ejs","hash":"950ddd91db8718153b329b96dc14439ab8463ba5","modified":1601799641136},{"_id":"themes/kiss/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1601799641135},{"_id":"themes/kiss/layout/_partial/article.ejs","hash":"e5654ca2792242a24af1f79501b29b64160c60cb","modified":1606880318990},{"_id":"themes/kiss/layout/_partial/footer.ejs","hash":"93518893cf91287e797ebac543c560e2a63b8d0e","modified":1601799641136},{"_id":"themes/kiss/layout/_partial/gauges-analytics.ejs","hash":"aad6312ac197d6c5aaf2104ac863d7eba46b772a","modified":1601799641136},{"_id":"themes/kiss/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1601799641136},{"_id":"themes/kiss/layout/_partial/head.ejs","hash":"7421e44e34672c6e5232ea3e322584065e3ada9b","modified":1601799641136},{"_id":"themes/kiss/layout/_partial/header.ejs","hash":"29dc712318c3d64ea9d7603300738d23f5b9e5cc","modified":1601799641136},{"_id":"themes/kiss/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1601799641136},{"_id":"themes/kiss/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1601799641138},{"_id":"themes/kiss/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1601799641138},{"_id":"themes/kiss/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1601799641138},{"_id":"themes/kiss/layout/_widget/recent_posts.ejs","hash":"0d4f064733f8b9e45c0ce131fe4a689d570c883a","modified":1601799641138},{"_id":"themes/kiss/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1601799641138},{"_id":"themes/kiss/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1601799641138},{"_id":"themes/kiss/source/css/_extend.styl","hash":"3d0095dfc6c3aaf7028de1aace2599bcb99ede82","modified":1601815652647},{"_id":"themes/kiss/source/css/_variables.styl","hash":"85e17c5ca19f637cec560471c40df8afefc95d77","modified":1606892006651},{"_id":"themes/kiss/source/css/style.styl","hash":"d480f717465970cf6dfccdb6d1af18fba16cbdd0","modified":1602752265510},{"_id":"themes/kiss/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1601799641146},{"_id":"themes/kiss/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1601799641146},{"_id":"themes/kiss/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1601799641147},{"_id":"themes/kiss/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1601799641147},{"_id":"themes/kiss/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1601799641148},{"_id":"themes/kiss/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1601799641147},{"_id":"themes/kiss/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1601799641147},{"_id":"themes/kiss/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1601799641148},{"_id":"themes/kiss/source/js/script.js","hash":"63c21efc77abda2eec546d66ee832fc9776edabd","modified":1601799641149},{"_id":"themes/kiss/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1601799641148},{"_id":"source/_posts/it/java/.DS_Store","hash":"dd05cb1dde09d907c093caa93c9baf6fb341fefb","modified":1606892217046},{"_id":"source/_posts/it/java/java-basic.md","hash":"e01d3690bacabf7e4314f99647f91247cf88b98a","modified":1606892732442},{"_id":"source/_posts/it/java/java-collection.md","hash":"b47e5e923d21f219c06ba637be94690344e2decf","modified":1606892616480},{"_id":"source/_posts/language/jp/keitai-de-nihongo.md","hash":"2994a4af2a4564ee62399b2d745f6325ddfb9f6e","modified":1601808183780},{"_id":"source/_posts/language/min/sigêng-giamgia.md","hash":"f188d37b6057097009967e65a93ffc6a5e6d8a37","modified":1602030872609},{"_id":"source/_posts/language/min/teochew-kahtsi-vowel.md","hash":"5a3919731e7eb4099de64471b0910bb9626fe7a4","modified":1606879961725},{"_id":"source/_posts/language/min/teochew-opera-ghêgdengcung.md","hash":"a0e7f18033c2875451a885af7263d903692123e5","modified":1602777096531},{"_id":"source/_posts/music/listen-chopin-raindrop/piano-keys.gif","hash":"db1a2b3d591cfb88fe67069f81b91746aa38039a","modified":1602427784286},{"_id":"source/_posts/music/listen-chopin-raindrop/cdefgab.jpg","hash":"ce62e60f342c7565b3836eaeffe1bdcdb8e25fb1","modified":1602427784244},{"_id":"themes/kiss/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1601799641137},{"_id":"themes/kiss/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1601799641137},{"_id":"themes/kiss/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1601799641137},{"_id":"themes/kiss/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1601799641137},{"_id":"themes/kiss/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1601799641137},{"_id":"themes/kiss/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1601799641137},{"_id":"themes/kiss/source/css/_partial/archive.styl","hash":"82f3417081c67faef39660762eef606a147c13b5","modified":1601799641140},{"_id":"themes/kiss/source/css/_partial/article.styl","hash":"e57d5e442d980d408393ea742a767ed1546f7d77","modified":1606881806252},{"_id":"themes/kiss/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1601799641140},{"_id":"themes/kiss/source/css/_partial/footer.styl","hash":"2fa87c61bd4f464276719a5361fc2b37c4c0762b","modified":1601799641140},{"_id":"themes/kiss/source/css/_partial/header.styl","hash":"69c914cefed9e3427802a8ea7332b2aebade2627","modified":1601799641141},{"_id":"themes/kiss/source/css/_partial/highlight.styl","hash":"519d0b0f1f34ca0b3aa1a92eae3202c27db55f60","modified":1601799641141},{"_id":"themes/kiss/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1601799641141},{"_id":"themes/kiss/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1601799641141},{"_id":"themes/kiss/source/css/_partial/sidebar.styl","hash":"f5c4f4f9875693ff0f851838662639c01877450f","modified":1601799641141},{"_id":"themes/kiss/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1601799641141},{"_id":"themes/kiss/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1601799641141},{"_id":"themes/kiss/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1601799641141},{"_id":"themes/kiss/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1601799641142},{"_id":"themes/kiss/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1601799641142},{"_id":"themes/kiss/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1601799641145},{"_id":"themes/kiss/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1601799641147},{"_id":"themes/kiss/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1601799641147},{"_id":"themes/kiss/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1601799641148},{"_id":"themes/kiss/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1601799641147},{"_id":"themes/kiss/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1601799641148},{"_id":"themes/kiss/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1601799641148},{"_id":"themes/kiss/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1601799641144},{"_id":"source/_drafts/language/han/writing/chinese-honorific-for-work-mail.md","hash":"668053054f6ad62a131f7222abf563555398716c","modified":1601797714818},{"_id":"source/_posts/it/java/java-basic/20201114_101407.png","hash":"1cdd3a0dc66cb17e34926515dbd121738708761c","modified":1606891814779},{"_id":"source/_posts/it/java/java-collection/Untitled 1.png","hash":"bd4f8e27ff98fce5547f1f4b277ad4debc4f2ca9","modified":1606863364000},{"_id":"source/_posts/it/java/java-collection/Untitled 2.png","hash":"7ff8b589f12130fb2e71530aa5e43aff912ac2a6","modified":1606863364000},{"_id":"source/_posts/it/java/java-collection/Untitled 3.png","hash":"b032986e28a9202479cd743464809b53668cd6b4","modified":1606863364000},{"_id":"source/_posts/language/min/sigêng-giamgia/202010060948.jpg","hash":"abcd4e4bc5aeb9b8a1263329adae6b525101d7f6","modified":1602030864493},{"_id":"source/_posts/it/java/java-basic/Untitled.png","hash":"7feeb782152cb8ddc3c2fb39626145920a92062a","modified":1606861210000},{"_id":"source/_posts/it/java/java-collection/Untitled 6.png","hash":"e31adbdb1887144a8308143ae300d74e0eda4180","modified":1606863364000},{"_id":"themes/kiss/source/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1601799641144},{"_id":"source/_drafts/language/han/writing/chinese-honorific-for-work-mail/公函一.jpg","hash":"d10d31eb05040d107d206044be07d19ee641c6d7","modified":1601797714824},{"_id":"source/_drafts/program/dev/lang/js/js-startup.md","hash":"1002895f270f47c232e292ca5c3e0b5e25e3e5ef","modified":1601797714828},{"_id":"source/_posts/it/java/java-basic/Untitled 1.png","hash":"b0ff3f9c9afb47aa3ec4ae861b96f91ba225de2a","modified":1606861210000},{"_id":"source/_posts/it/java/java-basic/20201202_24328.png","hash":"c992fe54e126ad45512d012b8bf6dcb6a5e36533","modified":1606891792361},{"_id":"themes/kiss/source/css/images/moon.jpg","hash":"798c8924ee26b8f402054d6ed5743a18ba9226df","modified":1601799641146},{"_id":"source/_drafts/language/han/writing/chinese-honorific-for-work-mail/公函二.jpg","hash":"dca3c41d60237ef9b62cb631b3964a3b04185a3d","modified":1601797714825},{"_id":"source/_drafts/language/han/writing/chinese-honorific-for-work-mail/快雪時晴帖.jpg","hash":"2c79022ec7ab1a4928b449c86cf58c4718905bb7","modified":1601797714825},{"_id":"source/_posts/it/java/java-collection/Untitled 4.png","hash":"2ddf731a2d67a0b5ff4ee6fbe7f77c5e0afcb484","modified":1606863364000},{"_id":"source/_drafts/language/han/writing/chinese-honorific-for-work-mail/现代电子邮件公函格式.jpg","hash":"b3c15b50a69e62e182066cdb4b4ad465b6a56676","modified":1601797714826},{"_id":"source/_posts/language/min/sigêng-giamgia/蒹葭.m4a","hash":"9b489081647694ae1fa69bf4712934565c8a11e3","modified":1602028632941},{"_id":"source/_posts/it/java/java-collection/Untitled 5.png","hash":"922d23d15cb96dffebb5d71187bc17d8f61ae1a1","modified":1606863364000},{"_id":"source/_posts/it/java/java-basic/Untitled 4.png","hash":"af3906ce47f968ea8aded65e377c5f643aa110a8","modified":1606861210000},{"_id":"source/_drafts/language/han/writing/chinese-honorific-for-work-mail/中文祝颂词分析.jpg","hash":"8ddc17087266a2ef508341e90ca00365df9cc913","modified":1601797714823},{"_id":"source/_drafts/language/han/writing/chinese-honorific-for-work-mail/陈寅恪致函傅斯年.jpg","hash":"f4f266f6b36ed5fa4dc5e94e03bfb76ee134f472","modified":1601797714827},{"_id":"source/_posts/it/java/java-basic/Untitled 3.png","hash":"f21a829671bd0c8e3bcab7d20e7a390363509871","modified":1606861210000},{"_id":"source/_drafts/language/han/writing/chinese-honorific-for-work-mail/english-mail-example.jpg","hash":"b4f4c98ed766e33187cdcb6c9e0cf5bf9a45d9ce","modified":1601797714820},{"_id":"source/_posts/it/java/java-basic/Untitled 2.png","hash":"36b1886c415bc0d597baaa227f833144132032ff","modified":1606861210000},{"_id":"source/_drafts/language/han/writing/chinese-honorific-for-work-mail/jp-mail-example.jpg","hash":"28efcda0e32946377e5ea26a32d886195af0a45e","modified":1601797714822},{"_id":"source/_posts/language/min/teochew-kahtsi-vowel/202010042112.png","hash":"0b9ffd6564070d7d913668a0aa3dfa827eab26e8","modified":1601817258266},{"_id":"source/_posts/it/java/java-collection/Untitled.png","hash":"7a36813b6140feab84abce77938e837272413355","modified":1606863364000},{"_id":"source/_posts/language/min/teochew-opera-ghêgdengcung/2020-10-15-1.11.30.png","hash":"1ff30cad5d55cf8320e0965be31810db278f4522","modified":1602739655500},{"_id":"source/_posts/language/min/teochew-opera-ghêgdengcung/2020-10-15-1.10.20.png","hash":"8fd5a50fb29b7d581d4cc3c99f25aba06d3a9b95","modified":1602739647334},{"_id":"source/_posts/language/min/teochew-opera-ghêgdengcung/2020-10-15-1.12.28.png","hash":"4c88e38f46e12a86b53682f31d3aa56cb8b66e2b","modified":1602739661299},{"_id":"source/_posts/language/min/teochew-opera-ghêgdengcung/2020-10-14-12.41.34.png","hash":"6cfc945d1177754ccf8834ca1be4309bd5b512a7","modified":1602739639687},{"_id":"public/atom.xml","hash":"f8fa4bc07117a9e2bebdfc39a61641a636dbf83f","modified":1606893191283},{"_id":"public/2020/10/11/music/listen-chopin-raindrop/index.html","hash":"1d01cf6def7b45e206e3abb24ba30a914a3457ca","modified":1606893191442},{"_id":"public/2019/09/01/Hello/index.html","hash":"53ce5b8f7d042864ba90565cf0299b4b99b97756","modified":1606893191442},{"_id":"public/archives/index.html","hash":"5a0ce607ef5e8f00d1d224ac4138ebfd36b01c82","modified":1606893191442},{"_id":"public/archives/2019/index.html","hash":"8532d7a7384f83b527219bdeb6067d9b81073ba1","modified":1606893191446},{"_id":"public/archives/2019/09/index.html","hash":"54fefbea19298af7a0b544b788fa27d4e576429f","modified":1606893191447},{"_id":"public/archives/2020/index.html","hash":"a482486b5e40c12a3036a2436f3884b38a953e0e","modified":1606893191448},{"_id":"public/archives/2020/10/index.html","hash":"b2e53001266cb0f03252ca70bed3c3da81812ae7","modified":1606893191448},{"_id":"public/archives/2020/12/index.html","hash":"69c41a7c4562abd5fb862a135b9fb38f32210e15","modified":1606893191448},{"_id":"public/tags/Hello/index.html","hash":"b35b088e6328f16fda5faf72fdaad7671410b98f","modified":1606893191448},{"_id":"public/tags/Java/index.html","hash":"5164f57422772bed3f6b32ab037cbc805b2dd018","modified":1606893191448},{"_id":"public/tags/聆聽音樂/index.html","hash":"54c7062b923df979b3b3ab8992f7ea91d98e379d","modified":1606893191448},{"_id":"public/tags/詩經/index.html","hash":"cec4f9d647d88d5acc0a0e3bf7cd62c9bc9b6cf0","modified":1606893191448},{"_id":"public/tags/甲子話/index.html","hash":"dd1edd4b073636eeb3248454cdb09979a4190185","modified":1606893191448},{"_id":"public/tags/閩南語/index.html","hash":"4c489f584b08981021ac1a98faa03be4a78f41f4","modified":1606893191448},{"_id":"public/tags/日本語/index.html","hash":"f3bcd834d8817fff09d2f38ec5bf9f3a77eaaa10","modified":1606893191448},{"_id":"public/2020/12/02/it/java/java-collection/index.html","hash":"15745257f7e11960aabf13cff9031aa2fa5b9df8","modified":1606893191448},{"_id":"public/2020/12/02/it/java/java-basic/index.html","hash":"1635852c9f3e3ce82eed5bee8983b2b8a4f5a33d","modified":1606893191448},{"_id":"public/2020/10/15/language/min/teochew-opera-ghêgdengcung/index.html","hash":"72b1c675cb610593aaa99ecdb062334aa16d978f","modified":1606893191449},{"_id":"public/2020/10/04/language/min/teochew-kahtsi-vowel/index.html","hash":"3c9af515232a095f1d2e892435e4b874903db71f","modified":1606893191449},{"_id":"public/2020/10/04/language/jp/keitai-de-nihongo/index.html","hash":"37e9543edcc19afbd483d0e777c5cef83943fcc5","modified":1606893191449},{"_id":"public/2020/10/06/language/min/sigêng-giamgia/index.html","hash":"ad89425bc40288dc7077c9d7418d10ed0c85e155","modified":1606893191449},{"_id":"public/index.html","hash":"c7ca3dfde335d6cbe07fb7b025d38571fdff2b71","modified":1606893191449},{"_id":"public/tags/潮劇/index.html","hash":"2ae2bc33845d37abfbac1658ed600bc0466fd258","modified":1606893191456},{"_id":"public/tags/潮州話/index.html","hash":"a49da19de15d61708ff547cea54650719f277cac","modified":1606893191456},{"_id":"public/README.md","hash":"933b824f5bee4a6d4f81fc25d0a683aec450918b","modified":1606893191456},{"_id":"public/robots.txt","hash":"be8d5ab7132ac74a9375439e438b00b8c91e50b4","modified":1606893191457},{"_id":"public/music.png","hash":"3ca73e04c922de92ffb44d6fe4c698720f85b041","modified":1606893191457},{"_id":"public/favicon.png","hash":"d642aaac06571bf73b09872d57213a50e5ace563","modified":1606893191457},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1606893191457},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1606893191457},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1606893191457},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1606893191457},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1606893191457},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1606893191457},{"_id":"public/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1606893191457},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1606893191457},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1606893191457},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1606893191457},{"_id":"public/2020/10/11/music/listen-chopin-raindrop/cdefgab.jpg","hash":"ce62e60f342c7565b3836eaeffe1bdcdb8e25fb1","modified":1606893191457},{"_id":"public/2020/10/11/music/listen-chopin-raindrop/piano-keys.gif","hash":"db1a2b3d591cfb88fe67069f81b91746aa38039a","modified":1606893191457},{"_id":"public/2020/10/06/language/min/sigêng-giamgia/202010060948.jpg","hash":"abcd4e4bc5aeb9b8a1263329adae6b525101d7f6","modified":1606893191457},{"_id":"public/2020/12/02/it/java/java-basic/20201114_101407.png","hash":"1cdd3a0dc66cb17e34926515dbd121738708761c","modified":1606893191457},{"_id":"public/2020/12/02/it/java/java-collection/Untitled 1.png","hash":"bd4f8e27ff98fce5547f1f4b277ad4debc4f2ca9","modified":1606893191458},{"_id":"public/2020/12/02/it/java/java-collection/Untitled 3.png","hash":"b032986e28a9202479cd743464809b53668cd6b4","modified":1606893191458},{"_id":"public/2020/12/02/it/java/java-collection/Untitled 2.png","hash":"7ff8b589f12130fb2e71530aa5e43aff912ac2a6","modified":1606893191458},{"_id":"public/2020/10/04/language/han/writing/chinese-honorific-for-work-mail/公函一.jpg","hash":"d10d31eb05040d107d206044be07d19ee641c6d7","modified":1606893191458},{"_id":"public/2020/10/04/language/han/writing/chinese-honorific-for-work-mail/公函二.jpg","hash":"dca3c41d60237ef9b62cb631b3964a3b04185a3d","modified":1606893191458},{"_id":"public/assets/js/Meting.min.js","hash":"a0585220b918d78649a7893279e1ec4fb5abe835","modified":1606893191458},{"_id":"public/assets/js/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1606893191458},{"_id":"public/assets/css/APlayer.min.css","hash":"07372a2ba507388d0fed166d761b1c2c2a659dce","modified":1606893191458},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1606893192087},{"_id":"public/2020/12/02/it/java/java-basic/Untitled 1.png","hash":"b0ff3f9c9afb47aa3ec4ae861b96f91ba225de2a","modified":1606893192088},{"_id":"public/2020/12/02/it/java/java-basic/20201202_24328.png","hash":"c992fe54e126ad45512d012b8bf6dcb6a5e36533","modified":1606893192088},{"_id":"public/2020/12/02/it/java/java-collection/Untitled 4.png","hash":"2ddf731a2d67a0b5ff4ee6fbe7f77c5e0afcb484","modified":1606893192088},{"_id":"public/2020/12/02/it/java/java-basic/Untitled.png","hash":"7feeb782152cb8ddc3c2fb39626145920a92062a","modified":1606893192088},{"_id":"public/2020/12/02/it/java/java-collection/Untitled 6.png","hash":"e31adbdb1887144a8308143ae300d74e0eda4180","modified":1606893192089},{"_id":"public/2020/10/04/language/han/writing/chinese-honorific-for-work-mail/快雪時晴帖.jpg","hash":"2c79022ec7ab1a4928b449c86cf58c4718905bb7","modified":1606893192089},{"_id":"public/2020/10/04/language/han/writing/chinese-honorific-for-work-mail/现代电子邮件公函格式.jpg","hash":"b3c15b50a69e62e182066cdb4b4ad465b6a56676","modified":1606893192089},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1606893192093},{"_id":"public/js/script.js","hash":"63c21efc77abda2eec546d66ee832fc9776edabd","modified":1606893192093},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1606893192093},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1606893192093},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1606893192093},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1606893192094},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1606893192094},{"_id":"public/css/style.css","hash":"ae96d9dd55eef5176b116477d044755d5b73867c","modified":1606893192094},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1606893192094},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1606893192094},{"_id":"public/2020/10/06/language/min/sigêng-giamgia/蒹葭.m4a","hash":"9b489081647694ae1fa69bf4712934565c8a11e3","modified":1606893192094},{"_id":"public/assets/js/DPlayer.min.js","hash":"490148a22ab2b03a880495cc733ecd1840c02ed6","modified":1606893192094},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1606893192098},{"_id":"public/2020/10/04/language/han/writing/chinese-honorific-for-work-mail/陈寅恪致函傅斯年.jpg","hash":"f4f266f6b36ed5fa4dc5e94e03bfb76ee134f472","modified":1606893192098},{"_id":"public/2020/10/04/language/han/writing/chinese-honorific-for-work-mail/english-mail-example.jpg","hash":"b4f4c98ed766e33187cdcb6c9e0cf5bf9a45d9ce","modified":1606893192098},{"_id":"public/2020/12/02/it/java/java-collection/Untitled 5.png","hash":"922d23d15cb96dffebb5d71187bc17d8f61ae1a1","modified":1606893192103},{"_id":"public/2020/10/04/language/han/writing/chinese-honorific-for-work-mail/中文祝颂词分析.jpg","hash":"8ddc17087266a2ef508341e90ca00365df9cc913","modified":1606893192103},{"_id":"public/2020/10/04/language/han/writing/chinese-honorific-for-work-mail/jp-mail-example.jpg","hash":"28efcda0e32946377e5ea26a32d886195af0a45e","modified":1606893192103},{"_id":"public/2020/12/02/it/java/java-basic/Untitled 4.png","hash":"af3906ce47f968ea8aded65e377c5f643aa110a8","modified":1606893192108},{"_id":"public/2020/12/02/it/java/java-basic/Untitled 3.png","hash":"f21a829671bd0c8e3bcab7d20e7a390363509871","modified":1606893192108},{"_id":"public/css/images/moon.jpg","hash":"798c8924ee26b8f402054d6ed5743a18ba9226df","modified":1606893192111},{"_id":"public/2020/12/02/it/java/java-basic/Untitled 2.png","hash":"36b1886c415bc0d597baaa227f833144132032ff","modified":1606893192113},{"_id":"public/2020/10/04/language/min/teochew-kahtsi-vowel/202010042112.png","hash":"0b9ffd6564070d7d913668a0aa3dfa827eab26e8","modified":1606893192129},{"_id":"public/2020/12/02/it/java/java-collection/Untitled.png","hash":"7a36813b6140feab84abce77938e837272413355","modified":1606893192129},{"_id":"public/2020/10/15/language/min/teochew-opera-ghêgdengcung/2020-10-15-1.11.30.png","hash":"1ff30cad5d55cf8320e0965be31810db278f4522","modified":1606893192157},{"_id":"public/2020/10/15/language/min/teochew-opera-ghêgdengcung/2020-10-15-1.12.28.png","hash":"4c88e38f46e12a86b53682f31d3aa56cb8b66e2b","modified":1606893192161},{"_id":"public/2020/10/15/language/min/teochew-opera-ghêgdengcung/2020-10-15-1.10.20.png","hash":"8fd5a50fb29b7d581d4cc3c99f25aba06d3a9b95","modified":1606893192164},{"_id":"public/2020/10/15/language/min/teochew-opera-ghêgdengcung/2020-10-14-12.41.34.png","hash":"6cfc945d1177754ccf8834ca1be4309bd5b512a7","modified":1606893192175}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"Hello World","date":"2019-09-01T09:02:23.000Z","_content":"\n汝好，世界\n\n幸會，世界\n\n您好，世界\n\nHello World\n\nこんにちは、世界\n\n\n\n\n\n","source":"_posts/Hello.md","raw":"---\ntitle: Hello World\ndate: 2019-09-01 17:02:23\ntags: Hello\n---\n\n汝好，世界\n\n幸會，世界\n\n您好，世界\n\nHello World\n\nこんにちは、世界\n\n\n\n\n\n","slug":"Hello","published":1,"updated":"2020-10-04T08:25:37.030Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cki72psvt0000slw873g9t3yu","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css\"><p>汝好，世界</p>\n<p>幸會，世界</p>\n<p>您好，世界</p>\n<p>Hello World</p>\n<p>こんにちは、世界</p>\n","site":{"data":{}},"excerpt":"","more":"<p>汝好，世界</p>\n<p>幸會，世界</p>\n<p>您好，世界</p>\n<p>Hello World</p>\n<p>こんにちは、世界</p>\n"},{"title":"聆聽音樂：蕭邦之「雨滴」","p":"music/listen-chopin-raindrop","_content":"\n我發現聆聽音樂在提高自身的音樂素養的同時還可以提高自己的想像力，進而提高記憶力，實在是一舉多得。從今往後，我要多多聆聽，多多分享有感覺的音樂吶。\n\n今天點到蕭邦的「雨滴」，其全名爲 Prelude Op. 28 No. 15 Db major (Raindrop)，網易雲音樂上又寫成 Prélude in D:Flat Major, Op. 28, No. 15，是同樣的（繼續讀下去就知道爲什麼），翻譯成中文就是：降 D 大調前奏曲, 作品28之15。先來與君共賞。\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=554424111&auto=1&height=66\"></iframe>\n\n<!--more-->\n\n## 聽後感\n\n正開始時節奏平和而又纏綿多情。在阿爾卑斯山上，夕陽投射在我一家四口的臉上，暖暖的。我們趕著羊群正要回家。此時雲層似乎漸漸厚了起來，天慢慢暗了下來，我們依舊踏著幸福的步伐。\n\n翻過一個山坡之後，烏雲罩日，天昏地暗，狂風暴雨迅猛襲來，羊群四散，叫人難以抵抗，只能作痛苦狀。好不容易到達小木屋，卻發現小木屋被刮走了，我們緊緊地依偎在一起，雨淚俱下。所幸家人都在，生活還可以繼續，曲調又回歸到原本的平靜。\n\n## 音樂筆記\n\n### Prélude\nPrélude：法語，英文爲Prelude， 意爲前奏曲。\n常見的音樂體裁還有：\n- Ballade 敘事曲\n- Concerto 協奏曲\n- Etude 練習曲\n- Fuga 賦格\n- Impromptu 即興曲\n- Menuet 小步舞曲\n- Overture 序曲\n- Prelude 前奏曲\n- Sonata 奏鳴曲\n- String Quartet 弦樂四重奏\n- Suite 組曲\n- Symphony 交響曲\n- Violin Concerto 小提請協奏曲\n- Waltz 圓舞曲\n\n### D Flat / Db\nD Flat / Db：降D\n相關符號有：\n-  ♯ （也用 # 簡記），升號，英文 sharp，表示音高升半個音；\n- ♭（也用 b 簡記），降號，英文 flat，表示音高降低半個音；\n- ♮，還原號，英文natural，表示復歸原先的音高。\n\n### Major\n**major 大調**\n![](cdefgab.jpg)\n名詞解釋：\n- 簡譜：用數字表示音的簡單記譜方式\n- 音名：音的名字\n- 唱名：音的唱法\n- 距離：代表兩個音之間的距離\n- 半音：最靠近的兩個音之間的距離\n- 全音：1全音 = 1半音 + 1半音\n![](piano-keys.gif)\nE－F 之間沒有黑鍵 ，所以 E－F 的距離是半音，B－C 同理。\n\n記憶方法：\n1\tDo\tC\t這個不需要想，也很直覺，乾脆就直接背了\n2\tRe\tD\tDouble 跟 Repeat 都可以聯想到 2\n3\tMi\tE\t3 M E 都長的很像\n4\tFa\tF\t4 的英文單字是 Four\n5\tSol\tG\t你跟別人 Give me five 是用手 (Sol) 來的\n6\tLa\tA\t六的閩南語念成什麼? 尾音 A\n7\tSi\tB\t七夕(Si)。 SB\n\n音與音之間的距離符合全全半全全全半的八個音，就稱為大調音階。例如：\n- C Major：C D E F G A B C\n- Db Major：Db Eb F Gb Ab Bb C Db\n\n**minor 小調**\n音與音之間的距離符合全半全全半全全的八個音，就稱為自然小音階/小調。\n\n### Op. 28 , No. 15\nOp. 28 , No. 15：作品 28 之 15\nOp.，拉丁文 Opus，著作，尤指編號的音樂作品。\nNo.，Number，編號。\n\n## 參考\n1. [ 音階與調性 ](http://www.dancepiano.com/scalechar.aspx \"音階與調性\")\n2. [ 必學基礎樂理：音階/簡譜/音名/唱名 ](https://www.guitar.com.tw/basic-music-theory/ \"必學基礎樂理：音階/簡譜/音名/唱名\")\n3. [ 音階基本概念 ](http://www.rexchow.com/students/theory/music_theory_01_basic_concept_on_scales.pdf \"音階基本概念\")\n\n\n","source":"_posts/music/listen-chopin-raindrop.md","raw":"---\ntitle: 聆聽音樂：蕭邦之「雨滴」\np: music/listen-chopin-raindrop\ntags:\n- 聆聽音樂\n---\n\n我發現聆聽音樂在提高自身的音樂素養的同時還可以提高自己的想像力，進而提高記憶力，實在是一舉多得。從今往後，我要多多聆聽，多多分享有感覺的音樂吶。\n\n今天點到蕭邦的「雨滴」，其全名爲 Prelude Op. 28 No. 15 Db major (Raindrop)，網易雲音樂上又寫成 Prélude in D:Flat Major, Op. 28, No. 15，是同樣的（繼續讀下去就知道爲什麼），翻譯成中文就是：降 D 大調前奏曲, 作品28之15。先來與君共賞。\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=554424111&auto=1&height=66\"></iframe>\n\n<!--more-->\n\n## 聽後感\n\n正開始時節奏平和而又纏綿多情。在阿爾卑斯山上，夕陽投射在我一家四口的臉上，暖暖的。我們趕著羊群正要回家。此時雲層似乎漸漸厚了起來，天慢慢暗了下來，我們依舊踏著幸福的步伐。\n\n翻過一個山坡之後，烏雲罩日，天昏地暗，狂風暴雨迅猛襲來，羊群四散，叫人難以抵抗，只能作痛苦狀。好不容易到達小木屋，卻發現小木屋被刮走了，我們緊緊地依偎在一起，雨淚俱下。所幸家人都在，生活還可以繼續，曲調又回歸到原本的平靜。\n\n## 音樂筆記\n\n### Prélude\nPrélude：法語，英文爲Prelude， 意爲前奏曲。\n常見的音樂體裁還有：\n- Ballade 敘事曲\n- Concerto 協奏曲\n- Etude 練習曲\n- Fuga 賦格\n- Impromptu 即興曲\n- Menuet 小步舞曲\n- Overture 序曲\n- Prelude 前奏曲\n- Sonata 奏鳴曲\n- String Quartet 弦樂四重奏\n- Suite 組曲\n- Symphony 交響曲\n- Violin Concerto 小提請協奏曲\n- Waltz 圓舞曲\n\n### D Flat / Db\nD Flat / Db：降D\n相關符號有：\n-  ♯ （也用 # 簡記），升號，英文 sharp，表示音高升半個音；\n- ♭（也用 b 簡記），降號，英文 flat，表示音高降低半個音；\n- ♮，還原號，英文natural，表示復歸原先的音高。\n\n### Major\n**major 大調**\n![](cdefgab.jpg)\n名詞解釋：\n- 簡譜：用數字表示音的簡單記譜方式\n- 音名：音的名字\n- 唱名：音的唱法\n- 距離：代表兩個音之間的距離\n- 半音：最靠近的兩個音之間的距離\n- 全音：1全音 = 1半音 + 1半音\n![](piano-keys.gif)\nE－F 之間沒有黑鍵 ，所以 E－F 的距離是半音，B－C 同理。\n\n記憶方法：\n1\tDo\tC\t這個不需要想，也很直覺，乾脆就直接背了\n2\tRe\tD\tDouble 跟 Repeat 都可以聯想到 2\n3\tMi\tE\t3 M E 都長的很像\n4\tFa\tF\t4 的英文單字是 Four\n5\tSol\tG\t你跟別人 Give me five 是用手 (Sol) 來的\n6\tLa\tA\t六的閩南語念成什麼? 尾音 A\n7\tSi\tB\t七夕(Si)。 SB\n\n音與音之間的距離符合全全半全全全半的八個音，就稱為大調音階。例如：\n- C Major：C D E F G A B C\n- Db Major：Db Eb F Gb Ab Bb C Db\n\n**minor 小調**\n音與音之間的距離符合全半全全半全全的八個音，就稱為自然小音階/小調。\n\n### Op. 28 , No. 15\nOp. 28 , No. 15：作品 28 之 15\nOp.，拉丁文 Opus，著作，尤指編號的音樂作品。\nNo.，Number，編號。\n\n## 參考\n1. [ 音階與調性 ](http://www.dancepiano.com/scalechar.aspx \"音階與調性\")\n2. [ 必學基礎樂理：音階/簡譜/音名/唱名 ](https://www.guitar.com.tw/basic-music-theory/ \"必學基礎樂理：音階/簡譜/音名/唱名\")\n3. [ 音階基本概念 ](http://www.rexchow.com/students/theory/music_theory_01_basic_concept_on_scales.pdf \"音階基本概念\")\n\n\n","slug":"music/listen-chopin-raindrop","published":1,"date":"2020-10-11T14:44:31.951Z","updated":"2020-10-11T15:46:33.810Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cki72pswu0003slw8s5csnat6","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css\"><p>我發現聆聽音樂在提高自身的音樂素養的同時還可以提高自己的想像力，進而提高記憶力，實在是一舉多得。從今往後，我要多多聆聽，多多分享有感覺的音樂吶。</p>\n<p>今天點到蕭邦的「雨滴」，其全名爲 Prelude Op. 28 No. 15 Db major (Raindrop)，網易雲音樂上又寫成 Prélude in D:Flat Major, Op. 28, No. 15，是同樣的（繼續讀下去就知道爲什麼），翻譯成中文就是：降 D 大調前奏曲, 作品28之15。先來與君共賞。</p>\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=554424111&auto=1&height=66\"></iframe>\n\n<a id=\"more\"></a>\n\n<h2 id=\"聽後感\"><a href=\"#聽後感\" class=\"headerlink\" title=\"聽後感\"></a>聽後感</h2><p>正開始時節奏平和而又纏綿多情。在阿爾卑斯山上，夕陽投射在我一家四口的臉上，暖暖的。我們趕著羊群正要回家。此時雲層似乎漸漸厚了起來，天慢慢暗了下來，我們依舊踏著幸福的步伐。</p>\n<p>翻過一個山坡之後，烏雲罩日，天昏地暗，狂風暴雨迅猛襲來，羊群四散，叫人難以抵抗，只能作痛苦狀。好不容易到達小木屋，卻發現小木屋被刮走了，我們緊緊地依偎在一起，雨淚俱下。所幸家人都在，生活還可以繼續，曲調又回歸到原本的平靜。</p>\n<h2 id=\"音樂筆記\"><a href=\"#音樂筆記\" class=\"headerlink\" title=\"音樂筆記\"></a>音樂筆記</h2><h3 id=\"Prelude\"><a href=\"#Prelude\" class=\"headerlink\" title=\"Prélude\"></a>Prélude</h3><p>Prélude：法語，英文爲Prelude， 意爲前奏曲。<br>常見的音樂體裁還有：</p>\n<ul>\n<li>Ballade 敘事曲</li>\n<li>Concerto 協奏曲</li>\n<li>Etude 練習曲</li>\n<li>Fuga 賦格</li>\n<li>Impromptu 即興曲</li>\n<li>Menuet 小步舞曲</li>\n<li>Overture 序曲</li>\n<li>Prelude 前奏曲</li>\n<li>Sonata 奏鳴曲</li>\n<li>String Quartet 弦樂四重奏</li>\n<li>Suite 組曲</li>\n<li>Symphony 交響曲</li>\n<li>Violin Concerto 小提請協奏曲</li>\n<li>Waltz 圓舞曲</li>\n</ul>\n<h3 id=\"D-Flat-Db\"><a href=\"#D-Flat-Db\" class=\"headerlink\" title=\"D Flat / Db\"></a>D Flat / Db</h3><p>D Flat / Db：降D<br>相關符號有：</p>\n<ul>\n<li>♯ （也用 # 簡記），升號，英文 sharp，表示音高升半個音；</li>\n<li>♭（也用 b 簡記），降號，英文 flat，表示音高降低半個音；</li>\n<li>♮，還原號，英文natural，表示復歸原先的音高。</li>\n</ul>\n<h3 id=\"Major\"><a href=\"#Major\" class=\"headerlink\" title=\"Major\"></a>Major</h3><p><strong>major 大調</strong><br><img src=\"/2020/10/11/music/listen-chopin-raindrop/cdefgab.jpg\" alt><br>名詞解釋：</p>\n<ul>\n<li>簡譜：用數字表示音的簡單記譜方式</li>\n<li>音名：音的名字</li>\n<li>唱名：音的唱法</li>\n<li>距離：代表兩個音之間的距離</li>\n<li>半音：最靠近的兩個音之間的距離</li>\n<li>全音：1全音 = 1半音 + 1半音<br><img src=\"/2020/10/11/music/listen-chopin-raindrop/piano-keys.gif\" alt><br>E－F 之間沒有黑鍵 ，所以 E－F 的距離是半音，B－C 同理。</li>\n</ul>\n<p>記憶方法：<br>1    Do    C    這個不需要想，也很直覺，乾脆就直接背了<br>2    Re    D    Double 跟 Repeat 都可以聯想到 2<br>3    Mi    E    3 M E 都長的很像<br>4    Fa    F    4 的英文單字是 Four<br>5    Sol    G    你跟別人 Give me five 是用手 (Sol) 來的<br>6    La    A    六的閩南語念成什麼? 尾音 A<br>7    Si    B    七夕(Si)。 SB</p>\n<p>音與音之間的距離符合全全半全全全半的八個音，就稱為大調音階。例如：</p>\n<ul>\n<li>C Major：C D E F G A B C</li>\n<li>Db Major：Db Eb F Gb Ab Bb C Db</li>\n</ul>\n<p><strong>minor 小調</strong><br>音與音之間的距離符合全半全全半全全的八個音，就稱為自然小音階/小調。</p>\n<h3 id=\"Op-28-No-15\"><a href=\"#Op-28-No-15\" class=\"headerlink\" title=\"Op. 28 , No. 15\"></a>Op. 28 , No. 15</h3><p>Op. 28 , No. 15：作品 28 之 15<br>Op.，拉丁文 Opus，著作，尤指編號的音樂作品。<br>No.，Number，編號。</p>\n<h2 id=\"參考\"><a href=\"#參考\" class=\"headerlink\" title=\"參考\"></a>參考</h2><ol>\n<li><a href=\"http://www.dancepiano.com/scalechar.aspx\" title=\"音階與調性\" target=\"_blank\" rel=\"noopener\"> 音階與調性 </a></li>\n<li><a href=\"https://www.guitar.com.tw/basic-music-theory/\" title=\"必學基礎樂理：音階/簡譜/音名/唱名\" target=\"_blank\" rel=\"noopener\"> 必學基礎樂理：音階/簡譜/音名/唱名 </a></li>\n<li><a href=\"http://www.rexchow.com/students/theory/music_theory_01_basic_concept_on_scales.pdf\" title=\"音階基本概念\" target=\"_blank\" rel=\"noopener\"> 音階基本概念 </a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>我發現聆聽音樂在提高自身的音樂素養的同時還可以提高自己的想像力，進而提高記憶力，實在是一舉多得。從今往後，我要多多聆聽，多多分享有感覺的音樂吶。</p>\n<p>今天點到蕭邦的「雨滴」，其全名爲 Prelude Op. 28 No. 15 Db major (Raindrop)，網易雲音樂上又寫成 Prélude in D:Flat Major, Op. 28, No. 15，是同樣的（繼續讀下去就知道爲什麼），翻譯成中文就是：降 D 大調前奏曲, 作品28之15。先來與君共賞。</p>\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=554424111&auto=1&height=66\"></iframe>","more":"<h2 id=\"聽後感\"><a href=\"#聽後感\" class=\"headerlink\" title=\"聽後感\"></a>聽後感</h2><p>正開始時節奏平和而又纏綿多情。在阿爾卑斯山上，夕陽投射在我一家四口的臉上，暖暖的。我們趕著羊群正要回家。此時雲層似乎漸漸厚了起來，天慢慢暗了下來，我們依舊踏著幸福的步伐。</p>\n<p>翻過一個山坡之後，烏雲罩日，天昏地暗，狂風暴雨迅猛襲來，羊群四散，叫人難以抵抗，只能作痛苦狀。好不容易到達小木屋，卻發現小木屋被刮走了，我們緊緊地依偎在一起，雨淚俱下。所幸家人都在，生活還可以繼續，曲調又回歸到原本的平靜。</p>\n<h2 id=\"音樂筆記\"><a href=\"#音樂筆記\" class=\"headerlink\" title=\"音樂筆記\"></a>音樂筆記</h2><h3 id=\"Prelude\"><a href=\"#Prelude\" class=\"headerlink\" title=\"Prélude\"></a>Prélude</h3><p>Prélude：法語，英文爲Prelude， 意爲前奏曲。<br>常見的音樂體裁還有：</p>\n<ul>\n<li>Ballade 敘事曲</li>\n<li>Concerto 協奏曲</li>\n<li>Etude 練習曲</li>\n<li>Fuga 賦格</li>\n<li>Impromptu 即興曲</li>\n<li>Menuet 小步舞曲</li>\n<li>Overture 序曲</li>\n<li>Prelude 前奏曲</li>\n<li>Sonata 奏鳴曲</li>\n<li>String Quartet 弦樂四重奏</li>\n<li>Suite 組曲</li>\n<li>Symphony 交響曲</li>\n<li>Violin Concerto 小提請協奏曲</li>\n<li>Waltz 圓舞曲</li>\n</ul>\n<h3 id=\"D-Flat-Db\"><a href=\"#D-Flat-Db\" class=\"headerlink\" title=\"D Flat / Db\"></a>D Flat / Db</h3><p>D Flat / Db：降D<br>相關符號有：</p>\n<ul>\n<li>♯ （也用 # 簡記），升號，英文 sharp，表示音高升半個音；</li>\n<li>♭（也用 b 簡記），降號，英文 flat，表示音高降低半個音；</li>\n<li>♮，還原號，英文natural，表示復歸原先的音高。</li>\n</ul>\n<h3 id=\"Major\"><a href=\"#Major\" class=\"headerlink\" title=\"Major\"></a>Major</h3><p><strong>major 大調</strong><br><img src=\"/2020/10/11/music/listen-chopin-raindrop/cdefgab.jpg\" alt><br>名詞解釋：</p>\n<ul>\n<li>簡譜：用數字表示音的簡單記譜方式</li>\n<li>音名：音的名字</li>\n<li>唱名：音的唱法</li>\n<li>距離：代表兩個音之間的距離</li>\n<li>半音：最靠近的兩個音之間的距離</li>\n<li>全音：1全音 = 1半音 + 1半音<br><img src=\"/2020/10/11/music/listen-chopin-raindrop/piano-keys.gif\" alt><br>E－F 之間沒有黑鍵 ，所以 E－F 的距離是半音，B－C 同理。</li>\n</ul>\n<p>記憶方法：<br>1    Do    C    這個不需要想，也很直覺，乾脆就直接背了<br>2    Re    D    Double 跟 Repeat 都可以聯想到 2<br>3    Mi    E    3 M E 都長的很像<br>4    Fa    F    4 的英文單字是 Four<br>5    Sol    G    你跟別人 Give me five 是用手 (Sol) 來的<br>6    La    A    六的閩南語念成什麼? 尾音 A<br>7    Si    B    七夕(Si)。 SB</p>\n<p>音與音之間的距離符合全全半全全全半的八個音，就稱為大調音階。例如：</p>\n<ul>\n<li>C Major：C D E F G A B C</li>\n<li>Db Major：Db Eb F Gb Ab Bb C Db</li>\n</ul>\n<p><strong>minor 小調</strong><br>音與音之間的距離符合全半全全半全全的八個音，就稱為自然小音階/小調。</p>\n<h3 id=\"Op-28-No-15\"><a href=\"#Op-28-No-15\" class=\"headerlink\" title=\"Op. 28 , No. 15\"></a>Op. 28 , No. 15</h3><p>Op. 28 , No. 15：作品 28 之 15<br>Op.，拉丁文 Opus，著作，尤指編號的音樂作品。<br>No.，Number，編號。</p>\n<h2 id=\"參考\"><a href=\"#參考\" class=\"headerlink\" title=\"參考\"></a>參考</h2><ol>\n<li><a href=\"http://www.dancepiano.com/scalechar.aspx\" title=\"音階與調性\" target=\"_blank\" rel=\"noopener\"> 音階與調性 </a></li>\n<li><a href=\"https://www.guitar.com.tw/basic-music-theory/\" title=\"必學基礎樂理：音階/簡譜/音名/唱名\" target=\"_blank\" rel=\"noopener\"> 必學基礎樂理：音階/簡譜/音名/唱名 </a></li>\n<li><a href=\"http://www.rexchow.com/students/theory/music_theory_01_basic_concept_on_scales.pdf\" title=\"音階基本概念\" target=\"_blank\" rel=\"noopener\"> 音階基本概念 </a></li>\n</ol>"},{"title":"Java 基礎","p":"it/java/java-basic.md","_content":"\nJava 自 95 年誕生至今，已有 25 年的歷史。它是一種半編譯的語言，先將代碼編譯成字節碼，然後在 JVM 中解釋執行。\n\n- 它是一種面向對象的語言，封裝、繼承和多態它都有，類可以多實現但不支持多繼承，而接口可以多繼承。\n- 它支持 8 種基本數據類型，同時還提供了其包裝類型，另外還提供了 BigDecimal 精確處理浮點數、提供了 BigInteger 處理大整數。\n- 它的方法只有值傳遞，傳遞對象時它是淺拷貝而非深拷貝。類的方法可以被子類重寫，同個類可以有多個同名的重載方法。\n- 它支持泛型，一種將類型參數化的技術。不過，也有人稱之爲「僞泛型」，因爲類型會在編譯時被擦除。\n- 它支持反射，一種在運行時操作任意對象的方法和屬性的技術，這在框架應用中很常見。\n- 它提供了豐富的集合類、迭代器及工具類。\n- 它支持多線程，一種在程序進程中同時執行多個任務的技術，同時還有豐富的鎖類型，所有對象的頭信息裏都有一個鎖標識。\n- 它支持異常處理，Exception 分編譯時異常和運行時異常，編譯時異常可以被編譯器檢查到，而運行時異常只能在程序運行時發生。\n- 它有豐富的 I/O API，派生自 4 個抽象類，InputStream、OutputStream、Reader、Writer，字符流的出現是爲了減少 JVM 進行字符編碼解碼的資源損耗和編解碼錯誤。\n- 另外，目前有兩大項目管理工具，Maven 和 Gradle。\n\n<!-- more -->\n\n## Java 入門（基礎概念與常識）\n\n### 歷史\n\nJava 編程語言本名爲 oak（橡樹），因爲商標被註冊了，所以更名爲 Java，而 Java 是印尼的一座島嶼，盛產咖啡豆，有一種咖啡就是以該島命名，Java 編程語言之名因之。使用十六進制編輯器打開 class 文件時會發現前 32 位顯示爲 `CA FE BA BE` ，即 cafe babe （咖啡寶貝）。\n\n```java\n$ hexdump Test.class\n0000000 ca fe ba be 00 00 00 3b 00 51 0a 00 02 00 03 07\n```\n\n- 1994 年完成 1.0 版本。\n- 1995 年首次對外發佈，Java 語言誕生。\n- 1996 年JDK 1.0 誕生。\n- 2004 年 SUN 公司發佈 Java SE 5。\n- 2005 年 SUN 公司發佈 Java SE 6。\n- 2006 年 SUN 公司推出 OpenJDK 計劃。\n- 2014年 Oracle 公司發佈 Java SE 8。\n- 2017年 Oracle公司發佈 Java SE 9。\n- 2020 年 Oracle 公司發佈 Java SE 15。\n\n### 安裝與卸載JDK\n\n在 Mac 環境下，從 [Oracle JavaSE 下載地址](https://www.oracle.com/tw/java/technologies/javase-downloads.html) 下載並安裝。安裝完成後執行 `java -version`  可查看安裝的版本，以確認安裝成功。安裝後的Java Home 位置爲 `/Library/Java/JavaVirtualMachines/jdk-9.0.1.jdk/Contents/Home` 。如需卸載該 jdk，可安裝以下 shell 命令，先移除插件後根據查詢到的 jdk 版本移除整個 jdk 文件夾即可。\n\n```bash\nsudo rm -fr /Library/Internet\\ Plug-Ins/JavaAppletPlugin.plugin\nsudo rm -fr /Library/PreferencesPanes/JavaControlPanel.prefpane\n\nls /Library/Java/JavaVirtualMachines/\n输出：jdk-9.0.1.jdk\n\nsudo rm -rf /Library/Java/JavaVirtualMachines/jdk-9.0.1.jdk\n```\n\n### Hello World\n\n運行以下代碼，將輸出 `Hello World`。\n\n```java\npackage hello;\n\npublic class Hello {\n    public static void main(String[] args) {\n        System.out.println(\"Hello World\");\n    }\n}\n```\n\n### Java 語言的特點\n\n1. 面向對象（封裝，繼承，多態）\n2. 平台無關性（ Java 虛擬機實現平台無關性）\n3. 支持多線程\n4. 編譯與解釋並存\n\n編譯：生成字節碼(.class文件)，javac 指令。\n解釋：解釋字節碼成機器碼，java 指令。\n\n### JVM、JDK 和  JRE\n\n1. JVM，Java Virtual Machine 的縮寫，即 Java 虛擬機，是運行 Java 字節碼的虛擬機（包含解釋器 java），它包含在 JRE 中。不同的操作系統有特定的 JVM 實現，以便 Java 字節碼可以跨平台。\n2. JDK，Java Development Kit 的縮寫，即 Java 開發工具集，包含了 JRE 、編譯器（javac）和其他工具（javadoc 和 jdb 等）。\n3. JRE，Java Runtime 的縮寫，即 Java 運行時，包含了 JVM、必要的類庫、java 命令和其他基礎構件。\n\n### Java 與 C++ 對比\n\n1. 皆支持面向對象編程（封裝、繼承和多態）。\n2. Java 不提供指針來直接訪問內存；C++ 提供。\n3. Java 的類不支持多繼承，但接口可以；C++ 的類可以多繼承。\n4. Java 有內存垃圾自動回收機制（GC），不需要手動釋放無用內存；C++ 沒有。\n5. Java 字符串和字符數組沒有結束符的概念；C/C++ 中字符串和字符數組最後會有一個額外的字符`\\0` 來表示結束。\n\n## Java 語法\n\n### 基本類型及其大小\n\nJava 共 8 種數據類型（不包括 void），具體如下表：\n\n![](java_basic/20201202_24328.png)\n\nboolean 值的大小取決於 JVM 實現，Java 虛擬機規範（第8版）規定：單個 boolean佔 4 個字節，而 boolean 數組 1 個字節。\n\nchar 值是一個 16 位的 Unicode 字符，最小值是 '\\u0000' ，最大值是 '\\uffff'，即 0～65535，每個數字對應一個字符。\n\n- 代碼\n\n    ```java\n    char a = '中';\n    System.out.println((int)a);\n    // 輸出 20013\n    System.out.println(Integer.toHexString(a));\n    // 輸出 4e2d\n    System.out.println('\\u4e2d');\n    // 輸出 中\n    ```\n\nbyte、short、int、long 類型，採用二進制補碼存儲數據，以便利減法運算。\n\n- 二進制補碼\n    - 過程：正數的補碼是其自身；負數的補碼是除符號位外所有二進制位做反碼後加 1 的結果。\n    - 原理：假定 X、Y 是两个占1个字节的数。X-Y 等价于 X+(-Y) ，而 -Y 可以看作 0-Y，假定是 0 不足以被减，向上借 1 变为 1 0000 0000，而  1 0000 0000 又等價於 1111 1111 + 1，於是 -Y = 1111 1111 - Y + 1，即 Y 的反碼再 + 1。 見 [https://www.ruanyifeng.com/blog/2009/08/twos_complement.htm](https://www.ruanyifeng.com/blog/2009/08/twos_complement.html)l\n\nlong 類型的數據後面一定要加上 L，否則會被認為是整型。\n\nchar 類型值使用單引號括起來，String 使用雙引號。\n\nJava 有**自動拆裝箱機制**，裝箱即把基本類型使用其包裝類型包裝起來，拆箱即把包裝類型拆成基本類型。\n\n### 包裝類型及常量池技術\n\n1. Byte、Short、Integer 和 Long 分別默認創建了數值 [-128, 127] 的相應類型的緩存數據。\n2. Character 創建了數值在 [0, 127] 的緩存數據。\n3. Boolean 直接返回 True 和 False。\n4. Float 和 Double 沒有實現常量池技術。\n\n使用常量池技術意味著在緩存範圍內的包裝類型對象是相等的，除非 new 一個對象。使用包裝器的 valueOf 方法默認會先去緩存中取對象，取不到才會 new 一個。\n\n```java\nInteger i1 = 33;\nInteger i2 = 33;\nSystem.out.println(i1 == i2);// 输出 true\nInteger i11 = 333;\nInteger i22 = 333;\nSystem.out.println(i11 == i22);// 输出 false\nDouble i3 = 1.2;\nDouble i4 = 1.2;\nSystem.out.println(i3 == i4);// 输出 false\n```\n\n《阿里巴巴Java開發手冊》規定：\n\n- 【強制】**所有的 POJO 類屬性必須使用包裝數據類型**。\n- 【強制】RPC 方法的返回值和參數必須使用包裝數據類型。\n- 【推薦】所有的局部變量使用基本數據類型。\n\n### BigDecimal\n\n**（1）使用 BigDecimal 進行浮點數比較和精度取捨**\n\n**（2）使用 BigDecimal(String) 或 BigDecimal.valueOf(double) 構造對象**\n\n```java\nfloat a = 1.0f - 0.9f;\nfloat b = 0.9f - 0.8f;\nSystem.out.println(a);\nSystem.out.println(b);\nSystem.out.println(a == b); // false\n\nBigDecimal a = new BigDecimal(\"1.0\");\nBigDecimal b = new BigDecimal(\"0.9\");\nBigDecimal c = new BigDecimal(\"0.8\");\nSystem.out.println(a.subtract(b));\nSystem.out.println(b.subtract(c));\nSystem.out.println(a.subtract(b).equals(b.subtract(c))); // true\n\nBigDecimal a = new BigDecimal(\"1.1252312\");\n// 取小數點後 2 位，四捨五入\nBigDecimal scale = a.setScale(2, RoundingMode.HALF_UP);\nSystem.out.println(scale.toString()); // 1.13\n```\n\n### 對象及其大小\n\n基本類型的封裝類型是對象，Java 中的對象由以下部分組成：\n\n1. 對象頭（object header）：由 mark word 和 class pointer 組成。mark word 存儲了對象的 hashcode、GC信息和鎖信息；class pointer 存儲了指向類對象的指針。32 位的 JVM 上對象頭佔 8 個字節，mark word 和 class pointer 各佔一半。64 位的 JVM 默認開啟了壓縮指針選項（-XX+UseCompressedOops）後上對象頭佔用 12 個字節，mark word 佔用 8 個字節，class pointer 佔用 4 個字節。\n2. 實例數據（instance data）：\n3. 對齊填充（padding）\n\n可使用 `org.openjdk.jol` 工具查看一個對象佔用的字節大小，\n\n- 如下：\n\n    ```java\n    public static void main(String[] args){\n        System.out.println(VM.current().details());\n        System.out.println(ClassLayout.parseClass(Object.class).toPrintable());\n        System.out.println(ClassLayout.parseInstance(Integer.valueOf(1)).toPrintable());\n    }\n    ```\n\n    輸出結果：\n\n    ```bash\n    # Running 64-bit HotSpot VM.\n    # Using compressed oop with 3-bit shift.\n    # Using compressed klass with 3-bit shift.\n    # WARNING | Compressed references base/shifts are guessed by the experiment!\n    # WARNING | Therefore, computed addresses are just guesses, and ARE NOT RELIABLE.\n    # WARNING | Make sure to attach Serviceability Agent to get the reliable addresses.\n    # Objects are 8 bytes aligned.\n    # Field sizes by type: 4, 1, 1, 2, 2, 4, 4, 8, 8 [bytes]\n    # Array element sizes: 4, 1, 1, 2, 2, 4, 4, 8, 8 [bytes]\n\n    java.lang.Object object internals:\n     OFFSET  SIZE   TYPE DESCRIPTION                               VALUE\n          0    12        (object header)                           N/A\n         12     4        (loss due to the next object alignment)\n    Instance size: 16 bytes\n    Space losses: 0 bytes internal + 4 bytes external = 4 bytes total\n\n    java.lang.Integer object internals:\n     OFFSET  SIZE   TYPE DESCRIPTION                               VALUE\n          0     4        (object header)                           01 c9 01 4e (00000001 11001001 00000001 01001110) (1308739841)\n          4     4        (object header)                           3d 00 00 00 (00111101 00000000 00000000 00000000) (61)\n          8     4        (object header)                           48 71 00 00 (01001000 01110001 00000000 00000000) (29000)\n         12     4    int Integer.value                             1\n    Instance size: 16 bytes\n    Space losses: 0 bytes internal + 0 bytes external = 0 bytes total\n    ```\n\n結論：在 64 位開啟指針壓縮的環境下，Object 對象佔用 16 個字節，Integer 對象也佔用 16 個字節。\n\n### String、StringBuffer 和 String Builder 的區別\n\nString 類使用 final 修飾字符數組或字節數組來保存字符串，所以 String 對象是不可變的。\n\n```java\npublic final class String {\n\t// Java 9 之前\n\tprivate final char[] value;\n\t// Java 9 之後\n\tprivate final byte[] value;\n}\n```\n\nStringBuilder  和 StringBuffer 都繼承自 AbstractStringBuilder，AbstractStringBuilder 使用字符數組來保存字符串，但沒有使用 final 關鍵字修飾，所以這兩者是可變的。\n\n下面從不同角度比較下此三者：\n\n1. 線程安全性：String 對象不可變，線程安全；StringBuffer 對方法加了同步鎖，線程安全；StringBuilder 對方法沒有加同步鎖，線程不安全。\n2. 性能：每次對 String 類型進行改變時會生成一個新的 String 對象，然後將指針指向新的 String 對象。StringBuffer 和 StringBuilder 每次對自身進行操作，不生成新對象。同等情況下， StringBuilder 比 StringBuffer 能提升 10%～15% 性能，但要冒線程不安全的風險。\n\n### 注釋\n\n代碼即注釋。先讓標識符見名知意，然後再考慮增加注釋。\n\n### 標識符和關鍵字的區別\n\n標識符是程序、類、變量、方法等取的名字，而關鍵字是具備特殊含義的標識符。常見的關鍵字有：\n\n1. 訪問控制：private、protected、public\n2. 類、方法和變量修飾符：abstract、class、extends、final、implements、interface、native、new、static、strictfp、synchronized、transient、volatile\n3. 程序控制：break、continue、return、do、while、if、else、for、instanceof、switch、case、default\n4. 錯誤處理：try、catch、throw、throws、finally\n5. 包相關：import、package\n6. 基本類型：boolean、byte、char、double、float、int、short、null、true、false\n7. 變量引用：super、this、void\n8. 保留字：goto、const\n\n### 自增自減運算符\n\n符號在前先加減再賦值，符號在後先賦值後加減。假定 `a = 1; b = a++` 最後 a 值爲 2，b 值爲 1。\n\n### == 和 equals 的區別\n\n1. 基本數據類型 == 比較的是值，引用數據類型 == 比較的是內存地址。\n2. equals 是 Object 類的方法，如無重寫該方法，則默認使用 == 比較對象，即比較內存地址；String 類重寫了 equals 方法使其比較得是值。\n3. 整型包裝類都應使用 equals 比較大小。\n4. 浮點數之間的等值判斷，基本數據類型不能用==來比較，包裝數據類型不能用 equals 來判斷。\n- 重寫 equals 方法通常同時需要重寫 hashcode 方法，爲什麼？\n\n    hashcode 是 Object 類的一個本地方法，其實現時將對象的內存地址轉爲一個 int 值，不同的對象的 hashcode 可能相同。 HashSet 集合進行元素重複校驗時先比較 hashcode ，當 hashcode 一樣時再調用 equals，提高了校驗效率。因此，如果只重寫 equals 方法而不重寫 hashcode 方法，會出現 equals 返回 true，而 hashcode 不等的情況，這樣如果要求 HashSet 去重就會失敗。\n\n    HashSet 基於 HashMap 實現，HashMap 內部有一哈希表，裏面使用 hashcode 進行散列存儲。\n\n### 序列化時如果有些字段不想序列化，怎麼辦？\n\n使用 transient 關鍵字修飾不想序列化的字段。\n\n### continue、break 和 return 的區別\n\n1. continue：跳出當前這一次循環，繼續下一次循環。\n2. break：跳出整個循環體，繼續執行循環外的語句。\n3. return：跳出所在的方法，結束方法，可以帶一個返回值。\n\n### 泛型、類型擦除和通配符\n\n**泛型的本質是將類型參數化。**Java 的泛型（generics）是 JDK 5 中引入的新特性，還提供了編譯時類型安全檢測機制來檢測非法的類型。但是 Java 的泛型在編譯期間會將泛型信息擦除，即類型擦除，因此也被稱爲**僞泛型**。下面的例子展示了如何在運行期加入非法類型。\n\n```java\nList<Integer> list = new ArrayList<>();\nlist.add(12);\n//這裡直接添加會報錯\n// list.add(\"a\");\nClass<? extends List> clazz = list.getClass();\nMethod add = clazz.getDeclaredMethod(\"add\", Object.class);\n//但是通過反射添加，是可以的\nadd.invoke(list, \"kl\");\nSystem.out.println(list);\n```\n\n泛型分泛型接口、泛型類和泛型方法。泛型類的具體類型通過實例化時傳入，泛型方法的具體類型通過方法調用時傳入的參數確定。\n\n泛型通配符約定：\n\n1. ？ 表示不確定的 Java 類型，用於泛型方法\n2. T（Type）表示確定的一個 Java 類型\n3. K V（Key Value）分別表示映射中的鍵、值\n4. E（Element）表示集合中的一個元素\n5. <? extends A> 上界通配符，表示 A 類型或其子類\n6. <? super A> 下界通配符，表示 A 類型或其父類\n7. <T extends A> 表示 A 類型或其子類的一種\n8. <T extends A & B> 表示 A 類型且B類型的子類的一種\n9. ~~<T super A>~~ \n\n泛型不是協變的，已知 Apple 繼承自 Fruit 的情況下，Plate<Apple> 的引用並不能傳遞給 Plate<Fruit>，但可以傳遞給 Plate<? extends Fruit>。\n\n元素爲 <? extends E> 的集合，只能取出 E，而不能存入 E 及其子類的對象。因爲只能確定該類型是 E 的子類，但具體是哪個子類未知，因此編譯器不允許插入任何 E 或其子類的對象，取出來的時候只能當 E 類型。\n\n```java\npublic static void main(String[] args) {\n  List<? extends A> list = Arrays.asList(new A(), new B());\n  list.add(new A()); // 報錯\n  list.add(new B()); // 報錯\n  A a = list.get(1);\n  System.out.println(a.toString());\n}\n\nstatic class A {\n}\n\nstatic class B extends A {\n}\n```\n\n元素爲 <? super E> 的集合，只能取出 Object，只能存入 E 及其子類的對象。因爲只能確定該類型是 E 的超類，但不知是哪一個超類，所以插入任何 E 及其子類的對象是沒問題的，但是插入 E 的超類就不行了，取出來的時候也只能是 Object，因爲 Object 是一切類的超類。\n\n```java\npublic static void main(String[] args) {\n  List<? super B> list = new ArrayList<>();\n  list.add(new A()); // 報錯\n  list.add(new B());\n  list.add(new C());\n  Object object = list.get(1);\n  System.out.println(object.toString());\n}\n\nstatic class A {\n}\nstatic class B extends A {\n}\nstatic class C extends B{\n}\n```\n\n### 獲取鍵盤輸入數據的常用方法\n\n```java\n// 方法一：使用 Scanner，可以快速確定輸入數據的類型，按空格符分割數據\nScanner scanner = new Scanner(System.in);\nString s = scanner.nextLine();\nSystem.out.println(s);\n\n// 方法二：使用 BufferedReader 讀取字符序列，高效但需要轉換成其他類型，會拋出 IOException\nBufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));\nString s1 = bufferedReader.readLine();\nSystem.out.println(s1);\n```\n\n## 方法（函數）\n\n### 爲什麼 Java 只有值傳遞？\n\n首先要明瞭程序設計語言中的有關函數參數傳遞的兩種方法：\n\n1. 按值調用（call by value）：方法接收調用者提供的參數的值，方法內無法修改實際參數值。\n2. 按引用調用（call by reference）：方法接收調用者提供的參數的地址，方法內可以修改實際參數值。\n\n**Java 總是採用按值調用，所有參數值都是一個拷貝，無法修改實際參數值。對於引用類型參數，傳遞的是引用的拷貝，引用的拷貝和引用指向同一個對象，即所謂的淺拷貝**。\n\n```java\npublic static void main(String[] args) {\n  String s1 = \"Hello\";\n  String s2 = \"World\";\n  swap(s1, s2);\n  System.out.printf(\"main s1: %s, s2: %s%n\", s1, s2);\n}\n\nstatic void swap(String s1, String s2) {\n  String tmp = s1;\n  s1 = s2;\n  s2 = tmp;\n  System.out.printf(\"swap s1: %s, s2: %s%n\", s1, s2);\n}\n// 運行結果：\n// swap s1: World, s2: Hello\n// main s1: Hello, s2: World\n```\n\n結論：\n\n1. 一個方法不能修改一個基本類型的實參。\n2. 一個方法可以改變一個對象類型的實參狀態。\n3. 一個方法不能讓對象類型的實參引用一個新對象。\n\n### 深拷貝和淺拷貝有什麼不同？\n\n1. 淺拷貝：對基本類型拷貝其值；對引用類型拷貝其引用。\n2. 深拷貝：對基本類型拷貝其值；對引用類型，新建一個對象並拷貝原對象的值。\n\n![](java-basic/Untitled.png)\n\n### 重載和重寫有什麼區別？\n\n1. 重載（overloading）：在一個類中，有多個同名但不同傳入參數的方法，各個重載方法簽名不同。\n2. 重寫（overwrite）：子類對父類允許訪問的方法的重新編寫，方法簽名不變，訪問修飾符只能降低不能提高，拋出的異常只能更小，返回值類型也是。\n\n## Java 面向對象\n\n### 面向對象和面向過程\n\n1. 面向過程：不需要實例化對象，內存和 CPU 開銷小，但不容易維護。\n2. 面向對象：需要實例化對象，內存和 CPU 開銷大，但易維護、易復用、易擴展。\n\nJava 因爲編譯出的字節碼並不能直接在機器上運行，因而效率上會稍慢。但一些面向過程的腳本語言性能也不一定比 Java 好。\n\n### 構造方法\n\n1. 特點：名字跟類名相同，沒有返回值，不可重寫但可重載。\n2. 作用：執行對象的初始化工作，如果類沒有重載任何構造方法，那默認會有不帶參數的構造方法。\n3. 子類初始化時一定會調用父類的構造方法，即使子類不顯式調用，也會默認調用父類的無參構造方法。\n\n### 成員變量和局部變量的區別\n\n1. 成員變量：屬於類；可以被 public、private、static 等修飾符修飾；如用 static 修飾則變量屬於類，否則屬於對象存在於堆內存；生命週期隨對象；自動賦予初始化值。\n2. 局部變量：屬於代碼塊或方法；只能被 final 修飾；存在於棧內存；生命週期隨代碼塊或方法；不會自動賦予初始化值。\n\n### 對象實例和對象引用的區別\n\n1. 對象實例：存在於堆內存，一個對象實例可以被多個引用指向。\n2. 對象引用：存在於棧內存，一個引用指向一個對象實例。\n\n### 面向對象的三大特徵\n\n**（1）封裝**\n\n封裝是將一個對象的狀態信息（即屬性）隱藏在對象內部，一般不允許外界直接訪問，而是提供必要的方法給外界操作。\n\n**（2）繼承**\n\n繼承是使用已有的類創建新類的技術，它提高了代碼復用率和開發效率。關於繼承以下幾點務必明瞭：\n\n1. 子類擁有父類所有的屬性和方法（包括私有的），但父類中的私有屬性和方法子類無法訪問（反射子類也無法訪問），**僅僅擁有**。\n2. 子類可以對父類進行擴展，增加新的屬性和方法。\n3. 子類可以重寫父類的方法。\n\n**（3）多態**\n\n多態，即一個對象可以擁有多種狀態。具體表現在父類的引用可以指向子類的實例。關於多態以下幾點務必知曉：\n\n1. 對象類型和引用類型之間具有繼承/實現關係。\n2. 對象類型不可變，引用類型可變。\n3. 方法具有多態性，屬性不具有。父類的引用可以調用子類對象的方法，但不能訪問其屬性。\n4. 父類的引用不能調用「只有子類存在但在父類不存在」的方法。\n5. 如果子類重寫了父類的方法，真正執行的是子類覆蓋的方法。\n\n### **靜態方法內爲什麼不能調用非靜態成員？**\n\n因爲非靜態成員需要在類實例化成對象後才能被調用，而靜態方法不需要實例化對象就可以被調用。\n\n### 接口和抽象類的區別\n\n1. 方法上：接口的方法默認修飾符是 public，且不能實現（Java 8 開始可以有默認方法和靜態方法，Java 9 開始可以有私有方法和私有靜態方法）；而抽象類可有 public、protected 和 default 修飾符，且可有非抽象的方法。\n2. 變量上：接口只能有 static、final 變量；而抽象類沒有限制。\n3. 繼承上：一個類可以實現多個接口，接口本身也可以擴展多個接口；但一個類只能繼承一個抽象類。\n4. 設計上：接口是對行爲的抽象，是一個行爲規範；抽象類是對類的抽象，是一種模板設計。\n\n## Java 核心技術\n\n### 集合\n\n見 [Java 集合](https://linlshare.github.io/2020/12/02/it/java/java-collection/) \n\n### 反射機制\n\n**（1）什麼是反射**\n\nJava 的反射機制是在運行時能知道任意一個類的所有屬性和方法，能調用任意一個對象的屬性和方法。\n\n**（2）反射的優缺點**\n\n1. 優點：運行時確定類型，動態加載類，提高代碼靈活度。\n2. 缺點：反射性能比直接的 Java 代碼慢，存在安全問題，因爲可以動態操作改變類的屬性。\n\n反射動態加載類的優點即是動態編譯，與之相對的是靜態編譯，靜態編譯是在編譯時就確定了類型。\n\n**（3）反射的應用場景**\n\n反射是框架設計的靈魂。其應用場景有：\n\n1. 模塊化開發；\n2. 動態代理設計模式；\n3. Spring 框架的 IOC（控制反轉）和 AOP（面向切面編程）；\n4. JDBC 連接數據庫等等。\n\n### 異常\n\n**（1）簡介**\n\nJava 的異常歸於同一個 Throwable 類，並分爲兩大類：Error 和 Exception。**Error 通常是 JVM 錯誤，程序無法處理**；**而 Exception 是程序本身可以處理的異常**。Exception 分爲 Checked Exceptions（受檢異常）和 Unchecked Exceptions（不受檢異常）。\n\n![](java-basic/Untitled%201.png)\n\n**Checked Exceptions 又名 Compile Time Exceptions（編譯時異常）**，編譯器可以發現並要求程序處理後才能正常通過編譯，常見的有：\n\n- *IOException*\n- *EOFException*\n- *MalFormedURLException*\n- *IntruptedException*\n\n**Unchecked Exception 又名 Runtime Exceptions（運行時異常）**，編譯器無法檢測出，只有運行時才會發生的異常，常見的有：\n\n- *ArithmaticException*\n- *NullPointerException*\n- *IndexOutOfBoundsException*\n- *ClassCastException*\n- *ArrayIndexOutOfBoundsException*\n- *NumberFormatException*\n\n**（2）Throwable 類常用方法**\n\n1. `getMessage`：返回異常的簡要描述\n2. `toString`：返回異常的詳細信息\n3. `getLocalizedMessage`：返回異常的本地化信息（需要子類覆蓋該方法，否則與 `getMessage` 一樣）\n4. `printStackTrace`：在控制台打印 Throwable 对象封装的异常信息\n\n**（3）try-catch-finally**\n\n1. try 代碼塊：捕獲異常。其後可接零個或多個 catch 代碼塊，如零個則必須接一個 finally 代碼塊。\n2. catch 代碼塊：處理捕獲到的異常。\n3. finally 代碼塊：無論是否捕獲或處理異常，finally 代碼塊最終都會被執行。當在 try 代碼塊或 catch 代碼塊中遇到 return 語句時，finally 代碼塊將在方法返回之前被執行。此時如果 finally 中也有 return 語句的話，其返回值將覆蓋 try 或 catch 代碼塊中的返回值。\n\n```java\npublic static int f(int value) {\n  try {\n      return value * value;\n  } finally {\n      if (value == 2) {\n          return 0;\n      }\n  }\n}\n// f(2) 將返回 0 ，而不是 4.\n```\n\n以下情況，finally 代碼塊不會被執行或只部分執行：\n\n1. finally 代碼塊中有異常，代碼會中異常處中止；\n2. 在 catch 代碼塊或 finally 塊中調用了 `System.exit` 函數退出程序；\n3. 程序所在的線程死亡等等不可預料的系統和硬件問題。\n\n**（4）try-witch-resources**\n\nJava 7 中新增了 ****try-witch-resources 語法糖，適用於實現`java.lang.AutoCloseable` 或者 `java.io.Closeable` 的對象，可以自動關閉申請的資源，然後再執行 catch 或 finally 代碼塊。\n\n```java\n// try-catch-finally\nScanner scanner = null;\ntry {\n    scanner = new Scanner(new File(\"src/main/resources/test.txt\"));\n    while (scanner.hasNext()) {\n        System.out.println(scanner.nextLine());\n    }\n} catch (IOException e) {\n    e.printStackTrace();\n} finally {\n    if (scanner != null) {\n        scanner.close();\n    }\n}\n// try-witch-resources\ntry (Scanner scanner = new Scanner(new File(\"src/main/resources/test.txt\"))) {\n    while (scanner.hasNext()) {\n        System.out.println(scanner.nextLine());\n    }\n} catch (IOException e) {\n    e.printStackTrace();\n}\n```\n\n### 多線程\n\n見 [Java 並發](https://linlshare.github.io/2020/12/02/it/java/java-concurrent/) \n\n### 文件與 I/O 流\n\n**（1）Java 中 I/O 流分爲幾種？**\n\n按不同的分類方法有不同的分類：\n\n1. 按流向分：輸入流、輸出流。\n2. 按操作單元分：字節流、字符流。\n3. 按角色分：節點流、處理流。\n\nJava 中 40 多個 I/O 流相關的類都是從 4 個抽象基類派生：\n\n1. InputStream：字節輸入流\n2. Reader：字符輸入流\n3. OutputStream：字節輸出流\n4. Writer：字符輸出流\n\n![](java-basic/Untitled%202.png)\n\n![](java-basic/Untitled%203.png)\n\n**（2）爲什麼有了字節流還需要字符流？**\n\n不管是文件讀寫還是網絡發送接收，信息的最小存儲單元都是字節，那為什麼 I/O 流操作要分為字節流操作和字符流操作呢？\n\n字符流是由 JVM 將字節流轉換得到的，過程非常耗時，且容易出現亂碼問題。所以 I/O 流提供直接操作字符流的接口，以避免這種轉換。對於文本建議使用字符流，而圖片、音視頻等應使用字節流。\n\n**（3）BIO、NIO、AIO 有什麼區別？**\n\n1. **BIO**（Blocking I/O），同步阻塞 I/O 模式，數據的讀取寫入必須阻塞在一個線程內等待其完成。適用於活動連接數不高（< 單機 1000）的情況，結合線程池一起使用。\n2. **NIO**（Non-blocking I/O 或 New I/O），同步非阻塞的 I/O 模型，Java 1.4 中引入，位於 `java.nio` 包，提供 Channel、Selector 和 Buffer 等抽象，支持基於通道面向緩衝的 I/O 操作方法。適用於高負載、高並發的（網絡）應用。\n3. **AIO**（Asynchronous I/O），異步非阻塞的 I/O 模型，Java 7 中引入。支持基於事件回調機制的操作方法。\n\nNIO 模型：\n\n![](java-basic/Untitled%204.png)\n\n- NIO 服務端代碼\n\n    ```java\n    public class MultiplexerNioServer implements Runnable {\n\n        private Selector selector;\n        private volatile boolean stop = false;\n\n        /**\n         * 初始化多路复用器 绑定监听端口\n         *\n         * @param port\n         */\n        public MultiplexerNioServer(int port) {\n            try {\n                ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();//获得一个serverChannel\n                selector = Selector.open();////创建选择器  获得一个多路复用器\n                serverSocketChannel.configureBlocking(false);//设置为非阻塞模式 如果为 true，则此通道将被置于阻塞模式；如果为 false，则此通道将被置于非阻塞模式\n                serverSocketChannel.socket().bind(new InetSocketAddress(port), 1024);//绑定一个端口和等待队列长度\n                serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);//把selector注册到channel，关注链接事件\n            } catch (IOException e) {\n                e.printStackTrace();\n                System.exit(1);\n            }\n        }\n\n        public void stop() {\n            this.stop = true; // 优雅停机\n        }\n\n        public void run() {\n            while (!stop) {\n                try {\n                    //无论是否有读写事件发生，selector每隔1s被唤醒一次。如果一定时间内没有事件，就需要做些其他的事情，就可以使用带超时的\n                    int client = selector.select(1000);\n                    System.out.println(\"1:\" + client);\n                    // 阻塞,只有当至少一个注册的事件发生的时候才会继续.\n                    // int client = selector.select(); 不设置超时时间为线程阻塞，但是IO上支持多个文件描述符就绪\n                    if (client == 0) {\n                        continue;\n                    }\n                    System.out.println(\"2:\" + client);\n                    Set<SelectionKey> selectionKeys = selector.selectedKeys();\n                    Iterator<SelectionKey> it = selectionKeys.iterator();\n                    SelectionKey key = null;\n                    while (it.hasNext()) {\n                        key = it.next();\n                        it.remove();\n                        try {\n                            //处理事件\n                            handle(key);\n                        } catch (Exception e) {\n                            if (key != null) {\n                                key.cancel();\n                                if (key.channel() != null) {\n                                    key.channel().close();\n                                }\n                            }\n                        }\n                    }\n                } catch (Throwable e) {\n                    e.printStackTrace();\n                }\n            }\n\n            if (selector != null) {\n                // selector关闭后会自动释放里面管理的资源\n                try {\n                    selector.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n\n        public void handle(SelectionKey key) throws IOException {\n            if (key.isValid()) {\n                //连接事件\n                if (key.isAcceptable()) {\n                    ServerSocketChannel ssc = (ServerSocketChannel) key.channel();\n                    // 通过ServerSocketChannel的accept创建SocketChannel实例\n                    // 完成该操作意味着完成TCP三次握手，TCP物理链路正式建立\n                    SocketChannel sc = ssc.accept();//3次握手\n                    sc.configureBlocking(false);\n                    sc.register(selector, SelectionKey.OP_READ);//连接建立后关注读事件\n                }\n\n                //读事件\n                if (key.isReadable()) {\n                    SocketChannel socketChannel = (SocketChannel) key.channel();\n                    ByteBuffer readbuffer = ByteBuffer.allocate(1024);//写 0 1024  1024\n    //                ByteBuffer readbuffer = ByteBuffer.allocateDirect(1024); //申请直接内存，也就是堆外内存\n                    // 读取请求码流，返回读取到的字节数\n                    while (true) {\n                        int readBytes = socketChannel.read(readbuffer);\n                        // 读取到字节，对字节进行编解码\n                        if (readBytes > 0) {\n                            // 将缓冲区当前的limit设置为position=0，用于后续对缓冲区的读取操作\n                            readbuffer.flip();//读写模式反转\n                            // 将缓冲区可读字节数组复制到新建的数组中\n                            byte[] bytes = new byte[readbuffer.remaining()];\n                            readbuffer.get(bytes);\n                            String body = new String(bytes, StandardCharsets.UTF_8);\n                            System.out.println(\"input is:\" + body);\n                            res(socketChannel, body);\n                        } else if (readBytes < 0) {\n                            // 链路已经关闭 释放资源\n                            key.cancel();\n                            socketChannel.close();\n                        } else {\n                            // 没有读到字节忽略\n                            return;\n                        }\n                    }\n\n                }\n\n            }\n        }\n\n        private void res(SocketChannel channel, String response) throws IOException {\n            if (response != null && response.length() > 0) {\n                byte[] bytes = response.getBytes();\n                ByteBuffer writeBuffer = ByteBuffer.allocate(bytes.length);\n                writeBuffer.put(bytes);\n                writeBuffer.flip();\n                channel.write(writeBuffer);\n                System.out.println(\"res end\");\n            }\n        }\n    }\n    ```\n\n- NIO 客戶端代碼\n\n    ```java\n    public class NioClientHandler implements Runnable {\n        private final String host;\n        private final int port;\n        private Selector selector;\n        private SocketChannel socketChannel;\n        private volatile boolean stop;\n\n        public NioClientHandler(String host, int port) {\n            this.host = host;\n            this.port = port;\n            try {\n                // 创建选择器\n                selector = Selector.open();\n                // 打开监听通道\n                socketChannel = SocketChannel.open();\n                // 如果为 true，则此通道将被置于阻塞模式；如果为 false，则此通道将被置于非阻塞模式\n                socketChannel.configureBlocking(false); // 开启非阻塞模式\n            } catch (IOException e) {\n                e.printStackTrace();\n                System.exit(1);\n            }\n        }\n\n        public void run() {\n            try {\n                doConnect();\n            } catch (IOException e) {\n                e.printStackTrace();\n                System.exit(1);\n            }\n            while (!stop) {\n                try {\n                    int wait = selector.select(1000);\n                    if (wait == 0) {\n                        continue;\n                    }\n                    Set<SelectionKey> selectionKeys = selector.selectedKeys();\n                    Iterator<SelectionKey> it = selectionKeys.iterator();\n                    SelectionKey key = null;\n\n                    while (it.hasNext()) {\n                        key = it.next();\n                        it.remove();\n                        try {\n                            handle(key);\n                        } catch (Exception e) {\n                            if (key != null) {\n                                key.cancel();\n                                if (key.channel() != null) {\n                                    key.channel().close();\n                                }\n                            }\n                        }\n                    }\n                } catch (Exception e) {\n                    e.printStackTrace();\n                    System.exit(1);\n                }\n            }\n            if (selector != null) {\n                try {\n                    selector.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n\n        private void doConnect() throws IOException {\n            if (socketChannel.connect(new InetSocketAddress(host, port))) {\n                socketChannel.register(selector, SelectionKey.OP_READ);\n                doWrite(socketChannel);\n            } else {\n                socketChannel.register(selector, SelectionKey.OP_CONNECT);\n            }\n        }\n\n        private void handle(SelectionKey key) throws IOException {\n            if (key.isValid()) {\n                SocketChannel sc = (SocketChannel) key.channel();\n                if (key.isConnectable()) {\n                    if (sc.finishConnect()) {\n                        sc.register(selector, SelectionKey.OP_READ);\n                        doWrite(sc);\n                    } else {\n                        System.exit(1);\n                    }\n                }\n                if (key.isReadable()) {\n                    ByteBuffer readBuffer = ByteBuffer.allocate(1024);\n                    int readBytes = sc.read(readBuffer);\n                    if (readBytes > 0) {\n                        readBuffer.flip();\n                        byte[] bytes = new byte[readBuffer.remaining()];\n                        readBuffer.get(bytes);\n                        String body = new String(bytes, StandardCharsets.UTF_8);\n                        System.out.println(\"res\" + body);\n                        this.stop = true;\n                    } else if (readBytes < 0) {\n                        key.cancel();\n                        sc.close();\n                    }\n\n                }\n            }\n        }\n\n        private void doWrite(SocketChannel sc) throws IOException {\n            // 将消息编码为字节数组\n            byte[] request = \"Hello\".getBytes();\n            // 根据数组容量创建ByteBuffer\n            ByteBuffer writeBuffer = ByteBuffer.allocate(request.length);\n            // 将字节数组复制到缓冲区\n            writeBuffer.put(request);\n            // flip读写切换操作\n            writeBuffer.flip();\n            sc.write(writeBuffer);\n            if (!writeBuffer.hasRemaining()) {\n                System.out.println(\"写入完成\");\n            }\n        }\n    }\n    ```\n\n## Java 項目管理和構建\n\n### Maven 项目\n\n**（1）安装**\n\n從 [Maven 官網](https://maven.apache.org/download.cgi)下載 maven 包，解壓並設置環境變量。還可以直接使用 IDEA 的 Maven 插件。\n\n**（2）初始化一個 Maven 項目**\n\n使用以下命令：\n\n```bash\nmvn -B archetype:generate -DgroupId=com.mycompany.app -DartifactId=my-app -DarchetypeArtifactId=maven-archetype-quickstart -DarchetypeVersion=1.4\n```\n\n或者用 IDEA 直接新建一個 Maven 項目，其結構如下：\n\n![](java-basic/20201114_101407.png)\n\n其中 pom.xml 的內容如下：\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>org.example</groupId>\n    <artifactId>testmaven</artifactId>\n    <version>1.0-SNAPSHOT</version>\n\n    <!--  添加以下屬性，解決編譯報錯  -->\n    <properties>\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n        <maven.compiler.encoding>UTF-8</maven.compiler.encoding>\n        <java.version>15</java.version>\n        <maven.compiler.source>15</maven.compiler.source>\n        <maven.compiler.target>15</maven.compiler.target>\n    </properties>\n    <!-- 新增依賴在下方 -->\n    <dependencies>\n        <dependency>\n            <groupId>org.openjdk.jol</groupId>\n            <artifactId>jol-core</artifactId>\n            <version>0.14</version>\n        </dependency>\n    </dependencies>\n</project>\n```\n\n- 為什麼叫 Maven？\n\n    Maven 來源於意第緒語，爲「行家」的意思。最初是為了簡化 Jakarta Turbine 項目中的構建過程而建立。Maven 使用項目對象模型（POM）和一組插件來構件項目。\n\n- POM 又是指什麼？\n\n    POM（project object model）項目對象模型，maven 使用 `pom.xml` 定義了整個項目的構建、報告和文檔。\n\n**（3）編譯測試打包**\n\n```bash\n# 清理 target 中的文件\nmvn clean\n# 編譯 java 文件成 class 文件，置於 target/classes 文件夾中\nmvn compile\n# 進行單元測試\nmvn test\n# 打包成 jar 文件，置於 target 文件夾中\nmvn package\n# 安裝 jar 包到本地存儲庫（${user.home}/.m2/repository）\nmvn install\n# 生成自己的 maven 站點\nmvn site\n```\n\n- SNAPSHOT 是什麼？\n\n    snapshot 簡要的意思，在版本號之後添加 `-SNAPSHOT` 是說明該版本仍處於開發階段，不是最終的發行版本。以 `x.y-SNAPSHOT` 版本為例，發行時會去除 `-SNAPSHOT`  後綴，然後將最新的開發版本升爲`x.(y+1)-SNAPSHOT` 。\n\n- 使用 mvn compile 生成的 jar 包，其內容是怎樣的？\n\n    除了 class 文件外，還有 `META-INF` 文件夾，裏面存放一些清單文件和pom 文件。存放到項目資源文件夾（`main/resources` ）的文件也會被打包到`META-INF` 文件夾中，代碼中可通過`getClass().getResourceAsStream( \"/application.properties\" )` 調用。\n\n    ```bash\n    $ jar tf target/testmaven-1.0-SNAPSHOT.jar \n    META-INF/\n    META-INF/MANIFEST.MF\n    B.class\n    MemoryLayoutTest.class\n    A.class\n    C.class\n    META-INF/maven/\n    META-INF/maven/org.example/\n    META-INF/maven/org.example/testmaven/\n    META-INF/maven/org.example/testmaven/pom.xml\n    META-INF/maven/org.example/testmaven/pom.properties\n    ```\n\n### Gradle 项目\n\n**（1）安裝**\n\n可從 [gradle 官網](https://www.gradle.org/downloads)下載解壓並配置環境變量的方式安裝。Mac 用戶還可以使用 `brew install gradle` 的方式安裝。或者直接使用 IDEA 項目中的 `gradle-wrapper` ，此時對應的 `gradle` 命令變爲 `gradlew`。\n\n**（2）gradle 命令能做什麼？**\n\ngradle 命令能構建項目， 查看項目依賴、子項目和項目配置等等。\n\n```bash\n$ gradle tasks\n\n:tasks\n\n== All tasks runnable from root project\n\n== Build Setup tasks\nsetupBuild - Initializes a new Gradle build. [incubating]\n\n== Help tasks\ndependencies - Displays all dependencies declared in root project 'gs-gradle'.\ndependencyInsight - Displays the insight into a specific dependency in root project 'gs-gradle'.\nhelp - Displays a help message\nprojects - Displays the sub-projects of root project 'gs-gradle'.\nproperties - Displays the properties of root project 'gs-gradle'.\ntasks - Displays the tasks runnable from root project 'gs-gradle'.\n\nTo see all tasks and more detail, run with --all.\n\nBUILD SUCCESSFUL\n\nTotal time: 3.077 secs\n```\n\n**（3）初始化一個 Gradle 項目**\n\n在項目文件夾中新建一個名爲 `build.gradle` 的文件，其內容如下：\n\n```groovy\napply plugin: 'java'\n```\n\n隨後新建一個名爲 `settings.gradle` 的文件，其內容可暫時爲空。\n\n在 IDEA 中打開此項目，隨後 IDEA 會自動配置加入 `gradle-wrapper` ，其過程等價於執行以下命令：\n\n```bash\ngradle wrapper --gradle-version 6.5\n```\n\n**（4）編譯打包**\n\n```bash\n# 編譯項目，會默認在 build/classes 中生成類文件，在 build/libs 中生成 jar 包\ngradle build\n# 或使用 gradle wrapper\n./gradlew build\n\n# 清理生成的文件\ngradle clean\n\n# 生成 jar 文件\ngradle jar\n\n# 運行生成的 jar 文件\ngradle run\n\n# 進行單元測試\ngradle test\n```\n\n**（5）`build.gradle` 中可配置什麼？**\n\n```groovy\n// 配置插件，插件提供語法定義\napply plugin: 'java'\napply plugin: 'application'\n\n// 配置入口類\nmainClassName = 'hello.HelloWorld'\n\n// 配置依賴倉庫\nrepositories {\n    mavenCentral()\n}\n\n// 配置生成的 jar 文件的入口類\njar {\n    manifest {\n        attributes 'Main-Class': mainClassName\n    }\n}\n\n// 配置 JDK 兼容性\nsourceCompatibility = 1.8\ntargetCompatibility = 1.8\n\n// 配置依賴\ndependencies {\n    compile \"joda-time:joda-time:2.2\"\n    testCompile \"junit:junit:4.12\"\n}\n```\n\n如需將所有依賴 jar 打進同一個 jar 包，可使用 [shadow 插件](https://github.com/johnrengelman/shadow)或使用 [spring boot 插件](https://spring.io/quickstart)。","source":"_posts/it/java/java-basic.md","raw":"---\ntitle: Java 基礎\np: it/java/java-basic.md\ntags:\n- Java\n---\n\nJava 自 95 年誕生至今，已有 25 年的歷史。它是一種半編譯的語言，先將代碼編譯成字節碼，然後在 JVM 中解釋執行。\n\n- 它是一種面向對象的語言，封裝、繼承和多態它都有，類可以多實現但不支持多繼承，而接口可以多繼承。\n- 它支持 8 種基本數據類型，同時還提供了其包裝類型，另外還提供了 BigDecimal 精確處理浮點數、提供了 BigInteger 處理大整數。\n- 它的方法只有值傳遞，傳遞對象時它是淺拷貝而非深拷貝。類的方法可以被子類重寫，同個類可以有多個同名的重載方法。\n- 它支持泛型，一種將類型參數化的技術。不過，也有人稱之爲「僞泛型」，因爲類型會在編譯時被擦除。\n- 它支持反射，一種在運行時操作任意對象的方法和屬性的技術，這在框架應用中很常見。\n- 它提供了豐富的集合類、迭代器及工具類。\n- 它支持多線程，一種在程序進程中同時執行多個任務的技術，同時還有豐富的鎖類型，所有對象的頭信息裏都有一個鎖標識。\n- 它支持異常處理，Exception 分編譯時異常和運行時異常，編譯時異常可以被編譯器檢查到，而運行時異常只能在程序運行時發生。\n- 它有豐富的 I/O API，派生自 4 個抽象類，InputStream、OutputStream、Reader、Writer，字符流的出現是爲了減少 JVM 進行字符編碼解碼的資源損耗和編解碼錯誤。\n- 另外，目前有兩大項目管理工具，Maven 和 Gradle。\n\n<!-- more -->\n\n## Java 入門（基礎概念與常識）\n\n### 歷史\n\nJava 編程語言本名爲 oak（橡樹），因爲商標被註冊了，所以更名爲 Java，而 Java 是印尼的一座島嶼，盛產咖啡豆，有一種咖啡就是以該島命名，Java 編程語言之名因之。使用十六進制編輯器打開 class 文件時會發現前 32 位顯示爲 `CA FE BA BE` ，即 cafe babe （咖啡寶貝）。\n\n```java\n$ hexdump Test.class\n0000000 ca fe ba be 00 00 00 3b 00 51 0a 00 02 00 03 07\n```\n\n- 1994 年完成 1.0 版本。\n- 1995 年首次對外發佈，Java 語言誕生。\n- 1996 年JDK 1.0 誕生。\n- 2004 年 SUN 公司發佈 Java SE 5。\n- 2005 年 SUN 公司發佈 Java SE 6。\n- 2006 年 SUN 公司推出 OpenJDK 計劃。\n- 2014年 Oracle 公司發佈 Java SE 8。\n- 2017年 Oracle公司發佈 Java SE 9。\n- 2020 年 Oracle 公司發佈 Java SE 15。\n\n### 安裝與卸載JDK\n\n在 Mac 環境下，從 [Oracle JavaSE 下載地址](https://www.oracle.com/tw/java/technologies/javase-downloads.html) 下載並安裝。安裝完成後執行 `java -version`  可查看安裝的版本，以確認安裝成功。安裝後的Java Home 位置爲 `/Library/Java/JavaVirtualMachines/jdk-9.0.1.jdk/Contents/Home` 。如需卸載該 jdk，可安裝以下 shell 命令，先移除插件後根據查詢到的 jdk 版本移除整個 jdk 文件夾即可。\n\n```bash\nsudo rm -fr /Library/Internet\\ Plug-Ins/JavaAppletPlugin.plugin\nsudo rm -fr /Library/PreferencesPanes/JavaControlPanel.prefpane\n\nls /Library/Java/JavaVirtualMachines/\n输出：jdk-9.0.1.jdk\n\nsudo rm -rf /Library/Java/JavaVirtualMachines/jdk-9.0.1.jdk\n```\n\n### Hello World\n\n運行以下代碼，將輸出 `Hello World`。\n\n```java\npackage hello;\n\npublic class Hello {\n    public static void main(String[] args) {\n        System.out.println(\"Hello World\");\n    }\n}\n```\n\n### Java 語言的特點\n\n1. 面向對象（封裝，繼承，多態）\n2. 平台無關性（ Java 虛擬機實現平台無關性）\n3. 支持多線程\n4. 編譯與解釋並存\n\n編譯：生成字節碼(.class文件)，javac 指令。\n解釋：解釋字節碼成機器碼，java 指令。\n\n### JVM、JDK 和  JRE\n\n1. JVM，Java Virtual Machine 的縮寫，即 Java 虛擬機，是運行 Java 字節碼的虛擬機（包含解釋器 java），它包含在 JRE 中。不同的操作系統有特定的 JVM 實現，以便 Java 字節碼可以跨平台。\n2. JDK，Java Development Kit 的縮寫，即 Java 開發工具集，包含了 JRE 、編譯器（javac）和其他工具（javadoc 和 jdb 等）。\n3. JRE，Java Runtime 的縮寫，即 Java 運行時，包含了 JVM、必要的類庫、java 命令和其他基礎構件。\n\n### Java 與 C++ 對比\n\n1. 皆支持面向對象編程（封裝、繼承和多態）。\n2. Java 不提供指針來直接訪問內存；C++ 提供。\n3. Java 的類不支持多繼承，但接口可以；C++ 的類可以多繼承。\n4. Java 有內存垃圾自動回收機制（GC），不需要手動釋放無用內存；C++ 沒有。\n5. Java 字符串和字符數組沒有結束符的概念；C/C++ 中字符串和字符數組最後會有一個額外的字符`\\0` 來表示結束。\n\n## Java 語法\n\n### 基本類型及其大小\n\nJava 共 8 種數據類型（不包括 void），具體如下表：\n\n![](java_basic/20201202_24328.png)\n\nboolean 值的大小取決於 JVM 實現，Java 虛擬機規範（第8版）規定：單個 boolean佔 4 個字節，而 boolean 數組 1 個字節。\n\nchar 值是一個 16 位的 Unicode 字符，最小值是 '\\u0000' ，最大值是 '\\uffff'，即 0～65535，每個數字對應一個字符。\n\n- 代碼\n\n    ```java\n    char a = '中';\n    System.out.println((int)a);\n    // 輸出 20013\n    System.out.println(Integer.toHexString(a));\n    // 輸出 4e2d\n    System.out.println('\\u4e2d');\n    // 輸出 中\n    ```\n\nbyte、short、int、long 類型，採用二進制補碼存儲數據，以便利減法運算。\n\n- 二進制補碼\n    - 過程：正數的補碼是其自身；負數的補碼是除符號位外所有二進制位做反碼後加 1 的結果。\n    - 原理：假定 X、Y 是两个占1个字节的数。X-Y 等价于 X+(-Y) ，而 -Y 可以看作 0-Y，假定是 0 不足以被减，向上借 1 变为 1 0000 0000，而  1 0000 0000 又等價於 1111 1111 + 1，於是 -Y = 1111 1111 - Y + 1，即 Y 的反碼再 + 1。 見 [https://www.ruanyifeng.com/blog/2009/08/twos_complement.htm](https://www.ruanyifeng.com/blog/2009/08/twos_complement.html)l\n\nlong 類型的數據後面一定要加上 L，否則會被認為是整型。\n\nchar 類型值使用單引號括起來，String 使用雙引號。\n\nJava 有**自動拆裝箱機制**，裝箱即把基本類型使用其包裝類型包裝起來，拆箱即把包裝類型拆成基本類型。\n\n### 包裝類型及常量池技術\n\n1. Byte、Short、Integer 和 Long 分別默認創建了數值 [-128, 127] 的相應類型的緩存數據。\n2. Character 創建了數值在 [0, 127] 的緩存數據。\n3. Boolean 直接返回 True 和 False。\n4. Float 和 Double 沒有實現常量池技術。\n\n使用常量池技術意味著在緩存範圍內的包裝類型對象是相等的，除非 new 一個對象。使用包裝器的 valueOf 方法默認會先去緩存中取對象，取不到才會 new 一個。\n\n```java\nInteger i1 = 33;\nInteger i2 = 33;\nSystem.out.println(i1 == i2);// 输出 true\nInteger i11 = 333;\nInteger i22 = 333;\nSystem.out.println(i11 == i22);// 输出 false\nDouble i3 = 1.2;\nDouble i4 = 1.2;\nSystem.out.println(i3 == i4);// 输出 false\n```\n\n《阿里巴巴Java開發手冊》規定：\n\n- 【強制】**所有的 POJO 類屬性必須使用包裝數據類型**。\n- 【強制】RPC 方法的返回值和參數必須使用包裝數據類型。\n- 【推薦】所有的局部變量使用基本數據類型。\n\n### BigDecimal\n\n**（1）使用 BigDecimal 進行浮點數比較和精度取捨**\n\n**（2）使用 BigDecimal(String) 或 BigDecimal.valueOf(double) 構造對象**\n\n```java\nfloat a = 1.0f - 0.9f;\nfloat b = 0.9f - 0.8f;\nSystem.out.println(a);\nSystem.out.println(b);\nSystem.out.println(a == b); // false\n\nBigDecimal a = new BigDecimal(\"1.0\");\nBigDecimal b = new BigDecimal(\"0.9\");\nBigDecimal c = new BigDecimal(\"0.8\");\nSystem.out.println(a.subtract(b));\nSystem.out.println(b.subtract(c));\nSystem.out.println(a.subtract(b).equals(b.subtract(c))); // true\n\nBigDecimal a = new BigDecimal(\"1.1252312\");\n// 取小數點後 2 位，四捨五入\nBigDecimal scale = a.setScale(2, RoundingMode.HALF_UP);\nSystem.out.println(scale.toString()); // 1.13\n```\n\n### 對象及其大小\n\n基本類型的封裝類型是對象，Java 中的對象由以下部分組成：\n\n1. 對象頭（object header）：由 mark word 和 class pointer 組成。mark word 存儲了對象的 hashcode、GC信息和鎖信息；class pointer 存儲了指向類對象的指針。32 位的 JVM 上對象頭佔 8 個字節，mark word 和 class pointer 各佔一半。64 位的 JVM 默認開啟了壓縮指針選項（-XX+UseCompressedOops）後上對象頭佔用 12 個字節，mark word 佔用 8 個字節，class pointer 佔用 4 個字節。\n2. 實例數據（instance data）：\n3. 對齊填充（padding）\n\n可使用 `org.openjdk.jol` 工具查看一個對象佔用的字節大小，\n\n- 如下：\n\n    ```java\n    public static void main(String[] args){\n        System.out.println(VM.current().details());\n        System.out.println(ClassLayout.parseClass(Object.class).toPrintable());\n        System.out.println(ClassLayout.parseInstance(Integer.valueOf(1)).toPrintable());\n    }\n    ```\n\n    輸出結果：\n\n    ```bash\n    # Running 64-bit HotSpot VM.\n    # Using compressed oop with 3-bit shift.\n    # Using compressed klass with 3-bit shift.\n    # WARNING | Compressed references base/shifts are guessed by the experiment!\n    # WARNING | Therefore, computed addresses are just guesses, and ARE NOT RELIABLE.\n    # WARNING | Make sure to attach Serviceability Agent to get the reliable addresses.\n    # Objects are 8 bytes aligned.\n    # Field sizes by type: 4, 1, 1, 2, 2, 4, 4, 8, 8 [bytes]\n    # Array element sizes: 4, 1, 1, 2, 2, 4, 4, 8, 8 [bytes]\n\n    java.lang.Object object internals:\n     OFFSET  SIZE   TYPE DESCRIPTION                               VALUE\n          0    12        (object header)                           N/A\n         12     4        (loss due to the next object alignment)\n    Instance size: 16 bytes\n    Space losses: 0 bytes internal + 4 bytes external = 4 bytes total\n\n    java.lang.Integer object internals:\n     OFFSET  SIZE   TYPE DESCRIPTION                               VALUE\n          0     4        (object header)                           01 c9 01 4e (00000001 11001001 00000001 01001110) (1308739841)\n          4     4        (object header)                           3d 00 00 00 (00111101 00000000 00000000 00000000) (61)\n          8     4        (object header)                           48 71 00 00 (01001000 01110001 00000000 00000000) (29000)\n         12     4    int Integer.value                             1\n    Instance size: 16 bytes\n    Space losses: 0 bytes internal + 0 bytes external = 0 bytes total\n    ```\n\n結論：在 64 位開啟指針壓縮的環境下，Object 對象佔用 16 個字節，Integer 對象也佔用 16 個字節。\n\n### String、StringBuffer 和 String Builder 的區別\n\nString 類使用 final 修飾字符數組或字節數組來保存字符串，所以 String 對象是不可變的。\n\n```java\npublic final class String {\n\t// Java 9 之前\n\tprivate final char[] value;\n\t// Java 9 之後\n\tprivate final byte[] value;\n}\n```\n\nStringBuilder  和 StringBuffer 都繼承自 AbstractStringBuilder，AbstractStringBuilder 使用字符數組來保存字符串，但沒有使用 final 關鍵字修飾，所以這兩者是可變的。\n\n下面從不同角度比較下此三者：\n\n1. 線程安全性：String 對象不可變，線程安全；StringBuffer 對方法加了同步鎖，線程安全；StringBuilder 對方法沒有加同步鎖，線程不安全。\n2. 性能：每次對 String 類型進行改變時會生成一個新的 String 對象，然後將指針指向新的 String 對象。StringBuffer 和 StringBuilder 每次對自身進行操作，不生成新對象。同等情況下， StringBuilder 比 StringBuffer 能提升 10%～15% 性能，但要冒線程不安全的風險。\n\n### 注釋\n\n代碼即注釋。先讓標識符見名知意，然後再考慮增加注釋。\n\n### 標識符和關鍵字的區別\n\n標識符是程序、類、變量、方法等取的名字，而關鍵字是具備特殊含義的標識符。常見的關鍵字有：\n\n1. 訪問控制：private、protected、public\n2. 類、方法和變量修飾符：abstract、class、extends、final、implements、interface、native、new、static、strictfp、synchronized、transient、volatile\n3. 程序控制：break、continue、return、do、while、if、else、for、instanceof、switch、case、default\n4. 錯誤處理：try、catch、throw、throws、finally\n5. 包相關：import、package\n6. 基本類型：boolean、byte、char、double、float、int、short、null、true、false\n7. 變量引用：super、this、void\n8. 保留字：goto、const\n\n### 自增自減運算符\n\n符號在前先加減再賦值，符號在後先賦值後加減。假定 `a = 1; b = a++` 最後 a 值爲 2，b 值爲 1。\n\n### == 和 equals 的區別\n\n1. 基本數據類型 == 比較的是值，引用數據類型 == 比較的是內存地址。\n2. equals 是 Object 類的方法，如無重寫該方法，則默認使用 == 比較對象，即比較內存地址；String 類重寫了 equals 方法使其比較得是值。\n3. 整型包裝類都應使用 equals 比較大小。\n4. 浮點數之間的等值判斷，基本數據類型不能用==來比較，包裝數據類型不能用 equals 來判斷。\n- 重寫 equals 方法通常同時需要重寫 hashcode 方法，爲什麼？\n\n    hashcode 是 Object 類的一個本地方法，其實現時將對象的內存地址轉爲一個 int 值，不同的對象的 hashcode 可能相同。 HashSet 集合進行元素重複校驗時先比較 hashcode ，當 hashcode 一樣時再調用 equals，提高了校驗效率。因此，如果只重寫 equals 方法而不重寫 hashcode 方法，會出現 equals 返回 true，而 hashcode 不等的情況，這樣如果要求 HashSet 去重就會失敗。\n\n    HashSet 基於 HashMap 實現，HashMap 內部有一哈希表，裏面使用 hashcode 進行散列存儲。\n\n### 序列化時如果有些字段不想序列化，怎麼辦？\n\n使用 transient 關鍵字修飾不想序列化的字段。\n\n### continue、break 和 return 的區別\n\n1. continue：跳出當前這一次循環，繼續下一次循環。\n2. break：跳出整個循環體，繼續執行循環外的語句。\n3. return：跳出所在的方法，結束方法，可以帶一個返回值。\n\n### 泛型、類型擦除和通配符\n\n**泛型的本質是將類型參數化。**Java 的泛型（generics）是 JDK 5 中引入的新特性，還提供了編譯時類型安全檢測機制來檢測非法的類型。但是 Java 的泛型在編譯期間會將泛型信息擦除，即類型擦除，因此也被稱爲**僞泛型**。下面的例子展示了如何在運行期加入非法類型。\n\n```java\nList<Integer> list = new ArrayList<>();\nlist.add(12);\n//這裡直接添加會報錯\n// list.add(\"a\");\nClass<? extends List> clazz = list.getClass();\nMethod add = clazz.getDeclaredMethod(\"add\", Object.class);\n//但是通過反射添加，是可以的\nadd.invoke(list, \"kl\");\nSystem.out.println(list);\n```\n\n泛型分泛型接口、泛型類和泛型方法。泛型類的具體類型通過實例化時傳入，泛型方法的具體類型通過方法調用時傳入的參數確定。\n\n泛型通配符約定：\n\n1. ？ 表示不確定的 Java 類型，用於泛型方法\n2. T（Type）表示確定的一個 Java 類型\n3. K V（Key Value）分別表示映射中的鍵、值\n4. E（Element）表示集合中的一個元素\n5. <? extends A> 上界通配符，表示 A 類型或其子類\n6. <? super A> 下界通配符，表示 A 類型或其父類\n7. <T extends A> 表示 A 類型或其子類的一種\n8. <T extends A & B> 表示 A 類型且B類型的子類的一種\n9. ~~<T super A>~~ \n\n泛型不是協變的，已知 Apple 繼承自 Fruit 的情況下，Plate<Apple> 的引用並不能傳遞給 Plate<Fruit>，但可以傳遞給 Plate<? extends Fruit>。\n\n元素爲 <? extends E> 的集合，只能取出 E，而不能存入 E 及其子類的對象。因爲只能確定該類型是 E 的子類，但具體是哪個子類未知，因此編譯器不允許插入任何 E 或其子類的對象，取出來的時候只能當 E 類型。\n\n```java\npublic static void main(String[] args) {\n  List<? extends A> list = Arrays.asList(new A(), new B());\n  list.add(new A()); // 報錯\n  list.add(new B()); // 報錯\n  A a = list.get(1);\n  System.out.println(a.toString());\n}\n\nstatic class A {\n}\n\nstatic class B extends A {\n}\n```\n\n元素爲 <? super E> 的集合，只能取出 Object，只能存入 E 及其子類的對象。因爲只能確定該類型是 E 的超類，但不知是哪一個超類，所以插入任何 E 及其子類的對象是沒問題的，但是插入 E 的超類就不行了，取出來的時候也只能是 Object，因爲 Object 是一切類的超類。\n\n```java\npublic static void main(String[] args) {\n  List<? super B> list = new ArrayList<>();\n  list.add(new A()); // 報錯\n  list.add(new B());\n  list.add(new C());\n  Object object = list.get(1);\n  System.out.println(object.toString());\n}\n\nstatic class A {\n}\nstatic class B extends A {\n}\nstatic class C extends B{\n}\n```\n\n### 獲取鍵盤輸入數據的常用方法\n\n```java\n// 方法一：使用 Scanner，可以快速確定輸入數據的類型，按空格符分割數據\nScanner scanner = new Scanner(System.in);\nString s = scanner.nextLine();\nSystem.out.println(s);\n\n// 方法二：使用 BufferedReader 讀取字符序列，高效但需要轉換成其他類型，會拋出 IOException\nBufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));\nString s1 = bufferedReader.readLine();\nSystem.out.println(s1);\n```\n\n## 方法（函數）\n\n### 爲什麼 Java 只有值傳遞？\n\n首先要明瞭程序設計語言中的有關函數參數傳遞的兩種方法：\n\n1. 按值調用（call by value）：方法接收調用者提供的參數的值，方法內無法修改實際參數值。\n2. 按引用調用（call by reference）：方法接收調用者提供的參數的地址，方法內可以修改實際參數值。\n\n**Java 總是採用按值調用，所有參數值都是一個拷貝，無法修改實際參數值。對於引用類型參數，傳遞的是引用的拷貝，引用的拷貝和引用指向同一個對象，即所謂的淺拷貝**。\n\n```java\npublic static void main(String[] args) {\n  String s1 = \"Hello\";\n  String s2 = \"World\";\n  swap(s1, s2);\n  System.out.printf(\"main s1: %s, s2: %s%n\", s1, s2);\n}\n\nstatic void swap(String s1, String s2) {\n  String tmp = s1;\n  s1 = s2;\n  s2 = tmp;\n  System.out.printf(\"swap s1: %s, s2: %s%n\", s1, s2);\n}\n// 運行結果：\n// swap s1: World, s2: Hello\n// main s1: Hello, s2: World\n```\n\n結論：\n\n1. 一個方法不能修改一個基本類型的實參。\n2. 一個方法可以改變一個對象類型的實參狀態。\n3. 一個方法不能讓對象類型的實參引用一個新對象。\n\n### 深拷貝和淺拷貝有什麼不同？\n\n1. 淺拷貝：對基本類型拷貝其值；對引用類型拷貝其引用。\n2. 深拷貝：對基本類型拷貝其值；對引用類型，新建一個對象並拷貝原對象的值。\n\n![](java-basic/Untitled.png)\n\n### 重載和重寫有什麼區別？\n\n1. 重載（overloading）：在一個類中，有多個同名但不同傳入參數的方法，各個重載方法簽名不同。\n2. 重寫（overwrite）：子類對父類允許訪問的方法的重新編寫，方法簽名不變，訪問修飾符只能降低不能提高，拋出的異常只能更小，返回值類型也是。\n\n## Java 面向對象\n\n### 面向對象和面向過程\n\n1. 面向過程：不需要實例化對象，內存和 CPU 開銷小，但不容易維護。\n2. 面向對象：需要實例化對象，內存和 CPU 開銷大，但易維護、易復用、易擴展。\n\nJava 因爲編譯出的字節碼並不能直接在機器上運行，因而效率上會稍慢。但一些面向過程的腳本語言性能也不一定比 Java 好。\n\n### 構造方法\n\n1. 特點：名字跟類名相同，沒有返回值，不可重寫但可重載。\n2. 作用：執行對象的初始化工作，如果類沒有重載任何構造方法，那默認會有不帶參數的構造方法。\n3. 子類初始化時一定會調用父類的構造方法，即使子類不顯式調用，也會默認調用父類的無參構造方法。\n\n### 成員變量和局部變量的區別\n\n1. 成員變量：屬於類；可以被 public、private、static 等修飾符修飾；如用 static 修飾則變量屬於類，否則屬於對象存在於堆內存；生命週期隨對象；自動賦予初始化值。\n2. 局部變量：屬於代碼塊或方法；只能被 final 修飾；存在於棧內存；生命週期隨代碼塊或方法；不會自動賦予初始化值。\n\n### 對象實例和對象引用的區別\n\n1. 對象實例：存在於堆內存，一個對象實例可以被多個引用指向。\n2. 對象引用：存在於棧內存，一個引用指向一個對象實例。\n\n### 面向對象的三大特徵\n\n**（1）封裝**\n\n封裝是將一個對象的狀態信息（即屬性）隱藏在對象內部，一般不允許外界直接訪問，而是提供必要的方法給外界操作。\n\n**（2）繼承**\n\n繼承是使用已有的類創建新類的技術，它提高了代碼復用率和開發效率。關於繼承以下幾點務必明瞭：\n\n1. 子類擁有父類所有的屬性和方法（包括私有的），但父類中的私有屬性和方法子類無法訪問（反射子類也無法訪問），**僅僅擁有**。\n2. 子類可以對父類進行擴展，增加新的屬性和方法。\n3. 子類可以重寫父類的方法。\n\n**（3）多態**\n\n多態，即一個對象可以擁有多種狀態。具體表現在父類的引用可以指向子類的實例。關於多態以下幾點務必知曉：\n\n1. 對象類型和引用類型之間具有繼承/實現關係。\n2. 對象類型不可變，引用類型可變。\n3. 方法具有多態性，屬性不具有。父類的引用可以調用子類對象的方法，但不能訪問其屬性。\n4. 父類的引用不能調用「只有子類存在但在父類不存在」的方法。\n5. 如果子類重寫了父類的方法，真正執行的是子類覆蓋的方法。\n\n### **靜態方法內爲什麼不能調用非靜態成員？**\n\n因爲非靜態成員需要在類實例化成對象後才能被調用，而靜態方法不需要實例化對象就可以被調用。\n\n### 接口和抽象類的區別\n\n1. 方法上：接口的方法默認修飾符是 public，且不能實現（Java 8 開始可以有默認方法和靜態方法，Java 9 開始可以有私有方法和私有靜態方法）；而抽象類可有 public、protected 和 default 修飾符，且可有非抽象的方法。\n2. 變量上：接口只能有 static、final 變量；而抽象類沒有限制。\n3. 繼承上：一個類可以實現多個接口，接口本身也可以擴展多個接口；但一個類只能繼承一個抽象類。\n4. 設計上：接口是對行爲的抽象，是一個行爲規範；抽象類是對類的抽象，是一種模板設計。\n\n## Java 核心技術\n\n### 集合\n\n見 [Java 集合](https://linlshare.github.io/2020/12/02/it/java/java-collection/) \n\n### 反射機制\n\n**（1）什麼是反射**\n\nJava 的反射機制是在運行時能知道任意一個類的所有屬性和方法，能調用任意一個對象的屬性和方法。\n\n**（2）反射的優缺點**\n\n1. 優點：運行時確定類型，動態加載類，提高代碼靈活度。\n2. 缺點：反射性能比直接的 Java 代碼慢，存在安全問題，因爲可以動態操作改變類的屬性。\n\n反射動態加載類的優點即是動態編譯，與之相對的是靜態編譯，靜態編譯是在編譯時就確定了類型。\n\n**（3）反射的應用場景**\n\n反射是框架設計的靈魂。其應用場景有：\n\n1. 模塊化開發；\n2. 動態代理設計模式；\n3. Spring 框架的 IOC（控制反轉）和 AOP（面向切面編程）；\n4. JDBC 連接數據庫等等。\n\n### 異常\n\n**（1）簡介**\n\nJava 的異常歸於同一個 Throwable 類，並分爲兩大類：Error 和 Exception。**Error 通常是 JVM 錯誤，程序無法處理**；**而 Exception 是程序本身可以處理的異常**。Exception 分爲 Checked Exceptions（受檢異常）和 Unchecked Exceptions（不受檢異常）。\n\n![](java-basic/Untitled%201.png)\n\n**Checked Exceptions 又名 Compile Time Exceptions（編譯時異常）**，編譯器可以發現並要求程序處理後才能正常通過編譯，常見的有：\n\n- *IOException*\n- *EOFException*\n- *MalFormedURLException*\n- *IntruptedException*\n\n**Unchecked Exception 又名 Runtime Exceptions（運行時異常）**，編譯器無法檢測出，只有運行時才會發生的異常，常見的有：\n\n- *ArithmaticException*\n- *NullPointerException*\n- *IndexOutOfBoundsException*\n- *ClassCastException*\n- *ArrayIndexOutOfBoundsException*\n- *NumberFormatException*\n\n**（2）Throwable 類常用方法**\n\n1. `getMessage`：返回異常的簡要描述\n2. `toString`：返回異常的詳細信息\n3. `getLocalizedMessage`：返回異常的本地化信息（需要子類覆蓋該方法，否則與 `getMessage` 一樣）\n4. `printStackTrace`：在控制台打印 Throwable 对象封装的异常信息\n\n**（3）try-catch-finally**\n\n1. try 代碼塊：捕獲異常。其後可接零個或多個 catch 代碼塊，如零個則必須接一個 finally 代碼塊。\n2. catch 代碼塊：處理捕獲到的異常。\n3. finally 代碼塊：無論是否捕獲或處理異常，finally 代碼塊最終都會被執行。當在 try 代碼塊或 catch 代碼塊中遇到 return 語句時，finally 代碼塊將在方法返回之前被執行。此時如果 finally 中也有 return 語句的話，其返回值將覆蓋 try 或 catch 代碼塊中的返回值。\n\n```java\npublic static int f(int value) {\n  try {\n      return value * value;\n  } finally {\n      if (value == 2) {\n          return 0;\n      }\n  }\n}\n// f(2) 將返回 0 ，而不是 4.\n```\n\n以下情況，finally 代碼塊不會被執行或只部分執行：\n\n1. finally 代碼塊中有異常，代碼會中異常處中止；\n2. 在 catch 代碼塊或 finally 塊中調用了 `System.exit` 函數退出程序；\n3. 程序所在的線程死亡等等不可預料的系統和硬件問題。\n\n**（4）try-witch-resources**\n\nJava 7 中新增了 ****try-witch-resources 語法糖，適用於實現`java.lang.AutoCloseable` 或者 `java.io.Closeable` 的對象，可以自動關閉申請的資源，然後再執行 catch 或 finally 代碼塊。\n\n```java\n// try-catch-finally\nScanner scanner = null;\ntry {\n    scanner = new Scanner(new File(\"src/main/resources/test.txt\"));\n    while (scanner.hasNext()) {\n        System.out.println(scanner.nextLine());\n    }\n} catch (IOException e) {\n    e.printStackTrace();\n} finally {\n    if (scanner != null) {\n        scanner.close();\n    }\n}\n// try-witch-resources\ntry (Scanner scanner = new Scanner(new File(\"src/main/resources/test.txt\"))) {\n    while (scanner.hasNext()) {\n        System.out.println(scanner.nextLine());\n    }\n} catch (IOException e) {\n    e.printStackTrace();\n}\n```\n\n### 多線程\n\n見 [Java 並發](https://linlshare.github.io/2020/12/02/it/java/java-concurrent/) \n\n### 文件與 I/O 流\n\n**（1）Java 中 I/O 流分爲幾種？**\n\n按不同的分類方法有不同的分類：\n\n1. 按流向分：輸入流、輸出流。\n2. 按操作單元分：字節流、字符流。\n3. 按角色分：節點流、處理流。\n\nJava 中 40 多個 I/O 流相關的類都是從 4 個抽象基類派生：\n\n1. InputStream：字節輸入流\n2. Reader：字符輸入流\n3. OutputStream：字節輸出流\n4. Writer：字符輸出流\n\n![](java-basic/Untitled%202.png)\n\n![](java-basic/Untitled%203.png)\n\n**（2）爲什麼有了字節流還需要字符流？**\n\n不管是文件讀寫還是網絡發送接收，信息的最小存儲單元都是字節，那為什麼 I/O 流操作要分為字節流操作和字符流操作呢？\n\n字符流是由 JVM 將字節流轉換得到的，過程非常耗時，且容易出現亂碼問題。所以 I/O 流提供直接操作字符流的接口，以避免這種轉換。對於文本建議使用字符流，而圖片、音視頻等應使用字節流。\n\n**（3）BIO、NIO、AIO 有什麼區別？**\n\n1. **BIO**（Blocking I/O），同步阻塞 I/O 模式，數據的讀取寫入必須阻塞在一個線程內等待其完成。適用於活動連接數不高（< 單機 1000）的情況，結合線程池一起使用。\n2. **NIO**（Non-blocking I/O 或 New I/O），同步非阻塞的 I/O 模型，Java 1.4 中引入，位於 `java.nio` 包，提供 Channel、Selector 和 Buffer 等抽象，支持基於通道面向緩衝的 I/O 操作方法。適用於高負載、高並發的（網絡）應用。\n3. **AIO**（Asynchronous I/O），異步非阻塞的 I/O 模型，Java 7 中引入。支持基於事件回調機制的操作方法。\n\nNIO 模型：\n\n![](java-basic/Untitled%204.png)\n\n- NIO 服務端代碼\n\n    ```java\n    public class MultiplexerNioServer implements Runnable {\n\n        private Selector selector;\n        private volatile boolean stop = false;\n\n        /**\n         * 初始化多路复用器 绑定监听端口\n         *\n         * @param port\n         */\n        public MultiplexerNioServer(int port) {\n            try {\n                ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();//获得一个serverChannel\n                selector = Selector.open();////创建选择器  获得一个多路复用器\n                serverSocketChannel.configureBlocking(false);//设置为非阻塞模式 如果为 true，则此通道将被置于阻塞模式；如果为 false，则此通道将被置于非阻塞模式\n                serverSocketChannel.socket().bind(new InetSocketAddress(port), 1024);//绑定一个端口和等待队列长度\n                serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);//把selector注册到channel，关注链接事件\n            } catch (IOException e) {\n                e.printStackTrace();\n                System.exit(1);\n            }\n        }\n\n        public void stop() {\n            this.stop = true; // 优雅停机\n        }\n\n        public void run() {\n            while (!stop) {\n                try {\n                    //无论是否有读写事件发生，selector每隔1s被唤醒一次。如果一定时间内没有事件，就需要做些其他的事情，就可以使用带超时的\n                    int client = selector.select(1000);\n                    System.out.println(\"1:\" + client);\n                    // 阻塞,只有当至少一个注册的事件发生的时候才会继续.\n                    // int client = selector.select(); 不设置超时时间为线程阻塞，但是IO上支持多个文件描述符就绪\n                    if (client == 0) {\n                        continue;\n                    }\n                    System.out.println(\"2:\" + client);\n                    Set<SelectionKey> selectionKeys = selector.selectedKeys();\n                    Iterator<SelectionKey> it = selectionKeys.iterator();\n                    SelectionKey key = null;\n                    while (it.hasNext()) {\n                        key = it.next();\n                        it.remove();\n                        try {\n                            //处理事件\n                            handle(key);\n                        } catch (Exception e) {\n                            if (key != null) {\n                                key.cancel();\n                                if (key.channel() != null) {\n                                    key.channel().close();\n                                }\n                            }\n                        }\n                    }\n                } catch (Throwable e) {\n                    e.printStackTrace();\n                }\n            }\n\n            if (selector != null) {\n                // selector关闭后会自动释放里面管理的资源\n                try {\n                    selector.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n\n        public void handle(SelectionKey key) throws IOException {\n            if (key.isValid()) {\n                //连接事件\n                if (key.isAcceptable()) {\n                    ServerSocketChannel ssc = (ServerSocketChannel) key.channel();\n                    // 通过ServerSocketChannel的accept创建SocketChannel实例\n                    // 完成该操作意味着完成TCP三次握手，TCP物理链路正式建立\n                    SocketChannel sc = ssc.accept();//3次握手\n                    sc.configureBlocking(false);\n                    sc.register(selector, SelectionKey.OP_READ);//连接建立后关注读事件\n                }\n\n                //读事件\n                if (key.isReadable()) {\n                    SocketChannel socketChannel = (SocketChannel) key.channel();\n                    ByteBuffer readbuffer = ByteBuffer.allocate(1024);//写 0 1024  1024\n    //                ByteBuffer readbuffer = ByteBuffer.allocateDirect(1024); //申请直接内存，也就是堆外内存\n                    // 读取请求码流，返回读取到的字节数\n                    while (true) {\n                        int readBytes = socketChannel.read(readbuffer);\n                        // 读取到字节，对字节进行编解码\n                        if (readBytes > 0) {\n                            // 将缓冲区当前的limit设置为position=0，用于后续对缓冲区的读取操作\n                            readbuffer.flip();//读写模式反转\n                            // 将缓冲区可读字节数组复制到新建的数组中\n                            byte[] bytes = new byte[readbuffer.remaining()];\n                            readbuffer.get(bytes);\n                            String body = new String(bytes, StandardCharsets.UTF_8);\n                            System.out.println(\"input is:\" + body);\n                            res(socketChannel, body);\n                        } else if (readBytes < 0) {\n                            // 链路已经关闭 释放资源\n                            key.cancel();\n                            socketChannel.close();\n                        } else {\n                            // 没有读到字节忽略\n                            return;\n                        }\n                    }\n\n                }\n\n            }\n        }\n\n        private void res(SocketChannel channel, String response) throws IOException {\n            if (response != null && response.length() > 0) {\n                byte[] bytes = response.getBytes();\n                ByteBuffer writeBuffer = ByteBuffer.allocate(bytes.length);\n                writeBuffer.put(bytes);\n                writeBuffer.flip();\n                channel.write(writeBuffer);\n                System.out.println(\"res end\");\n            }\n        }\n    }\n    ```\n\n- NIO 客戶端代碼\n\n    ```java\n    public class NioClientHandler implements Runnable {\n        private final String host;\n        private final int port;\n        private Selector selector;\n        private SocketChannel socketChannel;\n        private volatile boolean stop;\n\n        public NioClientHandler(String host, int port) {\n            this.host = host;\n            this.port = port;\n            try {\n                // 创建选择器\n                selector = Selector.open();\n                // 打开监听通道\n                socketChannel = SocketChannel.open();\n                // 如果为 true，则此通道将被置于阻塞模式；如果为 false，则此通道将被置于非阻塞模式\n                socketChannel.configureBlocking(false); // 开启非阻塞模式\n            } catch (IOException e) {\n                e.printStackTrace();\n                System.exit(1);\n            }\n        }\n\n        public void run() {\n            try {\n                doConnect();\n            } catch (IOException e) {\n                e.printStackTrace();\n                System.exit(1);\n            }\n            while (!stop) {\n                try {\n                    int wait = selector.select(1000);\n                    if (wait == 0) {\n                        continue;\n                    }\n                    Set<SelectionKey> selectionKeys = selector.selectedKeys();\n                    Iterator<SelectionKey> it = selectionKeys.iterator();\n                    SelectionKey key = null;\n\n                    while (it.hasNext()) {\n                        key = it.next();\n                        it.remove();\n                        try {\n                            handle(key);\n                        } catch (Exception e) {\n                            if (key != null) {\n                                key.cancel();\n                                if (key.channel() != null) {\n                                    key.channel().close();\n                                }\n                            }\n                        }\n                    }\n                } catch (Exception e) {\n                    e.printStackTrace();\n                    System.exit(1);\n                }\n            }\n            if (selector != null) {\n                try {\n                    selector.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n\n        private void doConnect() throws IOException {\n            if (socketChannel.connect(new InetSocketAddress(host, port))) {\n                socketChannel.register(selector, SelectionKey.OP_READ);\n                doWrite(socketChannel);\n            } else {\n                socketChannel.register(selector, SelectionKey.OP_CONNECT);\n            }\n        }\n\n        private void handle(SelectionKey key) throws IOException {\n            if (key.isValid()) {\n                SocketChannel sc = (SocketChannel) key.channel();\n                if (key.isConnectable()) {\n                    if (sc.finishConnect()) {\n                        sc.register(selector, SelectionKey.OP_READ);\n                        doWrite(sc);\n                    } else {\n                        System.exit(1);\n                    }\n                }\n                if (key.isReadable()) {\n                    ByteBuffer readBuffer = ByteBuffer.allocate(1024);\n                    int readBytes = sc.read(readBuffer);\n                    if (readBytes > 0) {\n                        readBuffer.flip();\n                        byte[] bytes = new byte[readBuffer.remaining()];\n                        readBuffer.get(bytes);\n                        String body = new String(bytes, StandardCharsets.UTF_8);\n                        System.out.println(\"res\" + body);\n                        this.stop = true;\n                    } else if (readBytes < 0) {\n                        key.cancel();\n                        sc.close();\n                    }\n\n                }\n            }\n        }\n\n        private void doWrite(SocketChannel sc) throws IOException {\n            // 将消息编码为字节数组\n            byte[] request = \"Hello\".getBytes();\n            // 根据数组容量创建ByteBuffer\n            ByteBuffer writeBuffer = ByteBuffer.allocate(request.length);\n            // 将字节数组复制到缓冲区\n            writeBuffer.put(request);\n            // flip读写切换操作\n            writeBuffer.flip();\n            sc.write(writeBuffer);\n            if (!writeBuffer.hasRemaining()) {\n                System.out.println(\"写入完成\");\n            }\n        }\n    }\n    ```\n\n## Java 項目管理和構建\n\n### Maven 项目\n\n**（1）安装**\n\n從 [Maven 官網](https://maven.apache.org/download.cgi)下載 maven 包，解壓並設置環境變量。還可以直接使用 IDEA 的 Maven 插件。\n\n**（2）初始化一個 Maven 項目**\n\n使用以下命令：\n\n```bash\nmvn -B archetype:generate -DgroupId=com.mycompany.app -DartifactId=my-app -DarchetypeArtifactId=maven-archetype-quickstart -DarchetypeVersion=1.4\n```\n\n或者用 IDEA 直接新建一個 Maven 項目，其結構如下：\n\n![](java-basic/20201114_101407.png)\n\n其中 pom.xml 的內容如下：\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>org.example</groupId>\n    <artifactId>testmaven</artifactId>\n    <version>1.0-SNAPSHOT</version>\n\n    <!--  添加以下屬性，解決編譯報錯  -->\n    <properties>\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n        <maven.compiler.encoding>UTF-8</maven.compiler.encoding>\n        <java.version>15</java.version>\n        <maven.compiler.source>15</maven.compiler.source>\n        <maven.compiler.target>15</maven.compiler.target>\n    </properties>\n    <!-- 新增依賴在下方 -->\n    <dependencies>\n        <dependency>\n            <groupId>org.openjdk.jol</groupId>\n            <artifactId>jol-core</artifactId>\n            <version>0.14</version>\n        </dependency>\n    </dependencies>\n</project>\n```\n\n- 為什麼叫 Maven？\n\n    Maven 來源於意第緒語，爲「行家」的意思。最初是為了簡化 Jakarta Turbine 項目中的構建過程而建立。Maven 使用項目對象模型（POM）和一組插件來構件項目。\n\n- POM 又是指什麼？\n\n    POM（project object model）項目對象模型，maven 使用 `pom.xml` 定義了整個項目的構建、報告和文檔。\n\n**（3）編譯測試打包**\n\n```bash\n# 清理 target 中的文件\nmvn clean\n# 編譯 java 文件成 class 文件，置於 target/classes 文件夾中\nmvn compile\n# 進行單元測試\nmvn test\n# 打包成 jar 文件，置於 target 文件夾中\nmvn package\n# 安裝 jar 包到本地存儲庫（${user.home}/.m2/repository）\nmvn install\n# 生成自己的 maven 站點\nmvn site\n```\n\n- SNAPSHOT 是什麼？\n\n    snapshot 簡要的意思，在版本號之後添加 `-SNAPSHOT` 是說明該版本仍處於開發階段，不是最終的發行版本。以 `x.y-SNAPSHOT` 版本為例，發行時會去除 `-SNAPSHOT`  後綴，然後將最新的開發版本升爲`x.(y+1)-SNAPSHOT` 。\n\n- 使用 mvn compile 生成的 jar 包，其內容是怎樣的？\n\n    除了 class 文件外，還有 `META-INF` 文件夾，裏面存放一些清單文件和pom 文件。存放到項目資源文件夾（`main/resources` ）的文件也會被打包到`META-INF` 文件夾中，代碼中可通過`getClass().getResourceAsStream( \"/application.properties\" )` 調用。\n\n    ```bash\n    $ jar tf target/testmaven-1.0-SNAPSHOT.jar \n    META-INF/\n    META-INF/MANIFEST.MF\n    B.class\n    MemoryLayoutTest.class\n    A.class\n    C.class\n    META-INF/maven/\n    META-INF/maven/org.example/\n    META-INF/maven/org.example/testmaven/\n    META-INF/maven/org.example/testmaven/pom.xml\n    META-INF/maven/org.example/testmaven/pom.properties\n    ```\n\n### Gradle 项目\n\n**（1）安裝**\n\n可從 [gradle 官網](https://www.gradle.org/downloads)下載解壓並配置環境變量的方式安裝。Mac 用戶還可以使用 `brew install gradle` 的方式安裝。或者直接使用 IDEA 項目中的 `gradle-wrapper` ，此時對應的 `gradle` 命令變爲 `gradlew`。\n\n**（2）gradle 命令能做什麼？**\n\ngradle 命令能構建項目， 查看項目依賴、子項目和項目配置等等。\n\n```bash\n$ gradle tasks\n\n:tasks\n\n== All tasks runnable from root project\n\n== Build Setup tasks\nsetupBuild - Initializes a new Gradle build. [incubating]\n\n== Help tasks\ndependencies - Displays all dependencies declared in root project 'gs-gradle'.\ndependencyInsight - Displays the insight into a specific dependency in root project 'gs-gradle'.\nhelp - Displays a help message\nprojects - Displays the sub-projects of root project 'gs-gradle'.\nproperties - Displays the properties of root project 'gs-gradle'.\ntasks - Displays the tasks runnable from root project 'gs-gradle'.\n\nTo see all tasks and more detail, run with --all.\n\nBUILD SUCCESSFUL\n\nTotal time: 3.077 secs\n```\n\n**（3）初始化一個 Gradle 項目**\n\n在項目文件夾中新建一個名爲 `build.gradle` 的文件，其內容如下：\n\n```groovy\napply plugin: 'java'\n```\n\n隨後新建一個名爲 `settings.gradle` 的文件，其內容可暫時爲空。\n\n在 IDEA 中打開此項目，隨後 IDEA 會自動配置加入 `gradle-wrapper` ，其過程等價於執行以下命令：\n\n```bash\ngradle wrapper --gradle-version 6.5\n```\n\n**（4）編譯打包**\n\n```bash\n# 編譯項目，會默認在 build/classes 中生成類文件，在 build/libs 中生成 jar 包\ngradle build\n# 或使用 gradle wrapper\n./gradlew build\n\n# 清理生成的文件\ngradle clean\n\n# 生成 jar 文件\ngradle jar\n\n# 運行生成的 jar 文件\ngradle run\n\n# 進行單元測試\ngradle test\n```\n\n**（5）`build.gradle` 中可配置什麼？**\n\n```groovy\n// 配置插件，插件提供語法定義\napply plugin: 'java'\napply plugin: 'application'\n\n// 配置入口類\nmainClassName = 'hello.HelloWorld'\n\n// 配置依賴倉庫\nrepositories {\n    mavenCentral()\n}\n\n// 配置生成的 jar 文件的入口類\njar {\n    manifest {\n        attributes 'Main-Class': mainClassName\n    }\n}\n\n// 配置 JDK 兼容性\nsourceCompatibility = 1.8\ntargetCompatibility = 1.8\n\n// 配置依賴\ndependencies {\n    compile \"joda-time:joda-time:2.2\"\n    testCompile \"junit:junit:4.12\"\n}\n```\n\n如需將所有依賴 jar 打進同一個 jar 包，可使用 [shadow 插件](https://github.com/johnrengelman/shadow)或使用 [spring boot 插件](https://spring.io/quickstart)。","slug":"it/java/java-basic","published":1,"date":"2020-12-01T22:20:10.000Z","updated":"2020-12-02T07:05:32.442Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cki72psxd0006slw80vj4wgnh","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css\"><p>Java 自 95 年誕生至今，已有 25 年的歷史。它是一種半編譯的語言，先將代碼編譯成字節碼，然後在 JVM 中解釋執行。</p>\n<ul>\n<li>它是一種面向對象的語言，封裝、繼承和多態它都有，類可以多實現但不支持多繼承，而接口可以多繼承。</li>\n<li>它支持 8 種基本數據類型，同時還提供了其包裝類型，另外還提供了 BigDecimal 精確處理浮點數、提供了 BigInteger 處理大整數。</li>\n<li>它的方法只有值傳遞，傳遞對象時它是淺拷貝而非深拷貝。類的方法可以被子類重寫，同個類可以有多個同名的重載方法。</li>\n<li>它支持泛型，一種將類型參數化的技術。不過，也有人稱之爲「僞泛型」，因爲類型會在編譯時被擦除。</li>\n<li>它支持反射，一種在運行時操作任意對象的方法和屬性的技術，這在框架應用中很常見。</li>\n<li>它提供了豐富的集合類、迭代器及工具類。</li>\n<li>它支持多線程，一種在程序進程中同時執行多個任務的技術，同時還有豐富的鎖類型，所有對象的頭信息裏都有一個鎖標識。</li>\n<li>它支持異常處理，Exception 分編譯時異常和運行時異常，編譯時異常可以被編譯器檢查到，而運行時異常只能在程序運行時發生。</li>\n<li>它有豐富的 I/O API，派生自 4 個抽象類，InputStream、OutputStream、Reader、Writer，字符流的出現是爲了減少 JVM 進行字符編碼解碼的資源損耗和編解碼錯誤。</li>\n<li>另外，目前有兩大項目管理工具，Maven 和 Gradle。</li>\n</ul>\n<a id=\"more\"></a>\n\n<h2 id=\"Java-入門（基礎概念與常識）\"><a href=\"#Java-入門（基礎概念與常識）\" class=\"headerlink\" title=\"Java 入門（基礎概念與常識）\"></a>Java 入門（基礎概念與常識）</h2><h3 id=\"歷史\"><a href=\"#歷史\" class=\"headerlink\" title=\"歷史\"></a>歷史</h3><p>Java 編程語言本名爲 oak（橡樹），因爲商標被註冊了，所以更名爲 Java，而 Java 是印尼的一座島嶼，盛產咖啡豆，有一種咖啡就是以該島命名，Java 編程語言之名因之。使用十六進制編輯器打開 class 文件時會發現前 32 位顯示爲 <code>CA FE BA BE</code> ，即 cafe babe （咖啡寶貝）。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexdump Test.class</span><br><span class=\"line\"><span class=\"number\">0000000</span> ca fe ba be <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">3</span>b <span class=\"number\">00</span> <span class=\"number\">51</span> <span class=\"number\">0</span>a <span class=\"number\">00</span> <span class=\"number\">02</span> <span class=\"number\">00</span> <span class=\"number\">03</span> <span class=\"number\">07</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>1994 年完成 1.0 版本。</li>\n<li>1995 年首次對外發佈，Java 語言誕生。</li>\n<li>1996 年JDK 1.0 誕生。</li>\n<li>2004 年 SUN 公司發佈 Java SE 5。</li>\n<li>2005 年 SUN 公司發佈 Java SE 6。</li>\n<li>2006 年 SUN 公司推出 OpenJDK 計劃。</li>\n<li>2014年 Oracle 公司發佈 Java SE 8。</li>\n<li>2017年 Oracle公司發佈 Java SE 9。</li>\n<li>2020 年 Oracle 公司發佈 Java SE 15。</li>\n</ul>\n<h3 id=\"安裝與卸載JDK\"><a href=\"#安裝與卸載JDK\" class=\"headerlink\" title=\"安裝與卸載JDK\"></a>安裝與卸載JDK</h3><p>在 Mac 環境下，從 <a href=\"https://www.oracle.com/tw/java/technologies/javase-downloads.html\" target=\"_blank\" rel=\"noopener\">Oracle JavaSE 下載地址</a> 下載並安裝。安裝完成後執行 <code>java -version</code>  可查看安裝的版本，以確認安裝成功。安裝後的Java Home 位置爲 <code>/Library/Java/JavaVirtualMachines/jdk-9.0.1.jdk/Contents/Home</code> 。如需卸載該 jdk，可安裝以下 shell 命令，先移除插件後根據查詢到的 jdk 版本移除整個 jdk 文件夾即可。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo rm -fr /Library/Internet\\ Plug-Ins/JavaAppletPlugin.plugin</span><br><span class=\"line\">sudo rm -fr /Library/PreferencesPanes/JavaControlPanel.prefpane</span><br><span class=\"line\"></span><br><span class=\"line\">ls /Library/Java/JavaVirtualMachines/</span><br><span class=\"line\">输出：jdk-9.0.1.jdk</span><br><span class=\"line\"></span><br><span class=\"line\">sudo rm -rf /Library/Java/JavaVirtualMachines/jdk-9.0.1.jdk</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Hello-World\"><a href=\"#Hello-World\" class=\"headerlink\" title=\"Hello World\"></a>Hello World</h3><p>運行以下代碼，將輸出 <code>Hello World</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> hello;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Hello</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Hello World\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Java-語言的特點\"><a href=\"#Java-語言的特點\" class=\"headerlink\" title=\"Java 語言的特點\"></a>Java 語言的特點</h3><ol>\n<li>面向對象（封裝，繼承，多態）</li>\n<li>平台無關性（ Java 虛擬機實現平台無關性）</li>\n<li>支持多線程</li>\n<li>編譯與解釋並存</li>\n</ol>\n<p>編譯：生成字節碼(.class文件)，javac 指令。<br>解釋：解釋字節碼成機器碼，java 指令。</p>\n<h3 id=\"JVM、JDK-和-JRE\"><a href=\"#JVM、JDK-和-JRE\" class=\"headerlink\" title=\"JVM、JDK 和  JRE\"></a>JVM、JDK 和  JRE</h3><ol>\n<li>JVM，Java Virtual Machine 的縮寫，即 Java 虛擬機，是運行 Java 字節碼的虛擬機（包含解釋器 java），它包含在 JRE 中。不同的操作系統有特定的 JVM 實現，以便 Java 字節碼可以跨平台。</li>\n<li>JDK，Java Development Kit 的縮寫，即 Java 開發工具集，包含了 JRE 、編譯器（javac）和其他工具（javadoc 和 jdb 等）。</li>\n<li>JRE，Java Runtime 的縮寫，即 Java 運行時，包含了 JVM、必要的類庫、java 命令和其他基礎構件。</li>\n</ol>\n<h3 id=\"Java-與-C-對比\"><a href=\"#Java-與-C-對比\" class=\"headerlink\" title=\"Java 與 C++ 對比\"></a>Java 與 C++ 對比</h3><ol>\n<li>皆支持面向對象編程（封裝、繼承和多態）。</li>\n<li>Java 不提供指針來直接訪問內存；C++ 提供。</li>\n<li>Java 的類不支持多繼承，但接口可以；C++ 的類可以多繼承。</li>\n<li>Java 有內存垃圾自動回收機制（GC），不需要手動釋放無用內存；C++ 沒有。</li>\n<li>Java 字符串和字符數組沒有結束符的概念；C/C++ 中字符串和字符數組最後會有一個額外的字符<code>\\0</code> 來表示結束。</li>\n</ol>\n<h2 id=\"Java-語法\"><a href=\"#Java-語法\" class=\"headerlink\" title=\"Java 語法\"></a>Java 語法</h2><h3 id=\"基本類型及其大小\"><a href=\"#基本類型及其大小\" class=\"headerlink\" title=\"基本類型及其大小\"></a>基本類型及其大小</h3><p>Java 共 8 種數據類型（不包括 void），具體如下表：</p>\n<p><img src=\"/2020/12/02/it/java/java-basic/20201202_24328.png\" alt></p>\n<p>boolean 值的大小取決於 JVM 實現，Java 虛擬機規範（第8版）規定：單個 boolean佔 4 個字節，而 boolean 數組 1 個字節。</p>\n<p>char 值是一個 16 位的 Unicode 字符，最小值是 ‘\\u0000’ ，最大值是 ‘\\uffff’，即 0～65535，每個數字對應一個字符。</p>\n<ul>\n<li><p>代碼</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span> a = <span class=\"string\">'中'</span>;</span><br><span class=\"line\">System.out.println((<span class=\"keyword\">int</span>)a);</span><br><span class=\"line\"><span class=\"comment\">// 輸出 20013</span></span><br><span class=\"line\">System.out.println(Integer.toHexString(a));</span><br><span class=\"line\"><span class=\"comment\">// 輸出 4e2d</span></span><br><span class=\"line\">System.out.println(<span class=\"string\">'\\u4e2d'</span>);</span><br><span class=\"line\"><span class=\"comment\">// 輸出 中</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>byte、short、int、long 類型，採用二進制補碼存儲數據，以便利減法運算。</p>\n<ul>\n<li>二進制補碼<ul>\n<li>過程：正數的補碼是其自身；負數的補碼是除符號位外所有二進制位做反碼後加 1 的結果。</li>\n<li>原理：假定 X、Y 是两个占1个字节的数。X-Y 等价于 X+(-Y) ，而 -Y 可以看作 0-Y，假定是 0 不足以被减，向上借 1 变为 1 0000 0000，而  1 0000 0000 又等價於 1111 1111 + 1，於是 -Y = 1111 1111 - Y + 1，即 Y 的反碼再 + 1。 見 <a href=\"https://www.ruanyifeng.com/blog/2009/08/twos_complement.html\" target=\"_blank\" rel=\"noopener\">https://www.ruanyifeng.com/blog/2009/08/twos_complement.htm</a>l</li>\n</ul>\n</li>\n</ul>\n<p>long 類型的數據後面一定要加上 L，否則會被認為是整型。</p>\n<p>char 類型值使用單引號括起來，String 使用雙引號。</p>\n<p>Java 有<strong>自動拆裝箱機制</strong>，裝箱即把基本類型使用其包裝類型包裝起來，拆箱即把包裝類型拆成基本類型。</p>\n<h3 id=\"包裝類型及常量池技術\"><a href=\"#包裝類型及常量池技術\" class=\"headerlink\" title=\"包裝類型及常量池技術\"></a>包裝類型及常量池技術</h3><ol>\n<li>Byte、Short、Integer 和 Long 分別默認創建了數值 [-128, 127] 的相應類型的緩存數據。</li>\n<li>Character 創建了數值在 [0, 127] 的緩存數據。</li>\n<li>Boolean 直接返回 True 和 False。</li>\n<li>Float 和 Double 沒有實現常量池技術。</li>\n</ol>\n<p>使用常量池技術意味著在緩存範圍內的包裝類型對象是相等的，除非 new 一個對象。使用包裝器的 valueOf 方法默認會先去緩存中取對象，取不到才會 new 一個。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Integer i1 = <span class=\"number\">33</span>;</span><br><span class=\"line\">Integer i2 = <span class=\"number\">33</span>;</span><br><span class=\"line\">System.out.println(i1 == i2);<span class=\"comment\">// 输出 true</span></span><br><span class=\"line\">Integer i11 = <span class=\"number\">333</span>;</span><br><span class=\"line\">Integer i22 = <span class=\"number\">333</span>;</span><br><span class=\"line\">System.out.println(i11 == i22);<span class=\"comment\">// 输出 false</span></span><br><span class=\"line\">Double i3 = <span class=\"number\">1.2</span>;</span><br><span class=\"line\">Double i4 = <span class=\"number\">1.2</span>;</span><br><span class=\"line\">System.out.println(i3 == i4);<span class=\"comment\">// 输出 false</span></span><br></pre></td></tr></table></figure>\n\n<p>《阿里巴巴Java開發手冊》規定：</p>\n<ul>\n<li>【強制】<strong>所有的 POJO 類屬性必須使用包裝數據類型</strong>。</li>\n<li>【強制】RPC 方法的返回值和參數必須使用包裝數據類型。</li>\n<li>【推薦】所有的局部變量使用基本數據類型。</li>\n</ul>\n<h3 id=\"BigDecimal\"><a href=\"#BigDecimal\" class=\"headerlink\" title=\"BigDecimal\"></a>BigDecimal</h3><p><strong>（1）使用 BigDecimal 進行浮點數比較和精度取捨</strong></p>\n<p><strong>（2）使用 BigDecimal(String) 或 BigDecimal.valueOf(double) 構造對象</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">float</span> a = <span class=\"number\">1.0f</span> - <span class=\"number\">0.9f</span>;</span><br><span class=\"line\"><span class=\"keyword\">float</span> b = <span class=\"number\">0.9f</span> - <span class=\"number\">0.8f</span>;</span><br><span class=\"line\">System.out.println(a);</span><br><span class=\"line\">System.out.println(b);</span><br><span class=\"line\">System.out.println(a == b); <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\">BigDecimal a = <span class=\"keyword\">new</span> BigDecimal(<span class=\"string\">\"1.0\"</span>);</span><br><span class=\"line\">BigDecimal b = <span class=\"keyword\">new</span> BigDecimal(<span class=\"string\">\"0.9\"</span>);</span><br><span class=\"line\">BigDecimal c = <span class=\"keyword\">new</span> BigDecimal(<span class=\"string\">\"0.8\"</span>);</span><br><span class=\"line\">System.out.println(a.subtract(b));</span><br><span class=\"line\">System.out.println(b.subtract(c));</span><br><span class=\"line\">System.out.println(a.subtract(b).equals(b.subtract(c))); <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\">BigDecimal a = <span class=\"keyword\">new</span> BigDecimal(<span class=\"string\">\"1.1252312\"</span>);</span><br><span class=\"line\"><span class=\"comment\">// 取小數點後 2 位，四捨五入</span></span><br><span class=\"line\">BigDecimal scale = a.setScale(<span class=\"number\">2</span>, RoundingMode.HALF_UP);</span><br><span class=\"line\">System.out.println(scale.toString()); <span class=\"comment\">// 1.13</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"對象及其大小\"><a href=\"#對象及其大小\" class=\"headerlink\" title=\"對象及其大小\"></a>對象及其大小</h3><p>基本類型的封裝類型是對象，Java 中的對象由以下部分組成：</p>\n<ol>\n<li>對象頭（object header）：由 mark word 和 class pointer 組成。mark word 存儲了對象的 hashcode、GC信息和鎖信息；class pointer 存儲了指向類對象的指針。32 位的 JVM 上對象頭佔 8 個字節，mark word 和 class pointer 各佔一半。64 位的 JVM 默認開啟了壓縮指針選項（-XX+UseCompressedOops）後上對象頭佔用 12 個字節，mark word 佔用 8 個字節，class pointer 佔用 4 個字節。</li>\n<li>實例數據（instance data）：</li>\n<li>對齊填充（padding）</li>\n</ol>\n<p>可使用 <code>org.openjdk.jol</code> 工具查看一個對象佔用的字節大小，</p>\n<ul>\n<li><p>如下：</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">    System.out.println(VM.current().details());</span><br><span class=\"line\">    System.out.println(ClassLayout.parseClass(Object.class).toPrintable());</span><br><span class=\"line\">    System.out.println(ClassLayout.parseInstance(Integer.valueOf(<span class=\"number\">1</span>)).toPrintable());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>  輸出結果：</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Running 64-bit HotSpot VM.</span></span><br><span class=\"line\"><span class=\"comment\"># Using compressed oop with 3-bit shift.</span></span><br><span class=\"line\"><span class=\"comment\"># Using compressed klass with 3-bit shift.</span></span><br><span class=\"line\"><span class=\"comment\"># WARNING | Compressed references base/shifts are guessed by the experiment!</span></span><br><span class=\"line\"><span class=\"comment\"># WARNING | Therefore, computed addresses are just guesses, and ARE NOT RELIABLE.</span></span><br><span class=\"line\"><span class=\"comment\"># WARNING | Make sure to attach Serviceability Agent to get the reliable addresses.</span></span><br><span class=\"line\"><span class=\"comment\"># Objects are 8 bytes aligned.</span></span><br><span class=\"line\"><span class=\"comment\"># Field sizes by type: 4, 1, 1, 2, 2, 4, 4, 8, 8 [bytes]</span></span><br><span class=\"line\"><span class=\"comment\"># Array element sizes: 4, 1, 1, 2, 2, 4, 4, 8, 8 [bytes]</span></span><br><span class=\"line\"></span><br><span class=\"line\">java.lang.Object object internals:</span><br><span class=\"line\"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class=\"line\">      0    12        (object header)                           N/A</span><br><span class=\"line\">     12     4        (loss due to the next object alignment)</span><br><span class=\"line\">Instance size: 16 bytes</span><br><span class=\"line\">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br><span class=\"line\"></span><br><span class=\"line\">java.lang.Integer object internals:</span><br><span class=\"line\"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class=\"line\">      0     4        (object header)                           01 c9 01 4e (00000001 11001001 00000001 01001110) (1308739841)</span><br><span class=\"line\">      4     4        (object header)                           3d 00 00 00 (00111101 00000000 00000000 00000000) (61)</span><br><span class=\"line\">      8     4        (object header)                           48 71 00 00 (01001000 01110001 00000000 00000000) (29000)</span><br><span class=\"line\">     12     4    int Integer.value                             1</span><br><span class=\"line\">Instance size: 16 bytes</span><br><span class=\"line\">Space losses: 0 bytes internal + 0 bytes external = 0 bytes total</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>結論：在 64 位開啟指針壓縮的環境下，Object 對象佔用 16 個字節，Integer 對象也佔用 16 個字節。</p>\n<h3 id=\"String、StringBuffer-和-String-Builder-的區別\"><a href=\"#String、StringBuffer-和-String-Builder-的區別\" class=\"headerlink\" title=\"String、StringBuffer 和 String Builder 的區別\"></a>String、StringBuffer 和 String Builder 的區別</h3><p>String 類使用 final 修飾字符數組或字節數組來保存字符串，所以 String 對象是不可變的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">String</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// Java 9 之前</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">char</span>[] value;</span><br><span class=\"line\">\t<span class=\"comment\">// Java 9 之後</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">byte</span>[] value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>StringBuilder  和 StringBuffer 都繼承自 AbstractStringBuilder，AbstractStringBuilder 使用字符數組來保存字符串，但沒有使用 final 關鍵字修飾，所以這兩者是可變的。</p>\n<p>下面從不同角度比較下此三者：</p>\n<ol>\n<li>線程安全性：String 對象不可變，線程安全；StringBuffer 對方法加了同步鎖，線程安全；StringBuilder 對方法沒有加同步鎖，線程不安全。</li>\n<li>性能：每次對 String 類型進行改變時會生成一個新的 String 對象，然後將指針指向新的 String 對象。StringBuffer 和 StringBuilder 每次對自身進行操作，不生成新對象。同等情況下， StringBuilder 比 StringBuffer 能提升 10%～15% 性能，但要冒線程不安全的風險。</li>\n</ol>\n<h3 id=\"注釋\"><a href=\"#注釋\" class=\"headerlink\" title=\"注釋\"></a>注釋</h3><p>代碼即注釋。先讓標識符見名知意，然後再考慮增加注釋。</p>\n<h3 id=\"標識符和關鍵字的區別\"><a href=\"#標識符和關鍵字的區別\" class=\"headerlink\" title=\"標識符和關鍵字的區別\"></a>標識符和關鍵字的區別</h3><p>標識符是程序、類、變量、方法等取的名字，而關鍵字是具備特殊含義的標識符。常見的關鍵字有：</p>\n<ol>\n<li>訪問控制：private、protected、public</li>\n<li>類、方法和變量修飾符：abstract、class、extends、final、implements、interface、native、new、static、strictfp、synchronized、transient、volatile</li>\n<li>程序控制：break、continue、return、do、while、if、else、for、instanceof、switch、case、default</li>\n<li>錯誤處理：try、catch、throw、throws、finally</li>\n<li>包相關：import、package</li>\n<li>基本類型：boolean、byte、char、double、float、int、short、null、true、false</li>\n<li>變量引用：super、this、void</li>\n<li>保留字：goto、const</li>\n</ol>\n<h3 id=\"自增自減運算符\"><a href=\"#自增自減運算符\" class=\"headerlink\" title=\"自增自減運算符\"></a>自增自減運算符</h3><p>符號在前先加減再賦值，符號在後先賦值後加減。假定 <code>a = 1; b = a++</code> 最後 a 值爲 2，b 值爲 1。</p>\n<h3 id=\"和-equals-的區別\"><a href=\"#和-equals-的區別\" class=\"headerlink\" title=\"== 和 equals 的區別\"></a>== 和 equals 的區別</h3><ol>\n<li>基本數據類型 == 比較的是值，引用數據類型 == 比較的是內存地址。</li>\n<li>equals 是 Object 類的方法，如無重寫該方法，則默認使用 == 比較對象，即比較內存地址；String 類重寫了 equals 方法使其比較得是值。</li>\n<li>整型包裝類都應使用 equals 比較大小。</li>\n<li>浮點數之間的等值判斷，基本數據類型不能用==來比較，包裝數據類型不能用 equals 來判斷。</li>\n</ol>\n<ul>\n<li><p>重寫 equals 方法通常同時需要重寫 hashcode 方法，爲什麼？</p>\n<p>  hashcode 是 Object 類的一個本地方法，其實現時將對象的內存地址轉爲一個 int 值，不同的對象的 hashcode 可能相同。 HashSet 集合進行元素重複校驗時先比較 hashcode ，當 hashcode 一樣時再調用 equals，提高了校驗效率。因此，如果只重寫 equals 方法而不重寫 hashcode 方法，會出現 equals 返回 true，而 hashcode 不等的情況，這樣如果要求 HashSet 去重就會失敗。</p>\n<p>  HashSet 基於 HashMap 實現，HashMap 內部有一哈希表，裏面使用 hashcode 進行散列存儲。</p>\n</li>\n</ul>\n<h3 id=\"序列化時如果有些字段不想序列化，怎麼辦？\"><a href=\"#序列化時如果有些字段不想序列化，怎麼辦？\" class=\"headerlink\" title=\"序列化時如果有些字段不想序列化，怎麼辦？\"></a>序列化時如果有些字段不想序列化，怎麼辦？</h3><p>使用 transient 關鍵字修飾不想序列化的字段。</p>\n<h3 id=\"continue、break-和-return-的區別\"><a href=\"#continue、break-和-return-的區別\" class=\"headerlink\" title=\"continue、break 和 return 的區別\"></a>continue、break 和 return 的區別</h3><ol>\n<li>continue：跳出當前這一次循環，繼續下一次循環。</li>\n<li>break：跳出整個循環體，繼續執行循環外的語句。</li>\n<li>return：跳出所在的方法，結束方法，可以帶一個返回值。</li>\n</ol>\n<h3 id=\"泛型、類型擦除和通配符\"><a href=\"#泛型、類型擦除和通配符\" class=\"headerlink\" title=\"泛型、類型擦除和通配符\"></a>泛型、類型擦除和通配符</h3><p><strong>泛型的本質是將類型參數化。</strong>Java 的泛型（generics）是 JDK 5 中引入的新特性，還提供了編譯時類型安全檢測機制來檢測非法的類型。但是 Java 的泛型在編譯期間會將泛型信息擦除，即類型擦除，因此也被稱爲<strong>僞泛型</strong>。下面的例子展示了如何在運行期加入非法類型。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">list.add(<span class=\"number\">12</span>);</span><br><span class=\"line\"><span class=\"comment\">//這裡直接添加會報錯</span></span><br><span class=\"line\"><span class=\"comment\">// list.add(\"a\");</span></span><br><span class=\"line\">Class&lt;? extends List&gt; clazz = list.getClass();</span><br><span class=\"line\">Method add = clazz.getDeclaredMethod(<span class=\"string\">\"add\"</span>, Object.class);</span><br><span class=\"line\"><span class=\"comment\">//但是通過反射添加，是可以的</span></span><br><span class=\"line\">add.invoke(list, <span class=\"string\">\"kl\"</span>);</span><br><span class=\"line\">System.out.println(list);</span><br></pre></td></tr></table></figure>\n\n<p>泛型分泛型接口、泛型類和泛型方法。泛型類的具體類型通過實例化時傳入，泛型方法的具體類型通過方法調用時傳入的參數確定。</p>\n<p>泛型通配符約定：</p>\n<ol>\n<li>？ 表示不確定的 Java 類型，用於泛型方法</li>\n<li>T（Type）表示確定的一個 Java 類型</li>\n<li>K V（Key Value）分別表示映射中的鍵、值</li>\n<li>E（Element）表示集合中的一個元素</li>\n<li>&lt;? extends A&gt; 上界通配符，表示 A 類型或其子類</li>\n<li>&lt;? super A&gt; 下界通配符，表示 A 類型或其父類</li>\n<li><t extends a> 表示 A 類型或其子類的一種</t></li>\n<li>&lt;T extends A &amp; B&gt; 表示 A 類型且B類型的子類的一種</li>\n<li><del><t super a></t></del> </li>\n</ol>\n<p>泛型不是協變的，已知 Apple 繼承自 Fruit 的情況下，Plate<apple> 的引用並不能傳遞給 Plate<fruit>，但可以傳遞給 Plate&lt;? extends Fruit&gt;。</fruit></apple></p>\n<p>元素爲 &lt;? extends E&gt; 的集合，只能取出 E，而不能存入 E 及其子類的對象。因爲只能確定該類型是 E 的子類，但具體是哪個子類未知，因此編譯器不允許插入任何 E 或其子類的對象，取出來的時候只能當 E 類型。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">  List&lt;? extends A&gt; list = Arrays.asList(<span class=\"keyword\">new</span> A(), <span class=\"keyword\">new</span> B());</span><br><span class=\"line\">  list.add(<span class=\"keyword\">new</span> A()); <span class=\"comment\">// 報錯</span></span><br><span class=\"line\">  list.add(<span class=\"keyword\">new</span> B()); <span class=\"comment\">// 報錯</span></span><br><span class=\"line\">  A a = list.get(<span class=\"number\">1</span>);</span><br><span class=\"line\">  System.out.println(a.toString());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>元素爲 &lt;? super E&gt; 的集合，只能取出 Object，只能存入 E 及其子類的對象。因爲只能確定該類型是 E 的超類，但不知是哪一個超類，所以插入任何 E 及其子類的對象是沒問題的，但是插入 E 的超類就不行了，取出來的時候也只能是 Object，因爲 Object 是一切類的超類。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">  List&lt;? <span class=\"keyword\">super</span> B&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">  list.add(<span class=\"keyword\">new</span> A()); <span class=\"comment\">// 報錯</span></span><br><span class=\"line\">  list.add(<span class=\"keyword\">new</span> B());</span><br><span class=\"line\">  list.add(<span class=\"keyword\">new</span> C());</span><br><span class=\"line\">  Object object = list.get(<span class=\"number\">1</span>);</span><br><span class=\"line\">  System.out.println(object.toString());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span> <span class=\"keyword\">extends</span> <span class=\"title\">B</span></span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"獲取鍵盤輸入數據的常用方法\"><a href=\"#獲取鍵盤輸入數據的常用方法\" class=\"headerlink\" title=\"獲取鍵盤輸入數據的常用方法\"></a>獲取鍵盤輸入數據的常用方法</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方法一：使用 Scanner，可以快速確定輸入數據的類型，按空格符分割數據</span></span><br><span class=\"line\">Scanner scanner = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\">String s = scanner.nextLine();</span><br><span class=\"line\">System.out.println(s);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方法二：使用 BufferedReader 讀取字符序列，高效但需要轉換成其他類型，會拋出 IOException</span></span><br><span class=\"line\">BufferedReader bufferedReader = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> InputStreamReader(System.in));</span><br><span class=\"line\">String s1 = bufferedReader.readLine();</span><br><span class=\"line\">System.out.println(s1);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"方法（函數）\"><a href=\"#方法（函數）\" class=\"headerlink\" title=\"方法（函數）\"></a>方法（函數）</h2><h3 id=\"爲什麼-Java-只有值傳遞？\"><a href=\"#爲什麼-Java-只有值傳遞？\" class=\"headerlink\" title=\"爲什麼 Java 只有值傳遞？\"></a>爲什麼 Java 只有值傳遞？</h3><p>首先要明瞭程序設計語言中的有關函數參數傳遞的兩種方法：</p>\n<ol>\n<li>按值調用（call by value）：方法接收調用者提供的參數的值，方法內無法修改實際參數值。</li>\n<li>按引用調用（call by reference）：方法接收調用者提供的參數的地址，方法內可以修改實際參數值。</li>\n</ol>\n<p><strong>Java 總是採用按值調用，所有參數值都是一個拷貝，無法修改實際參數值。對於引用類型參數，傳遞的是引用的拷貝，引用的拷貝和引用指向同一個對象，即所謂的淺拷貝</strong>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">  String s1 = <span class=\"string\">\"Hello\"</span>;</span><br><span class=\"line\">  String s2 = <span class=\"string\">\"World\"</span>;</span><br><span class=\"line\">  swap(s1, s2);</span><br><span class=\"line\">  System.out.printf(<span class=\"string\">\"main s1: %s, s2: %s%n\"</span>, s1, s2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(String s1, String s2)</span> </span>&#123;</span><br><span class=\"line\">  String tmp = s1;</span><br><span class=\"line\">  s1 = s2;</span><br><span class=\"line\">  s2 = tmp;</span><br><span class=\"line\">  System.out.printf(<span class=\"string\">\"swap s1: %s, s2: %s%n\"</span>, s1, s2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 運行結果：</span></span><br><span class=\"line\"><span class=\"comment\">// swap s1: World, s2: Hello</span></span><br><span class=\"line\"><span class=\"comment\">// main s1: Hello, s2: World</span></span><br></pre></td></tr></table></figure>\n\n<p>結論：</p>\n<ol>\n<li>一個方法不能修改一個基本類型的實參。</li>\n<li>一個方法可以改變一個對象類型的實參狀態。</li>\n<li>一個方法不能讓對象類型的實參引用一個新對象。</li>\n</ol>\n<h3 id=\"深拷貝和淺拷貝有什麼不同？\"><a href=\"#深拷貝和淺拷貝有什麼不同？\" class=\"headerlink\" title=\"深拷貝和淺拷貝有什麼不同？\"></a>深拷貝和淺拷貝有什麼不同？</h3><ol>\n<li>淺拷貝：對基本類型拷貝其值；對引用類型拷貝其引用。</li>\n<li>深拷貝：對基本類型拷貝其值；對引用類型，新建一個對象並拷貝原對象的值。</li>\n</ol>\n<p><img src=\"/2020/12/02/it/java/java-basic/Untitled.png\" alt></p>\n<h3 id=\"重載和重寫有什麼區別？\"><a href=\"#重載和重寫有什麼區別？\" class=\"headerlink\" title=\"重載和重寫有什麼區別？\"></a>重載和重寫有什麼區別？</h3><ol>\n<li>重載（overloading）：在一個類中，有多個同名但不同傳入參數的方法，各個重載方法簽名不同。</li>\n<li>重寫（overwrite）：子類對父類允許訪問的方法的重新編寫，方法簽名不變，訪問修飾符只能降低不能提高，拋出的異常只能更小，返回值類型也是。</li>\n</ol>\n<h2 id=\"Java-面向對象\"><a href=\"#Java-面向對象\" class=\"headerlink\" title=\"Java 面向對象\"></a>Java 面向對象</h2><h3 id=\"面向對象和面向過程\"><a href=\"#面向對象和面向過程\" class=\"headerlink\" title=\"面向對象和面向過程\"></a>面向對象和面向過程</h3><ol>\n<li>面向過程：不需要實例化對象，內存和 CPU 開銷小，但不容易維護。</li>\n<li>面向對象：需要實例化對象，內存和 CPU 開銷大，但易維護、易復用、易擴展。</li>\n</ol>\n<p>Java 因爲編譯出的字節碼並不能直接在機器上運行，因而效率上會稍慢。但一些面向過程的腳本語言性能也不一定比 Java 好。</p>\n<h3 id=\"構造方法\"><a href=\"#構造方法\" class=\"headerlink\" title=\"構造方法\"></a>構造方法</h3><ol>\n<li>特點：名字跟類名相同，沒有返回值，不可重寫但可重載。</li>\n<li>作用：執行對象的初始化工作，如果類沒有重載任何構造方法，那默認會有不帶參數的構造方法。</li>\n<li>子類初始化時一定會調用父類的構造方法，即使子類不顯式調用，也會默認調用父類的無參構造方法。</li>\n</ol>\n<h3 id=\"成員變量和局部變量的區別\"><a href=\"#成員變量和局部變量的區別\" class=\"headerlink\" title=\"成員變量和局部變量的區別\"></a>成員變量和局部變量的區別</h3><ol>\n<li>成員變量：屬於類；可以被 public、private、static 等修飾符修飾；如用 static 修飾則變量屬於類，否則屬於對象存在於堆內存；生命週期隨對象；自動賦予初始化值。</li>\n<li>局部變量：屬於代碼塊或方法；只能被 final 修飾；存在於棧內存；生命週期隨代碼塊或方法；不會自動賦予初始化值。</li>\n</ol>\n<h3 id=\"對象實例和對象引用的區別\"><a href=\"#對象實例和對象引用的區別\" class=\"headerlink\" title=\"對象實例和對象引用的區別\"></a>對象實例和對象引用的區別</h3><ol>\n<li>對象實例：存在於堆內存，一個對象實例可以被多個引用指向。</li>\n<li>對象引用：存在於棧內存，一個引用指向一個對象實例。</li>\n</ol>\n<h3 id=\"面向對象的三大特徵\"><a href=\"#面向對象的三大特徵\" class=\"headerlink\" title=\"面向對象的三大特徵\"></a>面向對象的三大特徵</h3><p><strong>（1）封裝</strong></p>\n<p>封裝是將一個對象的狀態信息（即屬性）隱藏在對象內部，一般不允許外界直接訪問，而是提供必要的方法給外界操作。</p>\n<p><strong>（2）繼承</strong></p>\n<p>繼承是使用已有的類創建新類的技術，它提高了代碼復用率和開發效率。關於繼承以下幾點務必明瞭：</p>\n<ol>\n<li>子類擁有父類所有的屬性和方法（包括私有的），但父類中的私有屬性和方法子類無法訪問（反射子類也無法訪問），<strong>僅僅擁有</strong>。</li>\n<li>子類可以對父類進行擴展，增加新的屬性和方法。</li>\n<li>子類可以重寫父類的方法。</li>\n</ol>\n<p><strong>（3）多態</strong></p>\n<p>多態，即一個對象可以擁有多種狀態。具體表現在父類的引用可以指向子類的實例。關於多態以下幾點務必知曉：</p>\n<ol>\n<li>對象類型和引用類型之間具有繼承/實現關係。</li>\n<li>對象類型不可變，引用類型可變。</li>\n<li>方法具有多態性，屬性不具有。父類的引用可以調用子類對象的方法，但不能訪問其屬性。</li>\n<li>父類的引用不能調用「只有子類存在但在父類不存在」的方法。</li>\n<li>如果子類重寫了父類的方法，真正執行的是子類覆蓋的方法。</li>\n</ol>\n<h3 id=\"靜態方法內爲什麼不能調用非靜態成員？\"><a href=\"#靜態方法內爲什麼不能調用非靜態成員？\" class=\"headerlink\" title=\"靜態方法內爲什麼不能調用非靜態成員？\"></a><strong>靜態方法內爲什麼不能調用非靜態成員？</strong></h3><p>因爲非靜態成員需要在類實例化成對象後才能被調用，而靜態方法不需要實例化對象就可以被調用。</p>\n<h3 id=\"接口和抽象類的區別\"><a href=\"#接口和抽象類的區別\" class=\"headerlink\" title=\"接口和抽象類的區別\"></a>接口和抽象類的區別</h3><ol>\n<li>方法上：接口的方法默認修飾符是 public，且不能實現（Java 8 開始可以有默認方法和靜態方法，Java 9 開始可以有私有方法和私有靜態方法）；而抽象類可有 public、protected 和 default 修飾符，且可有非抽象的方法。</li>\n<li>變量上：接口只能有 static、final 變量；而抽象類沒有限制。</li>\n<li>繼承上：一個類可以實現多個接口，接口本身也可以擴展多個接口；但一個類只能繼承一個抽象類。</li>\n<li>設計上：接口是對行爲的抽象，是一個行爲規範；抽象類是對類的抽象，是一種模板設計。</li>\n</ol>\n<h2 id=\"Java-核心技術\"><a href=\"#Java-核心技術\" class=\"headerlink\" title=\"Java 核心技術\"></a>Java 核心技術</h2><h3 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h3><p>見 <a href=\"https://linlshare.github.io/2020/12/02/it/java/java-collection/\" target=\"_blank\" rel=\"noopener\">Java 集合</a> </p>\n<h3 id=\"反射機制\"><a href=\"#反射機制\" class=\"headerlink\" title=\"反射機制\"></a>反射機制</h3><p><strong>（1）什麼是反射</strong></p>\n<p>Java 的反射機制是在運行時能知道任意一個類的所有屬性和方法，能調用任意一個對象的屬性和方法。</p>\n<p><strong>（2）反射的優缺點</strong></p>\n<ol>\n<li>優點：運行時確定類型，動態加載類，提高代碼靈活度。</li>\n<li>缺點：反射性能比直接的 Java 代碼慢，存在安全問題，因爲可以動態操作改變類的屬性。</li>\n</ol>\n<p>反射動態加載類的優點即是動態編譯，與之相對的是靜態編譯，靜態編譯是在編譯時就確定了類型。</p>\n<p><strong>（3）反射的應用場景</strong></p>\n<p>反射是框架設計的靈魂。其應用場景有：</p>\n<ol>\n<li>模塊化開發；</li>\n<li>動態代理設計模式；</li>\n<li>Spring 框架的 IOC（控制反轉）和 AOP（面向切面編程）；</li>\n<li>JDBC 連接數據庫等等。</li>\n</ol>\n<h3 id=\"異常\"><a href=\"#異常\" class=\"headerlink\" title=\"異常\"></a>異常</h3><p><strong>（1）簡介</strong></p>\n<p>Java 的異常歸於同一個 Throwable 類，並分爲兩大類：Error 和 Exception。<strong>Error 通常是 JVM 錯誤，程序無法處理</strong>；<strong>而 Exception 是程序本身可以處理的異常</strong>。Exception 分爲 Checked Exceptions（受檢異常）和 Unchecked Exceptions（不受檢異常）。</p>\n<p><img src=\"/2020/12/02/it/java/java-basic/Untitled%201.png\" alt></p>\n<p><strong>Checked Exceptions 又名 Compile Time Exceptions（編譯時異常）</strong>，編譯器可以發現並要求程序處理後才能正常通過編譯，常見的有：</p>\n<ul>\n<li><em>IOException</em></li>\n<li><em>EOFException</em></li>\n<li><em>MalFormedURLException</em></li>\n<li><em>IntruptedException</em></li>\n</ul>\n<p><strong>Unchecked Exception 又名 Runtime Exceptions（運行時異常）</strong>，編譯器無法檢測出，只有運行時才會發生的異常，常見的有：</p>\n<ul>\n<li><em>ArithmaticException</em></li>\n<li><em>NullPointerException</em></li>\n<li><em>IndexOutOfBoundsException</em></li>\n<li><em>ClassCastException</em></li>\n<li><em>ArrayIndexOutOfBoundsException</em></li>\n<li><em>NumberFormatException</em></li>\n</ul>\n<p><strong>（2）Throwable 類常用方法</strong></p>\n<ol>\n<li><code>getMessage</code>：返回異常的簡要描述</li>\n<li><code>toString</code>：返回異常的詳細信息</li>\n<li><code>getLocalizedMessage</code>：返回異常的本地化信息（需要子類覆蓋該方法，否則與 <code>getMessage</code> 一樣）</li>\n<li><code>printStackTrace</code>：在控制台打印 Throwable 对象封装的异常信息</li>\n</ol>\n<p><strong>（3）try-catch-finally</strong></p>\n<ol>\n<li>try 代碼塊：捕獲異常。其後可接零個或多個 catch 代碼塊，如零個則必須接一個 finally 代碼塊。</li>\n<li>catch 代碼塊：處理捕獲到的異常。</li>\n<li>finally 代碼塊：無論是否捕獲或處理異常，finally 代碼塊最終都會被執行。當在 try 代碼塊或 catch 代碼塊中遇到 return 語句時，finally 代碼塊將在方法返回之前被執行。此時如果 finally 中也有 return 語句的話，其返回值將覆蓋 try 或 catch 代碼塊中的返回值。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">f</span><span class=\"params\">(<span class=\"keyword\">int</span> value)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> value * value;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (value == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// f(2) 將返回 0 ，而不是 4.</span></span><br></pre></td></tr></table></figure>\n\n<p>以下情況，finally 代碼塊不會被執行或只部分執行：</p>\n<ol>\n<li>finally 代碼塊中有異常，代碼會中異常處中止；</li>\n<li>在 catch 代碼塊或 finally 塊中調用了 <code>System.exit</code> 函數退出程序；</li>\n<li>程序所在的線程死亡等等不可預料的系統和硬件問題。</li>\n</ol>\n<p><strong>（4）try-witch-resources</strong></p>\n<p>Java 7 中新增了 ****try-witch-resources 語法糖，適用於實現<code>java.lang.AutoCloseable</code> 或者 <code>java.io.Closeable</code> 的對象，可以自動關閉申請的資源，然後再執行 catch 或 finally 代碼塊。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// try-catch-finally</span></span><br><span class=\"line\">Scanner scanner = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    scanner = <span class=\"keyword\">new</span> Scanner(<span class=\"keyword\">new</span> File(<span class=\"string\">\"src/main/resources/test.txt\"</span>));</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (scanner.hasNext()) &#123;</span><br><span class=\"line\">        System.out.println(scanner.nextLine());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (scanner != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        scanner.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// try-witch-resources</span></span><br><span class=\"line\"><span class=\"keyword\">try</span> (Scanner scanner = <span class=\"keyword\">new</span> Scanner(<span class=\"keyword\">new</span> File(<span class=\"string\">\"src/main/resources/test.txt\"</span>))) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (scanner.hasNext()) &#123;</span><br><span class=\"line\">        System.out.println(scanner.nextLine());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"多線程\"><a href=\"#多線程\" class=\"headerlink\" title=\"多線程\"></a>多線程</h3><p>見 <a href=\"https://linlshare.github.io/2020/12/02/it/java/java-concurrent/\" target=\"_blank\" rel=\"noopener\">Java 並發</a> </p>\n<h3 id=\"文件與-I-O-流\"><a href=\"#文件與-I-O-流\" class=\"headerlink\" title=\"文件與 I/O 流\"></a>文件與 I/O 流</h3><p><strong>（1）Java 中 I/O 流分爲幾種？</strong></p>\n<p>按不同的分類方法有不同的分類：</p>\n<ol>\n<li>按流向分：輸入流、輸出流。</li>\n<li>按操作單元分：字節流、字符流。</li>\n<li>按角色分：節點流、處理流。</li>\n</ol>\n<p>Java 中 40 多個 I/O 流相關的類都是從 4 個抽象基類派生：</p>\n<ol>\n<li>InputStream：字節輸入流</li>\n<li>Reader：字符輸入流</li>\n<li>OutputStream：字節輸出流</li>\n<li>Writer：字符輸出流</li>\n</ol>\n<p><img src=\"/2020/12/02/it/java/java-basic/Untitled%202.png\" alt></p>\n<p><img src=\"/2020/12/02/it/java/java-basic/Untitled%203.png\" alt></p>\n<p><strong>（2）爲什麼有了字節流還需要字符流？</strong></p>\n<p>不管是文件讀寫還是網絡發送接收，信息的最小存儲單元都是字節，那為什麼 I/O 流操作要分為字節流操作和字符流操作呢？</p>\n<p>字符流是由 JVM 將字節流轉換得到的，過程非常耗時，且容易出現亂碼問題。所以 I/O 流提供直接操作字符流的接口，以避免這種轉換。對於文本建議使用字符流，而圖片、音視頻等應使用字節流。</p>\n<p><strong>（3）BIO、NIO、AIO 有什麼區別？</strong></p>\n<ol>\n<li><strong>BIO</strong>（Blocking I/O），同步阻塞 I/O 模式，數據的讀取寫入必須阻塞在一個線程內等待其完成。適用於活動連接數不高（&lt; 單機 1000）的情況，結合線程池一起使用。</li>\n<li><strong>NIO</strong>（Non-blocking I/O 或 New I/O），同步非阻塞的 I/O 模型，Java 1.4 中引入，位於 <code>java.nio</code> 包，提供 Channel、Selector 和 Buffer 等抽象，支持基於通道面向緩衝的 I/O 操作方法。適用於高負載、高並發的（網絡）應用。</li>\n<li><strong>AIO</strong>（Asynchronous I/O），異步非阻塞的 I/O 模型，Java 7 中引入。支持基於事件回調機制的操作方法。</li>\n</ol>\n<p>NIO 模型：</p>\n<p><img src=\"/2020/12/02/it/java/java-basic/Untitled%204.png\" alt></p>\n<ul>\n<li><p>NIO 服務端代碼</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MultiplexerNioServer</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Selector selector;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">boolean</span> stop = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 初始化多路复用器 绑定监听端口</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> port</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MultiplexerNioServer</span><span class=\"params\">(<span class=\"keyword\">int</span> port)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();<span class=\"comment\">//获得一个serverChannel</span></span><br><span class=\"line\">            selector = Selector.open();<span class=\"comment\">////创建选择器  获得一个多路复用器</span></span><br><span class=\"line\">            serverSocketChannel.configureBlocking(<span class=\"keyword\">false</span>);<span class=\"comment\">//设置为非阻塞模式 如果为 true，则此通道将被置于阻塞模式；如果为 false，则此通道将被置于非阻塞模式</span></span><br><span class=\"line\">            serverSocketChannel.socket().bind(<span class=\"keyword\">new</span> InetSocketAddress(port), <span class=\"number\">1024</span>);<span class=\"comment\">//绑定一个端口和等待队列长度</span></span><br><span class=\"line\">            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);<span class=\"comment\">//把selector注册到channel，关注链接事件</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            System.exit(<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">stop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.stop = <span class=\"keyword\">true</span>; <span class=\"comment\">// 优雅停机</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!stop) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">//无论是否有读写事件发生，selector每隔1s被唤醒一次。如果一定时间内没有事件，就需要做些其他的事情，就可以使用带超时的</span></span><br><span class=\"line\">                <span class=\"keyword\">int</span> client = selector.select(<span class=\"number\">1000</span>);</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"1:\"</span> + client);</span><br><span class=\"line\">                <span class=\"comment\">// 阻塞,只有当至少一个注册的事件发生的时候才会继续.</span></span><br><span class=\"line\">                <span class=\"comment\">// int client = selector.select(); 不设置超时时间为线程阻塞，但是IO上支持多个文件描述符就绪</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (client == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"2:\"</span> + client);</span><br><span class=\"line\">                Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class=\"line\">                Iterator&lt;SelectionKey&gt; it = selectionKeys.iterator();</span><br><span class=\"line\">                SelectionKey key = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (it.hasNext()) &#123;</span><br><span class=\"line\">                    key = it.next();</span><br><span class=\"line\">                    it.remove();</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        <span class=\"comment\">//处理事件</span></span><br><span class=\"line\">                        handle(key);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (key != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                            key.cancel();</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (key.channel() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                                key.channel().close();</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (selector != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// selector关闭后会自动释放里面管理的资源</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                selector.close();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handle</span><span class=\"params\">(SelectionKey key)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (key.isValid()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//连接事件</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (key.isAcceptable()) &#123;</span><br><span class=\"line\">                ServerSocketChannel ssc = (ServerSocketChannel) key.channel();</span><br><span class=\"line\">                <span class=\"comment\">// 通过ServerSocketChannel的accept创建SocketChannel实例</span></span><br><span class=\"line\">                <span class=\"comment\">// 完成该操作意味着完成TCP三次握手，TCP物理链路正式建立</span></span><br><span class=\"line\">                SocketChannel sc = ssc.accept();<span class=\"comment\">//3次握手</span></span><br><span class=\"line\">                sc.configureBlocking(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">                sc.register(selector, SelectionKey.OP_READ);<span class=\"comment\">//连接建立后关注读事件</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//读事件</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (key.isReadable()) &#123;</span><br><span class=\"line\">                SocketChannel socketChannel = (SocketChannel) key.channel();</span><br><span class=\"line\">                ByteBuffer readbuffer = ByteBuffer.allocate(<span class=\"number\">1024</span>);<span class=\"comment\">//写 0 1024  1024</span></span><br><span class=\"line\"><span class=\"comment\">//                ByteBuffer readbuffer = ByteBuffer.allocateDirect(1024); //申请直接内存，也就是堆外内存</span></span><br><span class=\"line\">                <span class=\"comment\">// 读取请求码流，返回读取到的字节数</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> readBytes = socketChannel.read(readbuffer);</span><br><span class=\"line\">                    <span class=\"comment\">// 读取到字节，对字节进行编解码</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (readBytes &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 将缓冲区当前的limit设置为position=0，用于后续对缓冲区的读取操作</span></span><br><span class=\"line\">                        readbuffer.flip();<span class=\"comment\">//读写模式反转</span></span><br><span class=\"line\">                        <span class=\"comment\">// 将缓冲区可读字节数组复制到新建的数组中</span></span><br><span class=\"line\">                        <span class=\"keyword\">byte</span>[] bytes = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[readbuffer.remaining()];</span><br><span class=\"line\">                        readbuffer.get(bytes);</span><br><span class=\"line\">                        String body = <span class=\"keyword\">new</span> String(bytes, StandardCharsets.UTF_8);</span><br><span class=\"line\">                        System.out.println(<span class=\"string\">\"input is:\"</span> + body);</span><br><span class=\"line\">                        res(socketChannel, body);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (readBytes &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 链路已经关闭 释放资源</span></span><br><span class=\"line\">                        key.cancel();</span><br><span class=\"line\">                        socketChannel.close();</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 没有读到字节忽略</span></span><br><span class=\"line\">                        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">res</span><span class=\"params\">(SocketChannel channel, String response)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (response != <span class=\"keyword\">null</span> &amp;&amp; response.length() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">byte</span>[] bytes = response.getBytes();</span><br><span class=\"line\">            ByteBuffer writeBuffer = ByteBuffer.allocate(bytes.length);</span><br><span class=\"line\">            writeBuffer.put(bytes);</span><br><span class=\"line\">            writeBuffer.flip();</span><br><span class=\"line\">            channel.write(writeBuffer);</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"res end\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>NIO 客戶端代碼</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NioClientHandler</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String host;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> port;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Selector selector;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> SocketChannel socketChannel;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">boolean</span> stop;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">NioClientHandler</span><span class=\"params\">(String host, <span class=\"keyword\">int</span> port)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.host = host;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.port = port;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 创建选择器</span></span><br><span class=\"line\">            selector = Selector.open();</span><br><span class=\"line\">            <span class=\"comment\">// 打开监听通道</span></span><br><span class=\"line\">            socketChannel = SocketChannel.open();</span><br><span class=\"line\">            <span class=\"comment\">// 如果为 true，则此通道将被置于阻塞模式；如果为 false，则此通道将被置于非阻塞模式</span></span><br><span class=\"line\">            socketChannel.configureBlocking(<span class=\"keyword\">false</span>); <span class=\"comment\">// 开启非阻塞模式</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            System.exit(<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            doConnect();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            System.exit(<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!stop) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> wait = selector.select(<span class=\"number\">1000</span>);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (wait == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class=\"line\">                Iterator&lt;SelectionKey&gt; it = selectionKeys.iterator();</span><br><span class=\"line\">                SelectionKey key = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (it.hasNext()) &#123;</span><br><span class=\"line\">                    key = it.next();</span><br><span class=\"line\">                    it.remove();</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        handle(key);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (key != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                            key.cancel();</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (key.channel() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                                key.channel().close();</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">                System.exit(<span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (selector != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                selector.close();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">doConnect</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (socketChannel.connect(<span class=\"keyword\">new</span> InetSocketAddress(host, port))) &#123;</span><br><span class=\"line\">            socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class=\"line\">            doWrite(socketChannel);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            socketChannel.register(selector, SelectionKey.OP_CONNECT);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">handle</span><span class=\"params\">(SelectionKey key)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (key.isValid()) &#123;</span><br><span class=\"line\">            SocketChannel sc = (SocketChannel) key.channel();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (key.isConnectable()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (sc.finishConnect()) &#123;</span><br><span class=\"line\">                    sc.register(selector, SelectionKey.OP_READ);</span><br><span class=\"line\">                    doWrite(sc);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    System.exit(<span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (key.isReadable()) &#123;</span><br><span class=\"line\">                ByteBuffer readBuffer = ByteBuffer.allocate(<span class=\"number\">1024</span>);</span><br><span class=\"line\">                <span class=\"keyword\">int</span> readBytes = sc.read(readBuffer);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (readBytes &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    readBuffer.flip();</span><br><span class=\"line\">                    <span class=\"keyword\">byte</span>[] bytes = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[readBuffer.remaining()];</span><br><span class=\"line\">                    readBuffer.get(bytes);</span><br><span class=\"line\">                    String body = <span class=\"keyword\">new</span> String(bytes, StandardCharsets.UTF_8);</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">\"res\"</span> + body);</span><br><span class=\"line\">                    <span class=\"keyword\">this</span>.stop = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (readBytes &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    key.cancel();</span><br><span class=\"line\">                    sc.close();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">doWrite</span><span class=\"params\">(SocketChannel sc)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 将消息编码为字节数组</span></span><br><span class=\"line\">        <span class=\"keyword\">byte</span>[] request = <span class=\"string\">\"Hello\"</span>.getBytes();</span><br><span class=\"line\">        <span class=\"comment\">// 根据数组容量创建ByteBuffer</span></span><br><span class=\"line\">        ByteBuffer writeBuffer = ByteBuffer.allocate(request.length);</span><br><span class=\"line\">        <span class=\"comment\">// 将字节数组复制到缓冲区</span></span><br><span class=\"line\">        writeBuffer.put(request);</span><br><span class=\"line\">        <span class=\"comment\">// flip读写切换操作</span></span><br><span class=\"line\">        writeBuffer.flip();</span><br><span class=\"line\">        sc.write(writeBuffer);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!writeBuffer.hasRemaining()) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"写入完成\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h2 id=\"Java-項目管理和構建\"><a href=\"#Java-項目管理和構建\" class=\"headerlink\" title=\"Java 項目管理和構建\"></a>Java 項目管理和構建</h2><h3 id=\"Maven-项目\"><a href=\"#Maven-项目\" class=\"headerlink\" title=\"Maven 项目\"></a>Maven 项目</h3><p><strong>（1）安装</strong></p>\n<p>從 <a href=\"https://maven.apache.org/download.cgi\" target=\"_blank\" rel=\"noopener\">Maven 官網</a>下載 maven 包，解壓並設置環境變量。還可以直接使用 IDEA 的 Maven 插件。</p>\n<p><strong>（2）初始化一個 Maven 項目</strong></p>\n<p>使用以下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">mvn -B archetype:generate -DgroupId=com.mycompany.app -DartifactId=my-app -DarchetypeArtifactId=maven-archetype-quickstart -DarchetypeVersion=1.4</span><br></pre></td></tr></table></figure>\n\n<p>或者用 IDEA 直接新建一個 Maven 項目，其結構如下：</p>\n<p><img src=\"/2020/12/02/it/java/java-basic/20201114_101407.png\" alt></p>\n<p>其中 pom.xml 的內容如下：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">project</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://maven.apache.org/POM/4.0.0\"</span></span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">modelVersion</span>&gt;</span>4.0.0<span class=\"tag\">&lt;/<span class=\"name\">modelVersion</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.example<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>testmaven<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.0-SNAPSHOT<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--  添加以下屬性，解決編譯報錯  --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">properties</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class=\"tag\">&lt;/<span class=\"name\">project.build.sourceEncoding</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">maven.compiler.encoding</span>&gt;</span>UTF-8<span class=\"tag\">&lt;/<span class=\"name\">maven.compiler.encoding</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">java.version</span>&gt;</span>15<span class=\"tag\">&lt;/<span class=\"name\">java.version</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">maven.compiler.source</span>&gt;</span>15<span class=\"tag\">&lt;/<span class=\"name\">maven.compiler.source</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">maven.compiler.target</span>&gt;</span>15<span class=\"tag\">&lt;/<span class=\"name\">maven.compiler.target</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">properties</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 新增依賴在下方 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.openjdk.jol<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>jol-core<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>0.14<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">project</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>為什麼叫 Maven？</p>\n<p>  Maven 來源於意第緒語，爲「行家」的意思。最初是為了簡化 Jakarta Turbine 項目中的構建過程而建立。Maven 使用項目對象模型（POM）和一組插件來構件項目。</p>\n</li>\n<li><p>POM 又是指什麼？</p>\n<p>  POM（project object model）項目對象模型，maven 使用 <code>pom.xml</code> 定義了整個項目的構建、報告和文檔。</p>\n</li>\n</ul>\n<p><strong>（3）編譯測試打包</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 清理 target 中的文件</span></span><br><span class=\"line\">mvn clean</span><br><span class=\"line\"><span class=\"comment\"># 編譯 java 文件成 class 文件，置於 target/classes 文件夾中</span></span><br><span class=\"line\">mvn compile</span><br><span class=\"line\"><span class=\"comment\"># 進行單元測試</span></span><br><span class=\"line\">mvn <span class=\"built_in\">test</span></span><br><span class=\"line\"><span class=\"comment\"># 打包成 jar 文件，置於 target 文件夾中</span></span><br><span class=\"line\">mvn package</span><br><span class=\"line\"><span class=\"comment\"># 安裝 jar 包到本地存儲庫（$&#123;user.home&#125;/.m2/repository）</span></span><br><span class=\"line\">mvn install</span><br><span class=\"line\"><span class=\"comment\"># 生成自己的 maven 站點</span></span><br><span class=\"line\">mvn site</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>SNAPSHOT 是什麼？</p>\n<p>  snapshot 簡要的意思，在版本號之後添加 <code>-SNAPSHOT</code> 是說明該版本仍處於開發階段，不是最終的發行版本。以 <code>x.y-SNAPSHOT</code> 版本為例，發行時會去除 <code>-SNAPSHOT</code>  後綴，然後將最新的開發版本升爲<code>x.(y+1)-SNAPSHOT</code> 。</p>\n</li>\n<li><p>使用 mvn compile 生成的 jar 包，其內容是怎樣的？</p>\n<p>  除了 class 文件外，還有 <code>META-INF</code> 文件夾，裏面存放一些清單文件和pom 文件。存放到項目資源文件夾（<code>main/resources</code> ）的文件也會被打包到<code>META-INF</code> 文件夾中，代碼中可通過<code>getClass().getResourceAsStream( &quot;/application.properties&quot; )</code> 調用。</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ jar tf target/testmaven-1.0-SNAPSHOT.jar </span><br><span class=\"line\">META-INF/</span><br><span class=\"line\">META-INF/MANIFEST.MF</span><br><span class=\"line\">B.class</span><br><span class=\"line\">MemoryLayoutTest.class</span><br><span class=\"line\">A.class</span><br><span class=\"line\">C.class</span><br><span class=\"line\">META-INF/maven/</span><br><span class=\"line\">META-INF/maven/org.example/</span><br><span class=\"line\">META-INF/maven/org.example/testmaven/</span><br><span class=\"line\">META-INF/maven/org.example/testmaven/pom.xml</span><br><span class=\"line\">META-INF/maven/org.example/testmaven/pom.properties</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"Gradle-项目\"><a href=\"#Gradle-项目\" class=\"headerlink\" title=\"Gradle 项目\"></a>Gradle 项目</h3><p><strong>（1）安裝</strong></p>\n<p>可從 <a href=\"https://www.gradle.org/downloads\" target=\"_blank\" rel=\"noopener\">gradle 官網</a>下載解壓並配置環境變量的方式安裝。Mac 用戶還可以使用 <code>brew install gradle</code> 的方式安裝。或者直接使用 IDEA 項目中的 <code>gradle-wrapper</code> ，此時對應的 <code>gradle</code> 命令變爲 <code>gradlew</code>。</p>\n<p><strong>（2）gradle 命令能做什麼？</strong></p>\n<p>gradle 命令能構建項目， 查看項目依賴、子項目和項目配置等等。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ gradle tasks</span><br><span class=\"line\"></span><br><span class=\"line\">:tasks</span><br><span class=\"line\"></span><br><span class=\"line\">== All tasks runnable from root project</span><br><span class=\"line\"></span><br><span class=\"line\">== Build Setup tasks</span><br><span class=\"line\">setupBuild - Initializes a new Gradle build. [incubating]</span><br><span class=\"line\"></span><br><span class=\"line\">== Help tasks</span><br><span class=\"line\">dependencies - Displays all dependencies declared <span class=\"keyword\">in</span> root project <span class=\"string\">'gs-gradle'</span>.</span><br><span class=\"line\">dependencyInsight - Displays the insight into a specific dependency <span class=\"keyword\">in</span> root project <span class=\"string\">'gs-gradle'</span>.</span><br><span class=\"line\"><span class=\"built_in\">help</span> - Displays a <span class=\"built_in\">help</span> message</span><br><span class=\"line\">projects - Displays the sub-projects of root project <span class=\"string\">'gs-gradle'</span>.</span><br><span class=\"line\">properties - Displays the properties of root project <span class=\"string\">'gs-gradle'</span>.</span><br><span class=\"line\">tasks - Displays the tasks runnable from root project <span class=\"string\">'gs-gradle'</span>.</span><br><span class=\"line\"></span><br><span class=\"line\">To see all tasks and more detail, run with --all.</span><br><span class=\"line\"></span><br><span class=\"line\">BUILD SUCCESSFUL</span><br><span class=\"line\"></span><br><span class=\"line\">Total time: 3.077 secs</span><br></pre></td></tr></table></figure>\n\n<p><strong>（3）初始化一個 Gradle 項目</strong></p>\n<p>在項目文件夾中新建一個名爲 <code>build.gradle</code> 的文件，其內容如下：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"code\"><pre><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'java'</span></span><br></pre></td></tr></table></figure>\n\n<p>隨後新建一個名爲 <code>settings.gradle</code> 的文件，其內容可暫時爲空。</p>\n<p>在 IDEA 中打開此項目，隨後 IDEA 會自動配置加入 <code>gradle-wrapper</code> ，其過程等價於執行以下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">gradle wrapper --gradle-version 6.5</span><br></pre></td></tr></table></figure>\n\n<p><strong>（4）編譯打包</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 編譯項目，會默認在 build/classes 中生成類文件，在 build/libs 中生成 jar 包</span></span><br><span class=\"line\">gradle build</span><br><span class=\"line\"><span class=\"comment\"># 或使用 gradle wrapper</span></span><br><span class=\"line\">./gradlew build</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 清理生成的文件</span></span><br><span class=\"line\">gradle clean</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 生成 jar 文件</span></span><br><span class=\"line\">gradle jar</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 運行生成的 jar 文件</span></span><br><span class=\"line\">gradle run</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 進行單元測試</span></span><br><span class=\"line\">gradle <span class=\"built_in\">test</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>（5）<code>build.gradle</code> 中可配置什麼？</strong></p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 配置插件，插件提供語法定義</span></span><br><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'java'</span></span><br><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'application'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 配置入口類</span></span><br><span class=\"line\">mainClassName = <span class=\"string\">'hello.HelloWorld'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 配置依賴倉庫</span></span><br><span class=\"line\">repositories &#123;</span><br><span class=\"line\">    mavenCentral()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 配置生成的 jar 文件的入口類</span></span><br><span class=\"line\">jar &#123;</span><br><span class=\"line\">    manifest &#123;</span><br><span class=\"line\">        attributes <span class=\"string\">'Main-Class'</span>: mainClassName</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 配置 JDK 兼容性</span></span><br><span class=\"line\">sourceCompatibility = <span class=\"number\">1.8</span></span><br><span class=\"line\">targetCompatibility = <span class=\"number\">1.8</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 配置依賴</span></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    compile <span class=\"string\">\"joda-time:joda-time:2.2\"</span></span><br><span class=\"line\">    testCompile <span class=\"string\">\"junit:junit:4.12\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如需將所有依賴 jar 打進同一個 jar 包，可使用 <a href=\"https://github.com/johnrengelman/shadow\" target=\"_blank\" rel=\"noopener\">shadow 插件</a>或使用 <a href=\"https://spring.io/quickstart\" target=\"_blank\" rel=\"noopener\">spring boot 插件</a>。</p>\n","site":{"data":{}},"excerpt":"<p>Java 自 95 年誕生至今，已有 25 年的歷史。它是一種半編譯的語言，先將代碼編譯成字節碼，然後在 JVM 中解釋執行。</p>\n<ul>\n<li>它是一種面向對象的語言，封裝、繼承和多態它都有，類可以多實現但不支持多繼承，而接口可以多繼承。</li>\n<li>它支持 8 種基本數據類型，同時還提供了其包裝類型，另外還提供了 BigDecimal 精確處理浮點數、提供了 BigInteger 處理大整數。</li>\n<li>它的方法只有值傳遞，傳遞對象時它是淺拷貝而非深拷貝。類的方法可以被子類重寫，同個類可以有多個同名的重載方法。</li>\n<li>它支持泛型，一種將類型參數化的技術。不過，也有人稱之爲「僞泛型」，因爲類型會在編譯時被擦除。</li>\n<li>它支持反射，一種在運行時操作任意對象的方法和屬性的技術，這在框架應用中很常見。</li>\n<li>它提供了豐富的集合類、迭代器及工具類。</li>\n<li>它支持多線程，一種在程序進程中同時執行多個任務的技術，同時還有豐富的鎖類型，所有對象的頭信息裏都有一個鎖標識。</li>\n<li>它支持異常處理，Exception 分編譯時異常和運行時異常，編譯時異常可以被編譯器檢查到，而運行時異常只能在程序運行時發生。</li>\n<li>它有豐富的 I/O API，派生自 4 個抽象類，InputStream、OutputStream、Reader、Writer，字符流的出現是爲了減少 JVM 進行字符編碼解碼的資源損耗和編解碼錯誤。</li>\n<li>另外，目前有兩大項目管理工具，Maven 和 Gradle。</li>\n</ul>","more":"<h2 id=\"Java-入門（基礎概念與常識）\"><a href=\"#Java-入門（基礎概念與常識）\" class=\"headerlink\" title=\"Java 入門（基礎概念與常識）\"></a>Java 入門（基礎概念與常識）</h2><h3 id=\"歷史\"><a href=\"#歷史\" class=\"headerlink\" title=\"歷史\"></a>歷史</h3><p>Java 編程語言本名爲 oak（橡樹），因爲商標被註冊了，所以更名爲 Java，而 Java 是印尼的一座島嶼，盛產咖啡豆，有一種咖啡就是以該島命名，Java 編程語言之名因之。使用十六進制編輯器打開 class 文件時會發現前 32 位顯示爲 <code>CA FE BA BE</code> ，即 cafe babe （咖啡寶貝）。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexdump Test.class</span><br><span class=\"line\"><span class=\"number\">0000000</span> ca fe ba be <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">3</span>b <span class=\"number\">00</span> <span class=\"number\">51</span> <span class=\"number\">0</span>a <span class=\"number\">00</span> <span class=\"number\">02</span> <span class=\"number\">00</span> <span class=\"number\">03</span> <span class=\"number\">07</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>1994 年完成 1.0 版本。</li>\n<li>1995 年首次對外發佈，Java 語言誕生。</li>\n<li>1996 年JDK 1.0 誕生。</li>\n<li>2004 年 SUN 公司發佈 Java SE 5。</li>\n<li>2005 年 SUN 公司發佈 Java SE 6。</li>\n<li>2006 年 SUN 公司推出 OpenJDK 計劃。</li>\n<li>2014年 Oracle 公司發佈 Java SE 8。</li>\n<li>2017年 Oracle公司發佈 Java SE 9。</li>\n<li>2020 年 Oracle 公司發佈 Java SE 15。</li>\n</ul>\n<h3 id=\"安裝與卸載JDK\"><a href=\"#安裝與卸載JDK\" class=\"headerlink\" title=\"安裝與卸載JDK\"></a>安裝與卸載JDK</h3><p>在 Mac 環境下，從 <a href=\"https://www.oracle.com/tw/java/technologies/javase-downloads.html\" target=\"_blank\" rel=\"noopener\">Oracle JavaSE 下載地址</a> 下載並安裝。安裝完成後執行 <code>java -version</code>  可查看安裝的版本，以確認安裝成功。安裝後的Java Home 位置爲 <code>/Library/Java/JavaVirtualMachines/jdk-9.0.1.jdk/Contents/Home</code> 。如需卸載該 jdk，可安裝以下 shell 命令，先移除插件後根據查詢到的 jdk 版本移除整個 jdk 文件夾即可。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo rm -fr /Library/Internet\\ Plug-Ins/JavaAppletPlugin.plugin</span><br><span class=\"line\">sudo rm -fr /Library/PreferencesPanes/JavaControlPanel.prefpane</span><br><span class=\"line\"></span><br><span class=\"line\">ls /Library/Java/JavaVirtualMachines/</span><br><span class=\"line\">输出：jdk-9.0.1.jdk</span><br><span class=\"line\"></span><br><span class=\"line\">sudo rm -rf /Library/Java/JavaVirtualMachines/jdk-9.0.1.jdk</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Hello-World\"><a href=\"#Hello-World\" class=\"headerlink\" title=\"Hello World\"></a>Hello World</h3><p>運行以下代碼，將輸出 <code>Hello World</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> hello;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Hello</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Hello World\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Java-語言的特點\"><a href=\"#Java-語言的特點\" class=\"headerlink\" title=\"Java 語言的特點\"></a>Java 語言的特點</h3><ol>\n<li>面向對象（封裝，繼承，多態）</li>\n<li>平台無關性（ Java 虛擬機實現平台無關性）</li>\n<li>支持多線程</li>\n<li>編譯與解釋並存</li>\n</ol>\n<p>編譯：生成字節碼(.class文件)，javac 指令。<br>解釋：解釋字節碼成機器碼，java 指令。</p>\n<h3 id=\"JVM、JDK-和-JRE\"><a href=\"#JVM、JDK-和-JRE\" class=\"headerlink\" title=\"JVM、JDK 和  JRE\"></a>JVM、JDK 和  JRE</h3><ol>\n<li>JVM，Java Virtual Machine 的縮寫，即 Java 虛擬機，是運行 Java 字節碼的虛擬機（包含解釋器 java），它包含在 JRE 中。不同的操作系統有特定的 JVM 實現，以便 Java 字節碼可以跨平台。</li>\n<li>JDK，Java Development Kit 的縮寫，即 Java 開發工具集，包含了 JRE 、編譯器（javac）和其他工具（javadoc 和 jdb 等）。</li>\n<li>JRE，Java Runtime 的縮寫，即 Java 運行時，包含了 JVM、必要的類庫、java 命令和其他基礎構件。</li>\n</ol>\n<h3 id=\"Java-與-C-對比\"><a href=\"#Java-與-C-對比\" class=\"headerlink\" title=\"Java 與 C++ 對比\"></a>Java 與 C++ 對比</h3><ol>\n<li>皆支持面向對象編程（封裝、繼承和多態）。</li>\n<li>Java 不提供指針來直接訪問內存；C++ 提供。</li>\n<li>Java 的類不支持多繼承，但接口可以；C++ 的類可以多繼承。</li>\n<li>Java 有內存垃圾自動回收機制（GC），不需要手動釋放無用內存；C++ 沒有。</li>\n<li>Java 字符串和字符數組沒有結束符的概念；C/C++ 中字符串和字符數組最後會有一個額外的字符<code>\\0</code> 來表示結束。</li>\n</ol>\n<h2 id=\"Java-語法\"><a href=\"#Java-語法\" class=\"headerlink\" title=\"Java 語法\"></a>Java 語法</h2><h3 id=\"基本類型及其大小\"><a href=\"#基本類型及其大小\" class=\"headerlink\" title=\"基本類型及其大小\"></a>基本類型及其大小</h3><p>Java 共 8 種數據類型（不包括 void），具體如下表：</p>\n<p><img src=\"/2020/12/02/it/java/java-basic/20201202_24328.png\" alt></p>\n<p>boolean 值的大小取決於 JVM 實現，Java 虛擬機規範（第8版）規定：單個 boolean佔 4 個字節，而 boolean 數組 1 個字節。</p>\n<p>char 值是一個 16 位的 Unicode 字符，最小值是 ‘\\u0000’ ，最大值是 ‘\\uffff’，即 0～65535，每個數字對應一個字符。</p>\n<ul>\n<li><p>代碼</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span> a = <span class=\"string\">'中'</span>;</span><br><span class=\"line\">System.out.println((<span class=\"keyword\">int</span>)a);</span><br><span class=\"line\"><span class=\"comment\">// 輸出 20013</span></span><br><span class=\"line\">System.out.println(Integer.toHexString(a));</span><br><span class=\"line\"><span class=\"comment\">// 輸出 4e2d</span></span><br><span class=\"line\">System.out.println(<span class=\"string\">'\\u4e2d'</span>);</span><br><span class=\"line\"><span class=\"comment\">// 輸出 中</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>byte、short、int、long 類型，採用二進制補碼存儲數據，以便利減法運算。</p>\n<ul>\n<li>二進制補碼<ul>\n<li>過程：正數的補碼是其自身；負數的補碼是除符號位外所有二進制位做反碼後加 1 的結果。</li>\n<li>原理：假定 X、Y 是两个占1个字节的数。X-Y 等价于 X+(-Y) ，而 -Y 可以看作 0-Y，假定是 0 不足以被减，向上借 1 变为 1 0000 0000，而  1 0000 0000 又等價於 1111 1111 + 1，於是 -Y = 1111 1111 - Y + 1，即 Y 的反碼再 + 1。 見 <a href=\"https://www.ruanyifeng.com/blog/2009/08/twos_complement.html\" target=\"_blank\" rel=\"noopener\">https://www.ruanyifeng.com/blog/2009/08/twos_complement.htm</a>l</li>\n</ul>\n</li>\n</ul>\n<p>long 類型的數據後面一定要加上 L，否則會被認為是整型。</p>\n<p>char 類型值使用單引號括起來，String 使用雙引號。</p>\n<p>Java 有<strong>自動拆裝箱機制</strong>，裝箱即把基本類型使用其包裝類型包裝起來，拆箱即把包裝類型拆成基本類型。</p>\n<h3 id=\"包裝類型及常量池技術\"><a href=\"#包裝類型及常量池技術\" class=\"headerlink\" title=\"包裝類型及常量池技術\"></a>包裝類型及常量池技術</h3><ol>\n<li>Byte、Short、Integer 和 Long 分別默認創建了數值 [-128, 127] 的相應類型的緩存數據。</li>\n<li>Character 創建了數值在 [0, 127] 的緩存數據。</li>\n<li>Boolean 直接返回 True 和 False。</li>\n<li>Float 和 Double 沒有實現常量池技術。</li>\n</ol>\n<p>使用常量池技術意味著在緩存範圍內的包裝類型對象是相等的，除非 new 一個對象。使用包裝器的 valueOf 方法默認會先去緩存中取對象，取不到才會 new 一個。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Integer i1 = <span class=\"number\">33</span>;</span><br><span class=\"line\">Integer i2 = <span class=\"number\">33</span>;</span><br><span class=\"line\">System.out.println(i1 == i2);<span class=\"comment\">// 输出 true</span></span><br><span class=\"line\">Integer i11 = <span class=\"number\">333</span>;</span><br><span class=\"line\">Integer i22 = <span class=\"number\">333</span>;</span><br><span class=\"line\">System.out.println(i11 == i22);<span class=\"comment\">// 输出 false</span></span><br><span class=\"line\">Double i3 = <span class=\"number\">1.2</span>;</span><br><span class=\"line\">Double i4 = <span class=\"number\">1.2</span>;</span><br><span class=\"line\">System.out.println(i3 == i4);<span class=\"comment\">// 输出 false</span></span><br></pre></td></tr></table></figure>\n\n<p>《阿里巴巴Java開發手冊》規定：</p>\n<ul>\n<li>【強制】<strong>所有的 POJO 類屬性必須使用包裝數據類型</strong>。</li>\n<li>【強制】RPC 方法的返回值和參數必須使用包裝數據類型。</li>\n<li>【推薦】所有的局部變量使用基本數據類型。</li>\n</ul>\n<h3 id=\"BigDecimal\"><a href=\"#BigDecimal\" class=\"headerlink\" title=\"BigDecimal\"></a>BigDecimal</h3><p><strong>（1）使用 BigDecimal 進行浮點數比較和精度取捨</strong></p>\n<p><strong>（2）使用 BigDecimal(String) 或 BigDecimal.valueOf(double) 構造對象</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">float</span> a = <span class=\"number\">1.0f</span> - <span class=\"number\">0.9f</span>;</span><br><span class=\"line\"><span class=\"keyword\">float</span> b = <span class=\"number\">0.9f</span> - <span class=\"number\">0.8f</span>;</span><br><span class=\"line\">System.out.println(a);</span><br><span class=\"line\">System.out.println(b);</span><br><span class=\"line\">System.out.println(a == b); <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\">BigDecimal a = <span class=\"keyword\">new</span> BigDecimal(<span class=\"string\">\"1.0\"</span>);</span><br><span class=\"line\">BigDecimal b = <span class=\"keyword\">new</span> BigDecimal(<span class=\"string\">\"0.9\"</span>);</span><br><span class=\"line\">BigDecimal c = <span class=\"keyword\">new</span> BigDecimal(<span class=\"string\">\"0.8\"</span>);</span><br><span class=\"line\">System.out.println(a.subtract(b));</span><br><span class=\"line\">System.out.println(b.subtract(c));</span><br><span class=\"line\">System.out.println(a.subtract(b).equals(b.subtract(c))); <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\">BigDecimal a = <span class=\"keyword\">new</span> BigDecimal(<span class=\"string\">\"1.1252312\"</span>);</span><br><span class=\"line\"><span class=\"comment\">// 取小數點後 2 位，四捨五入</span></span><br><span class=\"line\">BigDecimal scale = a.setScale(<span class=\"number\">2</span>, RoundingMode.HALF_UP);</span><br><span class=\"line\">System.out.println(scale.toString()); <span class=\"comment\">// 1.13</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"對象及其大小\"><a href=\"#對象及其大小\" class=\"headerlink\" title=\"對象及其大小\"></a>對象及其大小</h3><p>基本類型的封裝類型是對象，Java 中的對象由以下部分組成：</p>\n<ol>\n<li>對象頭（object header）：由 mark word 和 class pointer 組成。mark word 存儲了對象的 hashcode、GC信息和鎖信息；class pointer 存儲了指向類對象的指針。32 位的 JVM 上對象頭佔 8 個字節，mark word 和 class pointer 各佔一半。64 位的 JVM 默認開啟了壓縮指針選項（-XX+UseCompressedOops）後上對象頭佔用 12 個字節，mark word 佔用 8 個字節，class pointer 佔用 4 個字節。</li>\n<li>實例數據（instance data）：</li>\n<li>對齊填充（padding）</li>\n</ol>\n<p>可使用 <code>org.openjdk.jol</code> 工具查看一個對象佔用的字節大小，</p>\n<ul>\n<li><p>如下：</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">    System.out.println(VM.current().details());</span><br><span class=\"line\">    System.out.println(ClassLayout.parseClass(Object.class).toPrintable());</span><br><span class=\"line\">    System.out.println(ClassLayout.parseInstance(Integer.valueOf(<span class=\"number\">1</span>)).toPrintable());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>  輸出結果：</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Running 64-bit HotSpot VM.</span></span><br><span class=\"line\"><span class=\"comment\"># Using compressed oop with 3-bit shift.</span></span><br><span class=\"line\"><span class=\"comment\"># Using compressed klass with 3-bit shift.</span></span><br><span class=\"line\"><span class=\"comment\"># WARNING | Compressed references base/shifts are guessed by the experiment!</span></span><br><span class=\"line\"><span class=\"comment\"># WARNING | Therefore, computed addresses are just guesses, and ARE NOT RELIABLE.</span></span><br><span class=\"line\"><span class=\"comment\"># WARNING | Make sure to attach Serviceability Agent to get the reliable addresses.</span></span><br><span class=\"line\"><span class=\"comment\"># Objects are 8 bytes aligned.</span></span><br><span class=\"line\"><span class=\"comment\"># Field sizes by type: 4, 1, 1, 2, 2, 4, 4, 8, 8 [bytes]</span></span><br><span class=\"line\"><span class=\"comment\"># Array element sizes: 4, 1, 1, 2, 2, 4, 4, 8, 8 [bytes]</span></span><br><span class=\"line\"></span><br><span class=\"line\">java.lang.Object object internals:</span><br><span class=\"line\"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class=\"line\">      0    12        (object header)                           N/A</span><br><span class=\"line\">     12     4        (loss due to the next object alignment)</span><br><span class=\"line\">Instance size: 16 bytes</span><br><span class=\"line\">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br><span class=\"line\"></span><br><span class=\"line\">java.lang.Integer object internals:</span><br><span class=\"line\"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class=\"line\">      0     4        (object header)                           01 c9 01 4e (00000001 11001001 00000001 01001110) (1308739841)</span><br><span class=\"line\">      4     4        (object header)                           3d 00 00 00 (00111101 00000000 00000000 00000000) (61)</span><br><span class=\"line\">      8     4        (object header)                           48 71 00 00 (01001000 01110001 00000000 00000000) (29000)</span><br><span class=\"line\">     12     4    int Integer.value                             1</span><br><span class=\"line\">Instance size: 16 bytes</span><br><span class=\"line\">Space losses: 0 bytes internal + 0 bytes external = 0 bytes total</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>結論：在 64 位開啟指針壓縮的環境下，Object 對象佔用 16 個字節，Integer 對象也佔用 16 個字節。</p>\n<h3 id=\"String、StringBuffer-和-String-Builder-的區別\"><a href=\"#String、StringBuffer-和-String-Builder-的區別\" class=\"headerlink\" title=\"String、StringBuffer 和 String Builder 的區別\"></a>String、StringBuffer 和 String Builder 的區別</h3><p>String 類使用 final 修飾字符數組或字節數組來保存字符串，所以 String 對象是不可變的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">String</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// Java 9 之前</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">char</span>[] value;</span><br><span class=\"line\">\t<span class=\"comment\">// Java 9 之後</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">byte</span>[] value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>StringBuilder  和 StringBuffer 都繼承自 AbstractStringBuilder，AbstractStringBuilder 使用字符數組來保存字符串，但沒有使用 final 關鍵字修飾，所以這兩者是可變的。</p>\n<p>下面從不同角度比較下此三者：</p>\n<ol>\n<li>線程安全性：String 對象不可變，線程安全；StringBuffer 對方法加了同步鎖，線程安全；StringBuilder 對方法沒有加同步鎖，線程不安全。</li>\n<li>性能：每次對 String 類型進行改變時會生成一個新的 String 對象，然後將指針指向新的 String 對象。StringBuffer 和 StringBuilder 每次對自身進行操作，不生成新對象。同等情況下， StringBuilder 比 StringBuffer 能提升 10%～15% 性能，但要冒線程不安全的風險。</li>\n</ol>\n<h3 id=\"注釋\"><a href=\"#注釋\" class=\"headerlink\" title=\"注釋\"></a>注釋</h3><p>代碼即注釋。先讓標識符見名知意，然後再考慮增加注釋。</p>\n<h3 id=\"標識符和關鍵字的區別\"><a href=\"#標識符和關鍵字的區別\" class=\"headerlink\" title=\"標識符和關鍵字的區別\"></a>標識符和關鍵字的區別</h3><p>標識符是程序、類、變量、方法等取的名字，而關鍵字是具備特殊含義的標識符。常見的關鍵字有：</p>\n<ol>\n<li>訪問控制：private、protected、public</li>\n<li>類、方法和變量修飾符：abstract、class、extends、final、implements、interface、native、new、static、strictfp、synchronized、transient、volatile</li>\n<li>程序控制：break、continue、return、do、while、if、else、for、instanceof、switch、case、default</li>\n<li>錯誤處理：try、catch、throw、throws、finally</li>\n<li>包相關：import、package</li>\n<li>基本類型：boolean、byte、char、double、float、int、short、null、true、false</li>\n<li>變量引用：super、this、void</li>\n<li>保留字：goto、const</li>\n</ol>\n<h3 id=\"自增自減運算符\"><a href=\"#自增自減運算符\" class=\"headerlink\" title=\"自增自減運算符\"></a>自增自減運算符</h3><p>符號在前先加減再賦值，符號在後先賦值後加減。假定 <code>a = 1; b = a++</code> 最後 a 值爲 2，b 值爲 1。</p>\n<h3 id=\"和-equals-的區別\"><a href=\"#和-equals-的區別\" class=\"headerlink\" title=\"== 和 equals 的區別\"></a>== 和 equals 的區別</h3><ol>\n<li>基本數據類型 == 比較的是值，引用數據類型 == 比較的是內存地址。</li>\n<li>equals 是 Object 類的方法，如無重寫該方法，則默認使用 == 比較對象，即比較內存地址；String 類重寫了 equals 方法使其比較得是值。</li>\n<li>整型包裝類都應使用 equals 比較大小。</li>\n<li>浮點數之間的等值判斷，基本數據類型不能用==來比較，包裝數據類型不能用 equals 來判斷。</li>\n</ol>\n<ul>\n<li><p>重寫 equals 方法通常同時需要重寫 hashcode 方法，爲什麼？</p>\n<p>  hashcode 是 Object 類的一個本地方法，其實現時將對象的內存地址轉爲一個 int 值，不同的對象的 hashcode 可能相同。 HashSet 集合進行元素重複校驗時先比較 hashcode ，當 hashcode 一樣時再調用 equals，提高了校驗效率。因此，如果只重寫 equals 方法而不重寫 hashcode 方法，會出現 equals 返回 true，而 hashcode 不等的情況，這樣如果要求 HashSet 去重就會失敗。</p>\n<p>  HashSet 基於 HashMap 實現，HashMap 內部有一哈希表，裏面使用 hashcode 進行散列存儲。</p>\n</li>\n</ul>\n<h3 id=\"序列化時如果有些字段不想序列化，怎麼辦？\"><a href=\"#序列化時如果有些字段不想序列化，怎麼辦？\" class=\"headerlink\" title=\"序列化時如果有些字段不想序列化，怎麼辦？\"></a>序列化時如果有些字段不想序列化，怎麼辦？</h3><p>使用 transient 關鍵字修飾不想序列化的字段。</p>\n<h3 id=\"continue、break-和-return-的區別\"><a href=\"#continue、break-和-return-的區別\" class=\"headerlink\" title=\"continue、break 和 return 的區別\"></a>continue、break 和 return 的區別</h3><ol>\n<li>continue：跳出當前這一次循環，繼續下一次循環。</li>\n<li>break：跳出整個循環體，繼續執行循環外的語句。</li>\n<li>return：跳出所在的方法，結束方法，可以帶一個返回值。</li>\n</ol>\n<h3 id=\"泛型、類型擦除和通配符\"><a href=\"#泛型、類型擦除和通配符\" class=\"headerlink\" title=\"泛型、類型擦除和通配符\"></a>泛型、類型擦除和通配符</h3><p><strong>泛型的本質是將類型參數化。</strong>Java 的泛型（generics）是 JDK 5 中引入的新特性，還提供了編譯時類型安全檢測機制來檢測非法的類型。但是 Java 的泛型在編譯期間會將泛型信息擦除，即類型擦除，因此也被稱爲<strong>僞泛型</strong>。下面的例子展示了如何在運行期加入非法類型。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">list.add(<span class=\"number\">12</span>);</span><br><span class=\"line\"><span class=\"comment\">//這裡直接添加會報錯</span></span><br><span class=\"line\"><span class=\"comment\">// list.add(\"a\");</span></span><br><span class=\"line\">Class&lt;? extends List&gt; clazz = list.getClass();</span><br><span class=\"line\">Method add = clazz.getDeclaredMethod(<span class=\"string\">\"add\"</span>, Object.class);</span><br><span class=\"line\"><span class=\"comment\">//但是通過反射添加，是可以的</span></span><br><span class=\"line\">add.invoke(list, <span class=\"string\">\"kl\"</span>);</span><br><span class=\"line\">System.out.println(list);</span><br></pre></td></tr></table></figure>\n\n<p>泛型分泛型接口、泛型類和泛型方法。泛型類的具體類型通過實例化時傳入，泛型方法的具體類型通過方法調用時傳入的參數確定。</p>\n<p>泛型通配符約定：</p>\n<ol>\n<li>？ 表示不確定的 Java 類型，用於泛型方法</li>\n<li>T（Type）表示確定的一個 Java 類型</li>\n<li>K V（Key Value）分別表示映射中的鍵、值</li>\n<li>E（Element）表示集合中的一個元素</li>\n<li>&lt;? extends A&gt; 上界通配符，表示 A 類型或其子類</li>\n<li>&lt;? super A&gt; 下界通配符，表示 A 類型或其父類</li>\n<li><t extends a> 表示 A 類型或其子類的一種</t></li>\n<li>&lt;T extends A &amp; B&gt; 表示 A 類型且B類型的子類的一種</li>\n<li><del><t super a></t></del> </li>\n</ol>\n<p>泛型不是協變的，已知 Apple 繼承自 Fruit 的情況下，Plate<apple> 的引用並不能傳遞給 Plate<fruit>，但可以傳遞給 Plate&lt;? extends Fruit&gt;。</fruit></apple></p>\n<p>元素爲 &lt;? extends E&gt; 的集合，只能取出 E，而不能存入 E 及其子類的對象。因爲只能確定該類型是 E 的子類，但具體是哪個子類未知，因此編譯器不允許插入任何 E 或其子類的對象，取出來的時候只能當 E 類型。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">  List&lt;? extends A&gt; list = Arrays.asList(<span class=\"keyword\">new</span> A(), <span class=\"keyword\">new</span> B());</span><br><span class=\"line\">  list.add(<span class=\"keyword\">new</span> A()); <span class=\"comment\">// 報錯</span></span><br><span class=\"line\">  list.add(<span class=\"keyword\">new</span> B()); <span class=\"comment\">// 報錯</span></span><br><span class=\"line\">  A a = list.get(<span class=\"number\">1</span>);</span><br><span class=\"line\">  System.out.println(a.toString());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>元素爲 &lt;? super E&gt; 的集合，只能取出 Object，只能存入 E 及其子類的對象。因爲只能確定該類型是 E 的超類，但不知是哪一個超類，所以插入任何 E 及其子類的對象是沒問題的，但是插入 E 的超類就不行了，取出來的時候也只能是 Object，因爲 Object 是一切類的超類。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">  List&lt;? <span class=\"keyword\">super</span> B&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">  list.add(<span class=\"keyword\">new</span> A()); <span class=\"comment\">// 報錯</span></span><br><span class=\"line\">  list.add(<span class=\"keyword\">new</span> B());</span><br><span class=\"line\">  list.add(<span class=\"keyword\">new</span> C());</span><br><span class=\"line\">  Object object = list.get(<span class=\"number\">1</span>);</span><br><span class=\"line\">  System.out.println(object.toString());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span> <span class=\"keyword\">extends</span> <span class=\"title\">B</span></span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"獲取鍵盤輸入數據的常用方法\"><a href=\"#獲取鍵盤輸入數據的常用方法\" class=\"headerlink\" title=\"獲取鍵盤輸入數據的常用方法\"></a>獲取鍵盤輸入數據的常用方法</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方法一：使用 Scanner，可以快速確定輸入數據的類型，按空格符分割數據</span></span><br><span class=\"line\">Scanner scanner = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\">String s = scanner.nextLine();</span><br><span class=\"line\">System.out.println(s);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方法二：使用 BufferedReader 讀取字符序列，高效但需要轉換成其他類型，會拋出 IOException</span></span><br><span class=\"line\">BufferedReader bufferedReader = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> InputStreamReader(System.in));</span><br><span class=\"line\">String s1 = bufferedReader.readLine();</span><br><span class=\"line\">System.out.println(s1);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"方法（函數）\"><a href=\"#方法（函數）\" class=\"headerlink\" title=\"方法（函數）\"></a>方法（函數）</h2><h3 id=\"爲什麼-Java-只有值傳遞？\"><a href=\"#爲什麼-Java-只有值傳遞？\" class=\"headerlink\" title=\"爲什麼 Java 只有值傳遞？\"></a>爲什麼 Java 只有值傳遞？</h3><p>首先要明瞭程序設計語言中的有關函數參數傳遞的兩種方法：</p>\n<ol>\n<li>按值調用（call by value）：方法接收調用者提供的參數的值，方法內無法修改實際參數值。</li>\n<li>按引用調用（call by reference）：方法接收調用者提供的參數的地址，方法內可以修改實際參數值。</li>\n</ol>\n<p><strong>Java 總是採用按值調用，所有參數值都是一個拷貝，無法修改實際參數值。對於引用類型參數，傳遞的是引用的拷貝，引用的拷貝和引用指向同一個對象，即所謂的淺拷貝</strong>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">  String s1 = <span class=\"string\">\"Hello\"</span>;</span><br><span class=\"line\">  String s2 = <span class=\"string\">\"World\"</span>;</span><br><span class=\"line\">  swap(s1, s2);</span><br><span class=\"line\">  System.out.printf(<span class=\"string\">\"main s1: %s, s2: %s%n\"</span>, s1, s2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(String s1, String s2)</span> </span>&#123;</span><br><span class=\"line\">  String tmp = s1;</span><br><span class=\"line\">  s1 = s2;</span><br><span class=\"line\">  s2 = tmp;</span><br><span class=\"line\">  System.out.printf(<span class=\"string\">\"swap s1: %s, s2: %s%n\"</span>, s1, s2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 運行結果：</span></span><br><span class=\"line\"><span class=\"comment\">// swap s1: World, s2: Hello</span></span><br><span class=\"line\"><span class=\"comment\">// main s1: Hello, s2: World</span></span><br></pre></td></tr></table></figure>\n\n<p>結論：</p>\n<ol>\n<li>一個方法不能修改一個基本類型的實參。</li>\n<li>一個方法可以改變一個對象類型的實參狀態。</li>\n<li>一個方法不能讓對象類型的實參引用一個新對象。</li>\n</ol>\n<h3 id=\"深拷貝和淺拷貝有什麼不同？\"><a href=\"#深拷貝和淺拷貝有什麼不同？\" class=\"headerlink\" title=\"深拷貝和淺拷貝有什麼不同？\"></a>深拷貝和淺拷貝有什麼不同？</h3><ol>\n<li>淺拷貝：對基本類型拷貝其值；對引用類型拷貝其引用。</li>\n<li>深拷貝：對基本類型拷貝其值；對引用類型，新建一個對象並拷貝原對象的值。</li>\n</ol>\n<p><img src=\"/2020/12/02/it/java/java-basic/Untitled.png\" alt></p>\n<h3 id=\"重載和重寫有什麼區別？\"><a href=\"#重載和重寫有什麼區別？\" class=\"headerlink\" title=\"重載和重寫有什麼區別？\"></a>重載和重寫有什麼區別？</h3><ol>\n<li>重載（overloading）：在一個類中，有多個同名但不同傳入參數的方法，各個重載方法簽名不同。</li>\n<li>重寫（overwrite）：子類對父類允許訪問的方法的重新編寫，方法簽名不變，訪問修飾符只能降低不能提高，拋出的異常只能更小，返回值類型也是。</li>\n</ol>\n<h2 id=\"Java-面向對象\"><a href=\"#Java-面向對象\" class=\"headerlink\" title=\"Java 面向對象\"></a>Java 面向對象</h2><h3 id=\"面向對象和面向過程\"><a href=\"#面向對象和面向過程\" class=\"headerlink\" title=\"面向對象和面向過程\"></a>面向對象和面向過程</h3><ol>\n<li>面向過程：不需要實例化對象，內存和 CPU 開銷小，但不容易維護。</li>\n<li>面向對象：需要實例化對象，內存和 CPU 開銷大，但易維護、易復用、易擴展。</li>\n</ol>\n<p>Java 因爲編譯出的字節碼並不能直接在機器上運行，因而效率上會稍慢。但一些面向過程的腳本語言性能也不一定比 Java 好。</p>\n<h3 id=\"構造方法\"><a href=\"#構造方法\" class=\"headerlink\" title=\"構造方法\"></a>構造方法</h3><ol>\n<li>特點：名字跟類名相同，沒有返回值，不可重寫但可重載。</li>\n<li>作用：執行對象的初始化工作，如果類沒有重載任何構造方法，那默認會有不帶參數的構造方法。</li>\n<li>子類初始化時一定會調用父類的構造方法，即使子類不顯式調用，也會默認調用父類的無參構造方法。</li>\n</ol>\n<h3 id=\"成員變量和局部變量的區別\"><a href=\"#成員變量和局部變量的區別\" class=\"headerlink\" title=\"成員變量和局部變量的區別\"></a>成員變量和局部變量的區別</h3><ol>\n<li>成員變量：屬於類；可以被 public、private、static 等修飾符修飾；如用 static 修飾則變量屬於類，否則屬於對象存在於堆內存；生命週期隨對象；自動賦予初始化值。</li>\n<li>局部變量：屬於代碼塊或方法；只能被 final 修飾；存在於棧內存；生命週期隨代碼塊或方法；不會自動賦予初始化值。</li>\n</ol>\n<h3 id=\"對象實例和對象引用的區別\"><a href=\"#對象實例和對象引用的區別\" class=\"headerlink\" title=\"對象實例和對象引用的區別\"></a>對象實例和對象引用的區別</h3><ol>\n<li>對象實例：存在於堆內存，一個對象實例可以被多個引用指向。</li>\n<li>對象引用：存在於棧內存，一個引用指向一個對象實例。</li>\n</ol>\n<h3 id=\"面向對象的三大特徵\"><a href=\"#面向對象的三大特徵\" class=\"headerlink\" title=\"面向對象的三大特徵\"></a>面向對象的三大特徵</h3><p><strong>（1）封裝</strong></p>\n<p>封裝是將一個對象的狀態信息（即屬性）隱藏在對象內部，一般不允許外界直接訪問，而是提供必要的方法給外界操作。</p>\n<p><strong>（2）繼承</strong></p>\n<p>繼承是使用已有的類創建新類的技術，它提高了代碼復用率和開發效率。關於繼承以下幾點務必明瞭：</p>\n<ol>\n<li>子類擁有父類所有的屬性和方法（包括私有的），但父類中的私有屬性和方法子類無法訪問（反射子類也無法訪問），<strong>僅僅擁有</strong>。</li>\n<li>子類可以對父類進行擴展，增加新的屬性和方法。</li>\n<li>子類可以重寫父類的方法。</li>\n</ol>\n<p><strong>（3）多態</strong></p>\n<p>多態，即一個對象可以擁有多種狀態。具體表現在父類的引用可以指向子類的實例。關於多態以下幾點務必知曉：</p>\n<ol>\n<li>對象類型和引用類型之間具有繼承/實現關係。</li>\n<li>對象類型不可變，引用類型可變。</li>\n<li>方法具有多態性，屬性不具有。父類的引用可以調用子類對象的方法，但不能訪問其屬性。</li>\n<li>父類的引用不能調用「只有子類存在但在父類不存在」的方法。</li>\n<li>如果子類重寫了父類的方法，真正執行的是子類覆蓋的方法。</li>\n</ol>\n<h3 id=\"靜態方法內爲什麼不能調用非靜態成員？\"><a href=\"#靜態方法內爲什麼不能調用非靜態成員？\" class=\"headerlink\" title=\"靜態方法內爲什麼不能調用非靜態成員？\"></a><strong>靜態方法內爲什麼不能調用非靜態成員？</strong></h3><p>因爲非靜態成員需要在類實例化成對象後才能被調用，而靜態方法不需要實例化對象就可以被調用。</p>\n<h3 id=\"接口和抽象類的區別\"><a href=\"#接口和抽象類的區別\" class=\"headerlink\" title=\"接口和抽象類的區別\"></a>接口和抽象類的區別</h3><ol>\n<li>方法上：接口的方法默認修飾符是 public，且不能實現（Java 8 開始可以有默認方法和靜態方法，Java 9 開始可以有私有方法和私有靜態方法）；而抽象類可有 public、protected 和 default 修飾符，且可有非抽象的方法。</li>\n<li>變量上：接口只能有 static、final 變量；而抽象類沒有限制。</li>\n<li>繼承上：一個類可以實現多個接口，接口本身也可以擴展多個接口；但一個類只能繼承一個抽象類。</li>\n<li>設計上：接口是對行爲的抽象，是一個行爲規範；抽象類是對類的抽象，是一種模板設計。</li>\n</ol>\n<h2 id=\"Java-核心技術\"><a href=\"#Java-核心技術\" class=\"headerlink\" title=\"Java 核心技術\"></a>Java 核心技術</h2><h3 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h3><p>見 <a href=\"https://linlshare.github.io/2020/12/02/it/java/java-collection/\" target=\"_blank\" rel=\"noopener\">Java 集合</a> </p>\n<h3 id=\"反射機制\"><a href=\"#反射機制\" class=\"headerlink\" title=\"反射機制\"></a>反射機制</h3><p><strong>（1）什麼是反射</strong></p>\n<p>Java 的反射機制是在運行時能知道任意一個類的所有屬性和方法，能調用任意一個對象的屬性和方法。</p>\n<p><strong>（2）反射的優缺點</strong></p>\n<ol>\n<li>優點：運行時確定類型，動態加載類，提高代碼靈活度。</li>\n<li>缺點：反射性能比直接的 Java 代碼慢，存在安全問題，因爲可以動態操作改變類的屬性。</li>\n</ol>\n<p>反射動態加載類的優點即是動態編譯，與之相對的是靜態編譯，靜態編譯是在編譯時就確定了類型。</p>\n<p><strong>（3）反射的應用場景</strong></p>\n<p>反射是框架設計的靈魂。其應用場景有：</p>\n<ol>\n<li>模塊化開發；</li>\n<li>動態代理設計模式；</li>\n<li>Spring 框架的 IOC（控制反轉）和 AOP（面向切面編程）；</li>\n<li>JDBC 連接數據庫等等。</li>\n</ol>\n<h3 id=\"異常\"><a href=\"#異常\" class=\"headerlink\" title=\"異常\"></a>異常</h3><p><strong>（1）簡介</strong></p>\n<p>Java 的異常歸於同一個 Throwable 類，並分爲兩大類：Error 和 Exception。<strong>Error 通常是 JVM 錯誤，程序無法處理</strong>；<strong>而 Exception 是程序本身可以處理的異常</strong>。Exception 分爲 Checked Exceptions（受檢異常）和 Unchecked Exceptions（不受檢異常）。</p>\n<p><img src=\"/2020/12/02/it/java/java-basic/Untitled%201.png\" alt></p>\n<p><strong>Checked Exceptions 又名 Compile Time Exceptions（編譯時異常）</strong>，編譯器可以發現並要求程序處理後才能正常通過編譯，常見的有：</p>\n<ul>\n<li><em>IOException</em></li>\n<li><em>EOFException</em></li>\n<li><em>MalFormedURLException</em></li>\n<li><em>IntruptedException</em></li>\n</ul>\n<p><strong>Unchecked Exception 又名 Runtime Exceptions（運行時異常）</strong>，編譯器無法檢測出，只有運行時才會發生的異常，常見的有：</p>\n<ul>\n<li><em>ArithmaticException</em></li>\n<li><em>NullPointerException</em></li>\n<li><em>IndexOutOfBoundsException</em></li>\n<li><em>ClassCastException</em></li>\n<li><em>ArrayIndexOutOfBoundsException</em></li>\n<li><em>NumberFormatException</em></li>\n</ul>\n<p><strong>（2）Throwable 類常用方法</strong></p>\n<ol>\n<li><code>getMessage</code>：返回異常的簡要描述</li>\n<li><code>toString</code>：返回異常的詳細信息</li>\n<li><code>getLocalizedMessage</code>：返回異常的本地化信息（需要子類覆蓋該方法，否則與 <code>getMessage</code> 一樣）</li>\n<li><code>printStackTrace</code>：在控制台打印 Throwable 对象封装的异常信息</li>\n</ol>\n<p><strong>（3）try-catch-finally</strong></p>\n<ol>\n<li>try 代碼塊：捕獲異常。其後可接零個或多個 catch 代碼塊，如零個則必須接一個 finally 代碼塊。</li>\n<li>catch 代碼塊：處理捕獲到的異常。</li>\n<li>finally 代碼塊：無論是否捕獲或處理異常，finally 代碼塊最終都會被執行。當在 try 代碼塊或 catch 代碼塊中遇到 return 語句時，finally 代碼塊將在方法返回之前被執行。此時如果 finally 中也有 return 語句的話，其返回值將覆蓋 try 或 catch 代碼塊中的返回值。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">f</span><span class=\"params\">(<span class=\"keyword\">int</span> value)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> value * value;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (value == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// f(2) 將返回 0 ，而不是 4.</span></span><br></pre></td></tr></table></figure>\n\n<p>以下情況，finally 代碼塊不會被執行或只部分執行：</p>\n<ol>\n<li>finally 代碼塊中有異常，代碼會中異常處中止；</li>\n<li>在 catch 代碼塊或 finally 塊中調用了 <code>System.exit</code> 函數退出程序；</li>\n<li>程序所在的線程死亡等等不可預料的系統和硬件問題。</li>\n</ol>\n<p><strong>（4）try-witch-resources</strong></p>\n<p>Java 7 中新增了 ****try-witch-resources 語法糖，適用於實現<code>java.lang.AutoCloseable</code> 或者 <code>java.io.Closeable</code> 的對象，可以自動關閉申請的資源，然後再執行 catch 或 finally 代碼塊。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// try-catch-finally</span></span><br><span class=\"line\">Scanner scanner = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    scanner = <span class=\"keyword\">new</span> Scanner(<span class=\"keyword\">new</span> File(<span class=\"string\">\"src/main/resources/test.txt\"</span>));</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (scanner.hasNext()) &#123;</span><br><span class=\"line\">        System.out.println(scanner.nextLine());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (scanner != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        scanner.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// try-witch-resources</span></span><br><span class=\"line\"><span class=\"keyword\">try</span> (Scanner scanner = <span class=\"keyword\">new</span> Scanner(<span class=\"keyword\">new</span> File(<span class=\"string\">\"src/main/resources/test.txt\"</span>))) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (scanner.hasNext()) &#123;</span><br><span class=\"line\">        System.out.println(scanner.nextLine());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"多線程\"><a href=\"#多線程\" class=\"headerlink\" title=\"多線程\"></a>多線程</h3><p>見 <a href=\"https://linlshare.github.io/2020/12/02/it/java/java-concurrent/\" target=\"_blank\" rel=\"noopener\">Java 並發</a> </p>\n<h3 id=\"文件與-I-O-流\"><a href=\"#文件與-I-O-流\" class=\"headerlink\" title=\"文件與 I/O 流\"></a>文件與 I/O 流</h3><p><strong>（1）Java 中 I/O 流分爲幾種？</strong></p>\n<p>按不同的分類方法有不同的分類：</p>\n<ol>\n<li>按流向分：輸入流、輸出流。</li>\n<li>按操作單元分：字節流、字符流。</li>\n<li>按角色分：節點流、處理流。</li>\n</ol>\n<p>Java 中 40 多個 I/O 流相關的類都是從 4 個抽象基類派生：</p>\n<ol>\n<li>InputStream：字節輸入流</li>\n<li>Reader：字符輸入流</li>\n<li>OutputStream：字節輸出流</li>\n<li>Writer：字符輸出流</li>\n</ol>\n<p><img src=\"/2020/12/02/it/java/java-basic/Untitled%202.png\" alt></p>\n<p><img src=\"/2020/12/02/it/java/java-basic/Untitled%203.png\" alt></p>\n<p><strong>（2）爲什麼有了字節流還需要字符流？</strong></p>\n<p>不管是文件讀寫還是網絡發送接收，信息的最小存儲單元都是字節，那為什麼 I/O 流操作要分為字節流操作和字符流操作呢？</p>\n<p>字符流是由 JVM 將字節流轉換得到的，過程非常耗時，且容易出現亂碼問題。所以 I/O 流提供直接操作字符流的接口，以避免這種轉換。對於文本建議使用字符流，而圖片、音視頻等應使用字節流。</p>\n<p><strong>（3）BIO、NIO、AIO 有什麼區別？</strong></p>\n<ol>\n<li><strong>BIO</strong>（Blocking I/O），同步阻塞 I/O 模式，數據的讀取寫入必須阻塞在一個線程內等待其完成。適用於活動連接數不高（&lt; 單機 1000）的情況，結合線程池一起使用。</li>\n<li><strong>NIO</strong>（Non-blocking I/O 或 New I/O），同步非阻塞的 I/O 模型，Java 1.4 中引入，位於 <code>java.nio</code> 包，提供 Channel、Selector 和 Buffer 等抽象，支持基於通道面向緩衝的 I/O 操作方法。適用於高負載、高並發的（網絡）應用。</li>\n<li><strong>AIO</strong>（Asynchronous I/O），異步非阻塞的 I/O 模型，Java 7 中引入。支持基於事件回調機制的操作方法。</li>\n</ol>\n<p>NIO 模型：</p>\n<p><img src=\"/2020/12/02/it/java/java-basic/Untitled%204.png\" alt></p>\n<ul>\n<li><p>NIO 服務端代碼</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MultiplexerNioServer</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Selector selector;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">boolean</span> stop = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 初始化多路复用器 绑定监听端口</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> port</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MultiplexerNioServer</span><span class=\"params\">(<span class=\"keyword\">int</span> port)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();<span class=\"comment\">//获得一个serverChannel</span></span><br><span class=\"line\">            selector = Selector.open();<span class=\"comment\">////创建选择器  获得一个多路复用器</span></span><br><span class=\"line\">            serverSocketChannel.configureBlocking(<span class=\"keyword\">false</span>);<span class=\"comment\">//设置为非阻塞模式 如果为 true，则此通道将被置于阻塞模式；如果为 false，则此通道将被置于非阻塞模式</span></span><br><span class=\"line\">            serverSocketChannel.socket().bind(<span class=\"keyword\">new</span> InetSocketAddress(port), <span class=\"number\">1024</span>);<span class=\"comment\">//绑定一个端口和等待队列长度</span></span><br><span class=\"line\">            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);<span class=\"comment\">//把selector注册到channel，关注链接事件</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            System.exit(<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">stop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.stop = <span class=\"keyword\">true</span>; <span class=\"comment\">// 优雅停机</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!stop) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">//无论是否有读写事件发生，selector每隔1s被唤醒一次。如果一定时间内没有事件，就需要做些其他的事情，就可以使用带超时的</span></span><br><span class=\"line\">                <span class=\"keyword\">int</span> client = selector.select(<span class=\"number\">1000</span>);</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"1:\"</span> + client);</span><br><span class=\"line\">                <span class=\"comment\">// 阻塞,只有当至少一个注册的事件发生的时候才会继续.</span></span><br><span class=\"line\">                <span class=\"comment\">// int client = selector.select(); 不设置超时时间为线程阻塞，但是IO上支持多个文件描述符就绪</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (client == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"2:\"</span> + client);</span><br><span class=\"line\">                Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class=\"line\">                Iterator&lt;SelectionKey&gt; it = selectionKeys.iterator();</span><br><span class=\"line\">                SelectionKey key = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (it.hasNext()) &#123;</span><br><span class=\"line\">                    key = it.next();</span><br><span class=\"line\">                    it.remove();</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        <span class=\"comment\">//处理事件</span></span><br><span class=\"line\">                        handle(key);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (key != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                            key.cancel();</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (key.channel() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                                key.channel().close();</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (selector != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// selector关闭后会自动释放里面管理的资源</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                selector.close();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handle</span><span class=\"params\">(SelectionKey key)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (key.isValid()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//连接事件</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (key.isAcceptable()) &#123;</span><br><span class=\"line\">                ServerSocketChannel ssc = (ServerSocketChannel) key.channel();</span><br><span class=\"line\">                <span class=\"comment\">// 通过ServerSocketChannel的accept创建SocketChannel实例</span></span><br><span class=\"line\">                <span class=\"comment\">// 完成该操作意味着完成TCP三次握手，TCP物理链路正式建立</span></span><br><span class=\"line\">                SocketChannel sc = ssc.accept();<span class=\"comment\">//3次握手</span></span><br><span class=\"line\">                sc.configureBlocking(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">                sc.register(selector, SelectionKey.OP_READ);<span class=\"comment\">//连接建立后关注读事件</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//读事件</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (key.isReadable()) &#123;</span><br><span class=\"line\">                SocketChannel socketChannel = (SocketChannel) key.channel();</span><br><span class=\"line\">                ByteBuffer readbuffer = ByteBuffer.allocate(<span class=\"number\">1024</span>);<span class=\"comment\">//写 0 1024  1024</span></span><br><span class=\"line\"><span class=\"comment\">//                ByteBuffer readbuffer = ByteBuffer.allocateDirect(1024); //申请直接内存，也就是堆外内存</span></span><br><span class=\"line\">                <span class=\"comment\">// 读取请求码流，返回读取到的字节数</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> readBytes = socketChannel.read(readbuffer);</span><br><span class=\"line\">                    <span class=\"comment\">// 读取到字节，对字节进行编解码</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (readBytes &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 将缓冲区当前的limit设置为position=0，用于后续对缓冲区的读取操作</span></span><br><span class=\"line\">                        readbuffer.flip();<span class=\"comment\">//读写模式反转</span></span><br><span class=\"line\">                        <span class=\"comment\">// 将缓冲区可读字节数组复制到新建的数组中</span></span><br><span class=\"line\">                        <span class=\"keyword\">byte</span>[] bytes = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[readbuffer.remaining()];</span><br><span class=\"line\">                        readbuffer.get(bytes);</span><br><span class=\"line\">                        String body = <span class=\"keyword\">new</span> String(bytes, StandardCharsets.UTF_8);</span><br><span class=\"line\">                        System.out.println(<span class=\"string\">\"input is:\"</span> + body);</span><br><span class=\"line\">                        res(socketChannel, body);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (readBytes &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 链路已经关闭 释放资源</span></span><br><span class=\"line\">                        key.cancel();</span><br><span class=\"line\">                        socketChannel.close();</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 没有读到字节忽略</span></span><br><span class=\"line\">                        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">res</span><span class=\"params\">(SocketChannel channel, String response)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (response != <span class=\"keyword\">null</span> &amp;&amp; response.length() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">byte</span>[] bytes = response.getBytes();</span><br><span class=\"line\">            ByteBuffer writeBuffer = ByteBuffer.allocate(bytes.length);</span><br><span class=\"line\">            writeBuffer.put(bytes);</span><br><span class=\"line\">            writeBuffer.flip();</span><br><span class=\"line\">            channel.write(writeBuffer);</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"res end\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>NIO 客戶端代碼</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NioClientHandler</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String host;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> port;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Selector selector;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> SocketChannel socketChannel;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">boolean</span> stop;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">NioClientHandler</span><span class=\"params\">(String host, <span class=\"keyword\">int</span> port)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.host = host;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.port = port;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 创建选择器</span></span><br><span class=\"line\">            selector = Selector.open();</span><br><span class=\"line\">            <span class=\"comment\">// 打开监听通道</span></span><br><span class=\"line\">            socketChannel = SocketChannel.open();</span><br><span class=\"line\">            <span class=\"comment\">// 如果为 true，则此通道将被置于阻塞模式；如果为 false，则此通道将被置于非阻塞模式</span></span><br><span class=\"line\">            socketChannel.configureBlocking(<span class=\"keyword\">false</span>); <span class=\"comment\">// 开启非阻塞模式</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            System.exit(<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            doConnect();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            System.exit(<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!stop) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> wait = selector.select(<span class=\"number\">1000</span>);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (wait == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class=\"line\">                Iterator&lt;SelectionKey&gt; it = selectionKeys.iterator();</span><br><span class=\"line\">                SelectionKey key = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (it.hasNext()) &#123;</span><br><span class=\"line\">                    key = it.next();</span><br><span class=\"line\">                    it.remove();</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        handle(key);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (key != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                            key.cancel();</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (key.channel() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                                key.channel().close();</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">                System.exit(<span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (selector != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                selector.close();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">doConnect</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (socketChannel.connect(<span class=\"keyword\">new</span> InetSocketAddress(host, port))) &#123;</span><br><span class=\"line\">            socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class=\"line\">            doWrite(socketChannel);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            socketChannel.register(selector, SelectionKey.OP_CONNECT);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">handle</span><span class=\"params\">(SelectionKey key)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (key.isValid()) &#123;</span><br><span class=\"line\">            SocketChannel sc = (SocketChannel) key.channel();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (key.isConnectable()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (sc.finishConnect()) &#123;</span><br><span class=\"line\">                    sc.register(selector, SelectionKey.OP_READ);</span><br><span class=\"line\">                    doWrite(sc);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    System.exit(<span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (key.isReadable()) &#123;</span><br><span class=\"line\">                ByteBuffer readBuffer = ByteBuffer.allocate(<span class=\"number\">1024</span>);</span><br><span class=\"line\">                <span class=\"keyword\">int</span> readBytes = sc.read(readBuffer);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (readBytes &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    readBuffer.flip();</span><br><span class=\"line\">                    <span class=\"keyword\">byte</span>[] bytes = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[readBuffer.remaining()];</span><br><span class=\"line\">                    readBuffer.get(bytes);</span><br><span class=\"line\">                    String body = <span class=\"keyword\">new</span> String(bytes, StandardCharsets.UTF_8);</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">\"res\"</span> + body);</span><br><span class=\"line\">                    <span class=\"keyword\">this</span>.stop = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (readBytes &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    key.cancel();</span><br><span class=\"line\">                    sc.close();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">doWrite</span><span class=\"params\">(SocketChannel sc)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 将消息编码为字节数组</span></span><br><span class=\"line\">        <span class=\"keyword\">byte</span>[] request = <span class=\"string\">\"Hello\"</span>.getBytes();</span><br><span class=\"line\">        <span class=\"comment\">// 根据数组容量创建ByteBuffer</span></span><br><span class=\"line\">        ByteBuffer writeBuffer = ByteBuffer.allocate(request.length);</span><br><span class=\"line\">        <span class=\"comment\">// 将字节数组复制到缓冲区</span></span><br><span class=\"line\">        writeBuffer.put(request);</span><br><span class=\"line\">        <span class=\"comment\">// flip读写切换操作</span></span><br><span class=\"line\">        writeBuffer.flip();</span><br><span class=\"line\">        sc.write(writeBuffer);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!writeBuffer.hasRemaining()) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"写入完成\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h2 id=\"Java-項目管理和構建\"><a href=\"#Java-項目管理和構建\" class=\"headerlink\" title=\"Java 項目管理和構建\"></a>Java 項目管理和構建</h2><h3 id=\"Maven-项目\"><a href=\"#Maven-项目\" class=\"headerlink\" title=\"Maven 项目\"></a>Maven 项目</h3><p><strong>（1）安装</strong></p>\n<p>從 <a href=\"https://maven.apache.org/download.cgi\" target=\"_blank\" rel=\"noopener\">Maven 官網</a>下載 maven 包，解壓並設置環境變量。還可以直接使用 IDEA 的 Maven 插件。</p>\n<p><strong>（2）初始化一個 Maven 項目</strong></p>\n<p>使用以下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">mvn -B archetype:generate -DgroupId=com.mycompany.app -DartifactId=my-app -DarchetypeArtifactId=maven-archetype-quickstart -DarchetypeVersion=1.4</span><br></pre></td></tr></table></figure>\n\n<p>或者用 IDEA 直接新建一個 Maven 項目，其結構如下：</p>\n<p><img src=\"/2020/12/02/it/java/java-basic/20201114_101407.png\" alt></p>\n<p>其中 pom.xml 的內容如下：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">project</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://maven.apache.org/POM/4.0.0\"</span></span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">modelVersion</span>&gt;</span>4.0.0<span class=\"tag\">&lt;/<span class=\"name\">modelVersion</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.example<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>testmaven<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.0-SNAPSHOT<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--  添加以下屬性，解決編譯報錯  --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">properties</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class=\"tag\">&lt;/<span class=\"name\">project.build.sourceEncoding</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">maven.compiler.encoding</span>&gt;</span>UTF-8<span class=\"tag\">&lt;/<span class=\"name\">maven.compiler.encoding</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">java.version</span>&gt;</span>15<span class=\"tag\">&lt;/<span class=\"name\">java.version</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">maven.compiler.source</span>&gt;</span>15<span class=\"tag\">&lt;/<span class=\"name\">maven.compiler.source</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">maven.compiler.target</span>&gt;</span>15<span class=\"tag\">&lt;/<span class=\"name\">maven.compiler.target</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">properties</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 新增依賴在下方 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.openjdk.jol<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>jol-core<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>0.14<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">project</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>為什麼叫 Maven？</p>\n<p>  Maven 來源於意第緒語，爲「行家」的意思。最初是為了簡化 Jakarta Turbine 項目中的構建過程而建立。Maven 使用項目對象模型（POM）和一組插件來構件項目。</p>\n</li>\n<li><p>POM 又是指什麼？</p>\n<p>  POM（project object model）項目對象模型，maven 使用 <code>pom.xml</code> 定義了整個項目的構建、報告和文檔。</p>\n</li>\n</ul>\n<p><strong>（3）編譯測試打包</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 清理 target 中的文件</span></span><br><span class=\"line\">mvn clean</span><br><span class=\"line\"><span class=\"comment\"># 編譯 java 文件成 class 文件，置於 target/classes 文件夾中</span></span><br><span class=\"line\">mvn compile</span><br><span class=\"line\"><span class=\"comment\"># 進行單元測試</span></span><br><span class=\"line\">mvn <span class=\"built_in\">test</span></span><br><span class=\"line\"><span class=\"comment\"># 打包成 jar 文件，置於 target 文件夾中</span></span><br><span class=\"line\">mvn package</span><br><span class=\"line\"><span class=\"comment\"># 安裝 jar 包到本地存儲庫（$&#123;user.home&#125;/.m2/repository）</span></span><br><span class=\"line\">mvn install</span><br><span class=\"line\"><span class=\"comment\"># 生成自己的 maven 站點</span></span><br><span class=\"line\">mvn site</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>SNAPSHOT 是什麼？</p>\n<p>  snapshot 簡要的意思，在版本號之後添加 <code>-SNAPSHOT</code> 是說明該版本仍處於開發階段，不是最終的發行版本。以 <code>x.y-SNAPSHOT</code> 版本為例，發行時會去除 <code>-SNAPSHOT</code>  後綴，然後將最新的開發版本升爲<code>x.(y+1)-SNAPSHOT</code> 。</p>\n</li>\n<li><p>使用 mvn compile 生成的 jar 包，其內容是怎樣的？</p>\n<p>  除了 class 文件外，還有 <code>META-INF</code> 文件夾，裏面存放一些清單文件和pom 文件。存放到項目資源文件夾（<code>main/resources</code> ）的文件也會被打包到<code>META-INF</code> 文件夾中，代碼中可通過<code>getClass().getResourceAsStream( &quot;/application.properties&quot; )</code> 調用。</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ jar tf target/testmaven-1.0-SNAPSHOT.jar </span><br><span class=\"line\">META-INF/</span><br><span class=\"line\">META-INF/MANIFEST.MF</span><br><span class=\"line\">B.class</span><br><span class=\"line\">MemoryLayoutTest.class</span><br><span class=\"line\">A.class</span><br><span class=\"line\">C.class</span><br><span class=\"line\">META-INF/maven/</span><br><span class=\"line\">META-INF/maven/org.example/</span><br><span class=\"line\">META-INF/maven/org.example/testmaven/</span><br><span class=\"line\">META-INF/maven/org.example/testmaven/pom.xml</span><br><span class=\"line\">META-INF/maven/org.example/testmaven/pom.properties</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"Gradle-项目\"><a href=\"#Gradle-项目\" class=\"headerlink\" title=\"Gradle 项目\"></a>Gradle 项目</h3><p><strong>（1）安裝</strong></p>\n<p>可從 <a href=\"https://www.gradle.org/downloads\" target=\"_blank\" rel=\"noopener\">gradle 官網</a>下載解壓並配置環境變量的方式安裝。Mac 用戶還可以使用 <code>brew install gradle</code> 的方式安裝。或者直接使用 IDEA 項目中的 <code>gradle-wrapper</code> ，此時對應的 <code>gradle</code> 命令變爲 <code>gradlew</code>。</p>\n<p><strong>（2）gradle 命令能做什麼？</strong></p>\n<p>gradle 命令能構建項目， 查看項目依賴、子項目和項目配置等等。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ gradle tasks</span><br><span class=\"line\"></span><br><span class=\"line\">:tasks</span><br><span class=\"line\"></span><br><span class=\"line\">== All tasks runnable from root project</span><br><span class=\"line\"></span><br><span class=\"line\">== Build Setup tasks</span><br><span class=\"line\">setupBuild - Initializes a new Gradle build. [incubating]</span><br><span class=\"line\"></span><br><span class=\"line\">== Help tasks</span><br><span class=\"line\">dependencies - Displays all dependencies declared <span class=\"keyword\">in</span> root project <span class=\"string\">'gs-gradle'</span>.</span><br><span class=\"line\">dependencyInsight - Displays the insight into a specific dependency <span class=\"keyword\">in</span> root project <span class=\"string\">'gs-gradle'</span>.</span><br><span class=\"line\"><span class=\"built_in\">help</span> - Displays a <span class=\"built_in\">help</span> message</span><br><span class=\"line\">projects - Displays the sub-projects of root project <span class=\"string\">'gs-gradle'</span>.</span><br><span class=\"line\">properties - Displays the properties of root project <span class=\"string\">'gs-gradle'</span>.</span><br><span class=\"line\">tasks - Displays the tasks runnable from root project <span class=\"string\">'gs-gradle'</span>.</span><br><span class=\"line\"></span><br><span class=\"line\">To see all tasks and more detail, run with --all.</span><br><span class=\"line\"></span><br><span class=\"line\">BUILD SUCCESSFUL</span><br><span class=\"line\"></span><br><span class=\"line\">Total time: 3.077 secs</span><br></pre></td></tr></table></figure>\n\n<p><strong>（3）初始化一個 Gradle 項目</strong></p>\n<p>在項目文件夾中新建一個名爲 <code>build.gradle</code> 的文件，其內容如下：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"code\"><pre><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'java'</span></span><br></pre></td></tr></table></figure>\n\n<p>隨後新建一個名爲 <code>settings.gradle</code> 的文件，其內容可暫時爲空。</p>\n<p>在 IDEA 中打開此項目，隨後 IDEA 會自動配置加入 <code>gradle-wrapper</code> ，其過程等價於執行以下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">gradle wrapper --gradle-version 6.5</span><br></pre></td></tr></table></figure>\n\n<p><strong>（4）編譯打包</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 編譯項目，會默認在 build/classes 中生成類文件，在 build/libs 中生成 jar 包</span></span><br><span class=\"line\">gradle build</span><br><span class=\"line\"><span class=\"comment\"># 或使用 gradle wrapper</span></span><br><span class=\"line\">./gradlew build</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 清理生成的文件</span></span><br><span class=\"line\">gradle clean</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 生成 jar 文件</span></span><br><span class=\"line\">gradle jar</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 運行生成的 jar 文件</span></span><br><span class=\"line\">gradle run</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 進行單元測試</span></span><br><span class=\"line\">gradle <span class=\"built_in\">test</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>（5）<code>build.gradle</code> 中可配置什麼？</strong></p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 配置插件，插件提供語法定義</span></span><br><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'java'</span></span><br><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'application'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 配置入口類</span></span><br><span class=\"line\">mainClassName = <span class=\"string\">'hello.HelloWorld'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 配置依賴倉庫</span></span><br><span class=\"line\">repositories &#123;</span><br><span class=\"line\">    mavenCentral()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 配置生成的 jar 文件的入口類</span></span><br><span class=\"line\">jar &#123;</span><br><span class=\"line\">    manifest &#123;</span><br><span class=\"line\">        attributes <span class=\"string\">'Main-Class'</span>: mainClassName</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 配置 JDK 兼容性</span></span><br><span class=\"line\">sourceCompatibility = <span class=\"number\">1.8</span></span><br><span class=\"line\">targetCompatibility = <span class=\"number\">1.8</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 配置依賴</span></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    compile <span class=\"string\">\"joda-time:joda-time:2.2\"</span></span><br><span class=\"line\">    testCompile <span class=\"string\">\"junit:junit:4.12\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如需將所有依賴 jar 打進同一個 jar 包，可使用 <a href=\"https://github.com/johnrengelman/shadow\" target=\"_blank\" rel=\"noopener\">shadow 插件</a>或使用 <a href=\"https://spring.io/quickstart\" target=\"_blank\" rel=\"noopener\">spring boot 插件</a>。</p>"},{"title":"詩經·秦風‧蒹葭 (甲子話注音版)","p":"language/min/sigêng-giamgia","_content":"\n![](sigêng-giamgia/202010060948.jpg)\n\n{% aplayer \"蒹葭\" \"Hua\" \"2020/10/06/language/min/sigêng-giamgia/蒹葭.m4a\" \"/music.png\" %}\n\n蒹葭[^1]蒼蒼[^2]，白露爲霜。所謂伊人，在水一方。溯洄[^3]從之，道阻且長。溯游[^4]從之，宛在水中央。[^5]\ngiam¹ gia¹ cng¹ cng¹, bêh⁸ lao³ ui⁵ sng¹. so² ui³ i¹ ring⁵‚ do¹ zui² zêg⁸ hng¹. sog⁴ hoi⁵ ciong⁵ zu¹‚ dao⁶ zo² cian² dng⁵. sog⁴ iu⁵ ciong⁵ zu¹‚ uang² do¹ zui² dang¹ ng¹.\n\n蒹葭萋萋，白露未晞[^6]。所謂伊人，在水之湄[^7]。溯洄從之，道阻且躋。溯游從之，宛在水中坻[^8]。[^9]\ngiam¹ gia¹ ci¹ ci¹‚ bêh⁸ lao³ bhoi⁷ hi¹. so² ui³ i¹ ring⁵‚ do¹ zui² zu¹ mi⁵. sog⁴ hoi⁵ ciong⁵ zu¹‚ dao⁶ zo² cian² zi³. sog⁴ iu⁵ ciong¹ zu¹‚ uang² do¹ zui² dang¹ di².\n\n蒹葭采采，白露未已[^10]。所謂伊人，在水之涘[^11]。溯洄從之，道阻且右[^12]。溯游從之，宛在水中沚[^13]。[^14]_ giam¹ gia¹ cai² cai²‚ bêh⁸ lao³ bhoi⁷ in². so² ui³ i¹ ring⁵‚ do¹ zui² zu¹ su⁶. sog⁴ hoi⁵ ciong⁵ zu¹‚ dao⁶ zo² cian² iu⁶. sog⁴ iu⁵ ciong¹ zu¹‚ uang² do¹ zui² dang¹ zi².\n\n[^1]:\t「蒹」，荻草；「葭」，蘆草。\n\n[^2]:\t按今讀應爲「cang¹」，但根據韻腳應讀「cng¹」，且「倉」字甲子話亦讀作「cng¹」。\n\n[^3]:\t逆著河流走。\n\n[^4]:\t順著河流走。\n\n[^5]:\t蒼、霜、方、長、央，陽部。\n\n[^6]:\t露水未乾。\n\n[^7]:\t水草交接處，即岸邊。\n\n[^8]:\t水中小沙洲。\n\n[^9]:\t萋、晞、湄、躋、坻，脂部。\n\n[^10]:\t「已」完全。言露水還未完全乾。\n\n[^11]:\t岸邊。\n\n[^12]:\t水路彎曲。\n\n[^13]:\t水中小沙洲。\n\n[^14]:\t采、已、涘、右、沚，之部。","source":"_posts/language/min/sigêng-giamgia.md","raw":"---\ntitle: 詩經·秦風‧蒹葭 (甲子話注音版)\np: language/min/sigêng-giamgia\ntags:\n- 詩經\n- 甲子話\n- 閩南語\n---\n\n![](sigêng-giamgia/202010060948.jpg)\n\n{% aplayer \"蒹葭\" \"Hua\" \"2020/10/06/language/min/sigêng-giamgia/蒹葭.m4a\" \"/music.png\" %}\n\n蒹葭[^1]蒼蒼[^2]，白露爲霜。所謂伊人，在水一方。溯洄[^3]從之，道阻且長。溯游[^4]從之，宛在水中央。[^5]\ngiam¹ gia¹ cng¹ cng¹, bêh⁸ lao³ ui⁵ sng¹. so² ui³ i¹ ring⁵‚ do¹ zui² zêg⁸ hng¹. sog⁴ hoi⁵ ciong⁵ zu¹‚ dao⁶ zo² cian² dng⁵. sog⁴ iu⁵ ciong⁵ zu¹‚ uang² do¹ zui² dang¹ ng¹.\n\n蒹葭萋萋，白露未晞[^6]。所謂伊人，在水之湄[^7]。溯洄從之，道阻且躋。溯游從之，宛在水中坻[^8]。[^9]\ngiam¹ gia¹ ci¹ ci¹‚ bêh⁸ lao³ bhoi⁷ hi¹. so² ui³ i¹ ring⁵‚ do¹ zui² zu¹ mi⁵. sog⁴ hoi⁵ ciong⁵ zu¹‚ dao⁶ zo² cian² zi³. sog⁴ iu⁵ ciong¹ zu¹‚ uang² do¹ zui² dang¹ di².\n\n蒹葭采采，白露未已[^10]。所謂伊人，在水之涘[^11]。溯洄從之，道阻且右[^12]。溯游從之，宛在水中沚[^13]。[^14]_ giam¹ gia¹ cai² cai²‚ bêh⁸ lao³ bhoi⁷ in². so² ui³ i¹ ring⁵‚ do¹ zui² zu¹ su⁶. sog⁴ hoi⁵ ciong⁵ zu¹‚ dao⁶ zo² cian² iu⁶. sog⁴ iu⁵ ciong¹ zu¹‚ uang² do¹ zui² dang¹ zi².\n\n[^1]:\t「蒹」，荻草；「葭」，蘆草。\n\n[^2]:\t按今讀應爲「cang¹」，但根據韻腳應讀「cng¹」，且「倉」字甲子話亦讀作「cng¹」。\n\n[^3]:\t逆著河流走。\n\n[^4]:\t順著河流走。\n\n[^5]:\t蒼、霜、方、長、央，陽部。\n\n[^6]:\t露水未乾。\n\n[^7]:\t水草交接處，即岸邊。\n\n[^8]:\t水中小沙洲。\n\n[^9]:\t萋、晞、湄、躋、坻，脂部。\n\n[^10]:\t「已」完全。言露水還未完全乾。\n\n[^11]:\t岸邊。\n\n[^12]:\t水路彎曲。\n\n[^13]:\t水中小沙洲。\n\n[^14]:\t采、已、涘、右、沚，之部。","slug":"language/min/sigêng-giamgia","published":1,"date":"2020-10-06T01:12:45.597Z","updated":"2020-10-07T00:34:32.609Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cki72psxe0007slw84lp27w41","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css\"><p><img src=\"/2020/10/06/language/min/sigêng-giamgia/202010060948.jpg\" alt></p>\n\n        <div id=\"aplayer-NKAKWcYv\" class=\"aplayer aplayer-tag-marker\" style=\"margin-bottom: 20px;\">\n            <pre class=\"aplayer-lrc-content\"></pre>\n        </div>\n        <script>\n          var ap = new APlayer({\n            element: document.getElementById(\"aplayer-NKAKWcYv\"),\n            narrow: false,\n            autoplay: false,\n            showlrc: false,\n            music: {\n              title: \"蒹葭\",\n              author: \"Hua\",\n              url: \"2020/10/06/language/min/sigêng-giamgia/蒹葭.m4a\",\n              pic: \"/music.png\",\n              lrc: \"\"\n            }\n          });\n          window.aplayers || (window.aplayers = []);\n          window.aplayers.push(ap);\n        </script>\n\n<p>蒹葭<sup id=\"fnref:1\"><a href=\"#fn:1\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    「蒹」，荻草；「葭」，蘆草。\">[1]</span></a></sup>蒼蒼<sup id=\"fnref:2\"><a href=\"#fn:2\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    按今讀應爲「cang¹」，但根據韻腳應讀「cng¹」，且「倉」字甲子話亦讀作「cng¹」。\">[2]</span></a></sup>，白露爲霜。所謂伊人，在水一方。溯洄<sup id=\"fnref:3\"><a href=\"#fn:3\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    逆著河流走。\">[3]</span></a></sup>從之，道阻且長。溯游<sup id=\"fnref:4\"><a href=\"#fn:4\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    順著河流走。\">[4]</span></a></sup>從之，宛在水中央。<sup id=\"fnref:5\"><a href=\"#fn:5\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    蒼、霜、方、長、央，陽部。\">[5]</span></a></sup><br>giam¹ gia¹ cng¹ cng¹, bêh⁸ lao³ ui⁵ sng¹. so² ui³ i¹ ring⁵‚ do¹ zui² zêg⁸ hng¹. sog⁴ hoi⁵ ciong⁵ zu¹‚ dao⁶ zo² cian² dng⁵. sog⁴ iu⁵ ciong⁵ zu¹‚ uang² do¹ zui² dang¹ ng¹.</p>\n<p>蒹葭萋萋，白露未晞<sup id=\"fnref:6\"><a href=\"#fn:6\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    露水未乾。\">[6]</span></a></sup>。所謂伊人，在水之湄<sup id=\"fnref:7\"><a href=\"#fn:7\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    水草交接處，即岸邊。\">[7]</span></a></sup>。溯洄從之，道阻且躋。溯游從之，宛在水中坻<sup id=\"fnref:8\"><a href=\"#fn:8\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    水中小沙洲。\">[8]</span></a></sup>。<sup id=\"fnref:9\"><a href=\"#fn:9\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    萋、晞、湄、躋、坻，脂部。\">[9]</span></a></sup><br>giam¹ gia¹ ci¹ ci¹‚ bêh⁸ lao³ bhoi⁷ hi¹. so² ui³ i¹ ring⁵‚ do¹ zui² zu¹ mi⁵. sog⁴ hoi⁵ ciong⁵ zu¹‚ dao⁶ zo² cian² zi³. sog⁴ iu⁵ ciong¹ zu¹‚ uang² do¹ zui² dang¹ di².</p>\n<p>蒹葭采采，白露未已<sup id=\"fnref:10\"><a href=\"#fn:10\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    「已」完全。言露水還未完全乾。\">[10]</span></a></sup>。所謂伊人，在水之涘<sup id=\"fnref:11\"><a href=\"#fn:11\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    岸邊。\">[11]</span></a></sup>。溯洄從之，道阻且右<sup id=\"fnref:12\"><a href=\"#fn:12\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    水路彎曲。\">[12]</span></a></sup>。溯游從之，宛在水中沚<sup id=\"fnref:13\"><a href=\"#fn:13\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    水中小沙洲。\">[13]</span></a></sup>。<sup id=\"fnref:14\"><a href=\"#fn:14\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    采、已、涘、右、沚，之部。\">[14]</span></a></sup>_ giam¹ gia¹ cai² cai²‚ bêh⁸ lao³ bhoi⁷ in². so² ui³ i¹ ring⁵‚ do¹ zui² zu¹ su⁶. sog⁴ hoi⁵ ciong⁵ zu¹‚ dao⁶ zo² cian² iu⁶. sog⁴ iu⁵ ciong¹ zu¹‚ uang² do¹ zui² dang¹ zi².</p>\n<div id=\"footnotes\"><hr><div id=\"footnotelist\"><ol style=\"list-style: none; padding-left: 0; margin-left: 40px\"><li id=\"fn:1\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">1.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">「蒹」，荻草；「葭」，蘆草。<a href=\"#fnref:1\" rev=\"footnote\"> ↩</a></span></li><li id=\"fn:2\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">2.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">按今讀應爲「cang¹」，但根據韻腳應讀「cng¹」，且「倉」字甲子話亦讀作「cng¹」。<a href=\"#fnref:2\" rev=\"footnote\"> ↩</a></span></li><li id=\"fn:3\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">3.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">逆著河流走。<a href=\"#fnref:3\" rev=\"footnote\"> ↩</a></span></li><li id=\"fn:4\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">4.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">順著河流走。<a href=\"#fnref:4\" rev=\"footnote\"> ↩</a></span></li><li id=\"fn:5\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">5.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">蒼、霜、方、長、央，陽部。<a href=\"#fnref:5\" rev=\"footnote\"> ↩</a></span></li><li id=\"fn:6\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">6.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">露水未乾。<a href=\"#fnref:6\" rev=\"footnote\"> ↩</a></span></li><li id=\"fn:7\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">7.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">水草交接處，即岸邊。<a href=\"#fnref:7\" rev=\"footnote\"> ↩</a></span></li><li id=\"fn:8\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">8.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">水中小沙洲。<a href=\"#fnref:8\" rev=\"footnote\"> ↩</a></span></li><li id=\"fn:9\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">9.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">萋、晞、湄、躋、坻，脂部。<a href=\"#fnref:9\" rev=\"footnote\"> ↩</a></span></li><li id=\"fn:10\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">10.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">「已」完全。言露水還未完全乾。<a href=\"#fnref:10\" rev=\"footnote\"> ↩</a></span></li><li id=\"fn:11\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">11.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">岸邊。<a href=\"#fnref:11\" rev=\"footnote\"> ↩</a></span></li><li id=\"fn:12\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">12.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">水路彎曲。<a href=\"#fnref:12\" rev=\"footnote\"> ↩</a></span></li><li id=\"fn:13\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">13.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">水中小沙洲。<a href=\"#fnref:13\" rev=\"footnote\"> ↩</a></span></li><li id=\"fn:14\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">14.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">采、已、涘、右、沚，之部。<a href=\"#fnref:14\" rev=\"footnote\"> ↩</a></span></li></ol></div></div>","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/2020/10/06/language/min/sigêng-giamgia/202010060948.jpg\" alt></p>\n\n        <div id=\"aplayer-NKAKWcYv\" class=\"aplayer aplayer-tag-marker\" style=\"margin-bottom: 20px;\">\n            <pre class=\"aplayer-lrc-content\"></pre>\n        </div>\n        <script>\n          var ap = new APlayer({\n            element: document.getElementById(\"aplayer-NKAKWcYv\"),\n            narrow: false,\n            autoplay: false,\n            showlrc: false,\n            music: {\n              title: \"蒹葭\",\n              author: \"Hua\",\n              url: \"2020/10/06/language/min/sigêng-giamgia/蒹葭.m4a\",\n              pic: \"/music.png\",\n              lrc: \"\"\n            }\n          });\n          window.aplayers || (window.aplayers = []);\n          window.aplayers.push(ap);\n        </script>\n\n<p>蒹葭<sup id=\"fnref:1\"><a href=\"#fn:1\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    「蒹」，荻草；「葭」，蘆草。\">[1]</span></a></sup>蒼蒼<sup id=\"fnref:2\"><a href=\"#fn:2\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    按今讀應爲「cang¹」，但根據韻腳應讀「cng¹」，且「倉」字甲子話亦讀作「cng¹」。\">[2]</span></a></sup>，白露爲霜。所謂伊人，在水一方。溯洄<sup id=\"fnref:3\"><a href=\"#fn:3\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    逆著河流走。\">[3]</span></a></sup>從之，道阻且長。溯游<sup id=\"fnref:4\"><a href=\"#fn:4\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    順著河流走。\">[4]</span></a></sup>從之，宛在水中央。<sup id=\"fnref:5\"><a href=\"#fn:5\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    蒼、霜、方、長、央，陽部。\">[5]</span></a></sup><br>giam¹ gia¹ cng¹ cng¹, bêh⁸ lao³ ui⁵ sng¹. so² ui³ i¹ ring⁵‚ do¹ zui² zêg⁸ hng¹. sog⁴ hoi⁵ ciong⁵ zu¹‚ dao⁶ zo² cian² dng⁵. sog⁴ iu⁵ ciong⁵ zu¹‚ uang² do¹ zui² dang¹ ng¹.</p>\n<p>蒹葭萋萋，白露未晞<sup id=\"fnref:6\"><a href=\"#fn:6\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    露水未乾。\">[6]</span></a></sup>。所謂伊人，在水之湄<sup id=\"fnref:7\"><a href=\"#fn:7\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    水草交接處，即岸邊。\">[7]</span></a></sup>。溯洄從之，道阻且躋。溯游從之，宛在水中坻<sup id=\"fnref:8\"><a href=\"#fn:8\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    水中小沙洲。\">[8]</span></a></sup>。<sup id=\"fnref:9\"><a href=\"#fn:9\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    萋、晞、湄、躋、坻，脂部。\">[9]</span></a></sup><br>giam¹ gia¹ ci¹ ci¹‚ bêh⁸ lao³ bhoi⁷ hi¹. so² ui³ i¹ ring⁵‚ do¹ zui² zu¹ mi⁵. sog⁴ hoi⁵ ciong⁵ zu¹‚ dao⁶ zo² cian² zi³. sog⁴ iu⁵ ciong¹ zu¹‚ uang² do¹ zui² dang¹ di².</p>\n<p>蒹葭采采，白露未已<sup id=\"fnref:10\"><a href=\"#fn:10\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    「已」完全。言露水還未完全乾。\">[10]</span></a></sup>。所謂伊人，在水之涘<sup id=\"fnref:11\"><a href=\"#fn:11\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    岸邊。\">[11]</span></a></sup>。溯洄從之，道阻且右<sup id=\"fnref:12\"><a href=\"#fn:12\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    水路彎曲。\">[12]</span></a></sup>。溯游從之，宛在水中沚<sup id=\"fnref:13\"><a href=\"#fn:13\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    水中小沙洲。\">[13]</span></a></sup>。<sup id=\"fnref:14\"><a href=\"#fn:14\" rel=\"footnote\"><span class=\"hint--top hint--error hint--medium hint--rounded hint--bounce\" aria-label=\"    采、已、涘、右、沚，之部。\">[14]</span></a></sup>_ giam¹ gia¹ cai² cai²‚ bêh⁸ lao³ bhoi⁷ in². so² ui³ i¹ ring⁵‚ do¹ zui² zu¹ su⁶. sog⁴ hoi⁵ ciong⁵ zu¹‚ dao⁶ zo² cian² iu⁶. sog⁴ iu⁵ ciong¹ zu¹‚ uang² do¹ zui² dang¹ zi².</p>\n<div id=\"footnotes\"><hr><div id=\"footnotelist\"><ol style=\"list-style: none; padding-left: 0; margin-left: 40px\"><li id=\"fn:1\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">1.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">「蒹」，荻草；「葭」，蘆草。<a href=\"#fnref:1\" rev=\"footnote\"> ↩</a></span></li><li id=\"fn:2\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">2.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">按今讀應爲「cang¹」，但根據韻腳應讀「cng¹」，且「倉」字甲子話亦讀作「cng¹」。<a href=\"#fnref:2\" rev=\"footnote\"> ↩</a></span></li><li id=\"fn:3\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">3.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">逆著河流走。<a href=\"#fnref:3\" rev=\"footnote\"> ↩</a></span></li><li id=\"fn:4\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">4.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">順著河流走。<a href=\"#fnref:4\" rev=\"footnote\"> ↩</a></span></li><li id=\"fn:5\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">5.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">蒼、霜、方、長、央，陽部。<a href=\"#fnref:5\" rev=\"footnote\"> ↩</a></span></li><li id=\"fn:6\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">6.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">露水未乾。<a href=\"#fnref:6\" rev=\"footnote\"> ↩</a></span></li><li id=\"fn:7\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">7.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">水草交接處，即岸邊。<a href=\"#fnref:7\" rev=\"footnote\"> ↩</a></span></li><li id=\"fn:8\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">8.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">水中小沙洲。<a href=\"#fnref:8\" rev=\"footnote\"> ↩</a></span></li><li id=\"fn:9\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">9.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">萋、晞、湄、躋、坻，脂部。<a href=\"#fnref:9\" rev=\"footnote\"> ↩</a></span></li><li id=\"fn:10\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">10.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">「已」完全。言露水還未完全乾。<a href=\"#fnref:10\" rev=\"footnote\"> ↩</a></span></li><li id=\"fn:11\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">11.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">岸邊。<a href=\"#fnref:11\" rev=\"footnote\"> ↩</a></span></li><li id=\"fn:12\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">12.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">水路彎曲。<a href=\"#fnref:12\" rev=\"footnote\"> ↩</a></span></li><li id=\"fn:13\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">13.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">水中小沙洲。<a href=\"#fnref:13\" rev=\"footnote\"> ↩</a></span></li><li id=\"fn:14\"><span style=\"display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px\">14.</span><span style=\"display: inline-block; vertical-align: top; margin-left: 10px;\">采、已、涘、右、沚，之部。<a href=\"#fnref:14\" rev=\"footnote\"> ↩</a></span></li></ol></div></div>"},{"title":"携帯で日本語（手机上的日语）","p":"language/jp/keitai-de-nihongo.md","_content":"\n有一天，我把手机上的系统语言设定为日语，觉得读手机上的日语读起来很有趣。边读边猜边查字典认识了不少，于是整理了本文以飨读者。\n\n<!--more-->\n\n## 一、アプリ（应用程序）\n\n手机上的应用叫 「アプリ」(apuri)，取自英语「Application」前三个音节，日语中常有此类将常用英语引进时省略后面音节的做法，比如「パソコン」(pasokon) 取自英语「Personal Computer」第一个单词的前两个音节和后一个单词的第一个音节。值得注意的是，日语中有一个词语：「応用」（ouyou），虽然也是应用的意思，但可不是应用程序的缩写。这与汉语和英语的用法相异，汉语的「应用」和英语的「Application」都有投入实际使用和应用程序的意思。\n\n下面分 システムアプリ（系统应用）和ユーザーアプリ（用户应用）汇总了我手机上的一些 アプリ进行对比。\n\n### （一）システムアプリ（系统应用）\n\n| アプリ                   | Applications         | 应用程序      | 應用程式   |\n| ------------------------ | -------------------- | ------------- | ---------- |\n| アプリストア(apurisutoa) | App store            | 应用商店      | 應用商店   |\n| パスウードとアカウード   | Passwords & Accounts | 密码与账户    | 密碼與賬號 |\n| メール                   | Mail                 | 邮件          | 郵件       |\n| 連絡先（れんらくさき）   | Contacts             | 通讯录        | 聯絡資訊   |\n| カレンダー               | Calendar             | 日历          | 行事曆     |\n| メモ                     | Notes                | 备忘录        | 備忘錄     |\n| リマインダー             | Reminders            | 提醒事项      | 提醒事項   |\n| ボイスメモ               | Voice Memos          | 语言备忘录    | 語音備忘錄 |\n| 電話（でんわ）           | Phone                | 电话          | 電話       |\n| メッセージ               | Messages             | 信息          | 訊息       |\n| FaceTime                 | FaceTime             | FaceTime      | FaceTime   |\n| マップ                   | Maps                 | 地图          | 地圖       |\n| コンパス                 | Compass              | 指南针        | 指南針     |\n| 計測（けいそく）         | Measure              | 测距仪        | 測距儀     |\n| Safari                   | Safari               | Safari 浏览器 | Safari     |\n| 株価（かぶか）           | Stocks               | 股市          | 股市       |\n| ミュージック             | Music                | 音乐          | 音樂       |\n| ビデオ                   | Videos               | 视频          | 影片       |\n| 写真（しゃしん）         | Photos               | 照片          | 照片       |\n| カメラ                   | Camera               | 相机          | 相機       |\n| ブック                   | Books                | 图书          | 書籍       |\n\n备注：\n\n1. 股票：株式（かぶしき）\n2. 股市：株式市場（かぶしきしじょう）\n3. 股价：株価（かぶか）\n\n### （二）ユーザーアプリ（用户应用）\n\n| アプリ                          | Applications | 应用程序 | 應用程式 |\n| ------------------------------- | --------------- | -------- | -------- |\n| 微信 / ウェイシン \\| WeChat / ウィチャット | Wechat          | 微信     | 微信   |\n| QQ / キュキュ           | QQ              | QQ       | QQ     |\n| アリペイ                | Alipay          | 支付宝   | 支付寶 |\n| ビリビリ              | Bilibili        | 哔哩哔哩 | 嗶哩嗶哩 |\n| Google / グーグル       | Google          | 谷歌     | 谷歌   |\n| Kindle / キンドル | Kindle          | Kindle   | Kindle |\n| Chrome / クロム | Chrome | Chrome | Chrome |\n| YouTube / ユーチューブ | YouTube | YouTube | YouTube |\n| Gmail / ジメイル | Gmail | Gmail | Gmail |\n| Google フォト | Google Photo | Google相册 | Google相簿 |\n| 翻訳（ほにゃく） | Translate | 翻译 | 翻譯 |\n| Instagram / インスタグラム | Instagram | Instagram | Instagram |\n| WhatsApp / ワッツアップ | WhatsApp | WhatsApp | WhatsApp |\n| Wunderlist / ワンダーリスト | Wunderlist | 奇妙清单 | 奇妙清單 |\n| NetEase Music / ネットイース ミュージック | NetEase Music | 网易云音乐 | 網易云音樂 |\n| 好奇心日報（こうきしんにっぽう） | Qdaily | 好奇心日报 | 好奇心日報 |\n| Taobao / タオバオ | Taobao | 手机淘宝 | 手機淘寶 |\n| 京東 / ジンドン | JD | 京东 | 京東 |\n| 高德地図 / こうとくちず | Amap | 高德地图 | 高德地圖 |\n| 印象メモ | Evernote | 印象笔记 | 印象筆記 |\n| 招商銀行 / しょうしょうぎんこう | CMB | 招商银行 | 招商銀行 |\n| WeChat 読書（どくしょ 1）? | WeRead | 微信读书 | 微信讀書 |\n| Youku（ヨウク） | Youku | 优酷 | 優酷 |\n| 愛奇芸（アイキゲー） | IQiyi | 爱奇艺 | 愛奇藝 |\n\n## 二、設定（せってい）\n\n「設定」这个词语，不仅含义上，语音上也跟英语的「Setting」相似，很有意思。\n\n下面分「接続設定」（连接设置）、「フィードバック設定」（反馈设置）、「一般設定」（通用设置）和「ストアー設定」（商店设置）进行比较。\n\n### （一）接続（せつぞく）設定（连接设置）\n\n| 設定（せってい）                 | Settings         | 设置         | 設定     |\n| -------------------------------- | ---------------- | ------------ | -------- |\n| 機内モード（きない 1）           | Airplane Mode    | 飞行模式     | 飛航模式 |\n| WLAN                             | WLAN             | 无线网络     | WLAN     |\n| Bluetooth                        | Bluetooth        | 蓝牙         | 藍牙     |\n| モバイル通信（つうしん）         | Cellular         | 蜂窝移动网络 | 行動服務 |\n| インターネット共有（きょうゆう） | Personal Hotspot | 个人热点     | 個人熱點 |\n| VPN                              | VPN              | VPN          | VPN      |\n\n### （二）フィードバック設定（反馈设置）\n\n| 設定（せってい）             | Settings        | 设置         | 設定           |\n| ---------------------------- | --------------- | ------------ | -------------- |\n| 通知（つうち）               | Notifications   | 通知         | 通知           |\n| サウンドと触覚（しょっかく） | Sounds＆Haptics | 声音与触感   | 聲音與觸覺回饋 |\n| おやすみモード               | Do Not Disturb  | 勿扰模式     | 勿擾模式       |\n| スクリーンタイム             | Screen Time     | 屏幕使用时间 | 熒幕使用時間   |\n\n### （三）一般設定（通用设置）\n\n| 設定（せってい）                             | Settings              | 设置           | 設定           |\n| -------------------------------------------- | --------------------- | -------------- | -------------- |\n| 一般（いっぱん）                             | General               | 通用           | 一般           |\n| コントロールセンター                         | Control Center        | 控制中心       | 控制中心       |\n| 画面表示と明るさ（がめんひょうじとあかるさ） | Display ＆ Brightness | 显示与亮度     | 熒幕顯示與亮度 |\n| 壁紙（かべがみ）                             | Wallpaper             | 墙纸           | 背景圖片       |\n| Siriと検索（けんさく）                       | Siri ＆Search         | Siri 与搜索    | Siri 與搜尋    |\n| Face ID とパスコード                         | Face ID & Passcode    | 面容 ID 与密码 | Face ID 與密碼 |\n| 緊急SOS（きんきゅう）                        | Emergency SOS         | SOS 紧急联络   | SOS 緊急服務   |\n| バッテリー                                   | Battery               | 电池           | 電池           |\n| プライバシー                                 | Privacy               | 隐私           | 隱私權         |\n\n### （四）ストアー設定（商店设置）\n\n| 設定（せってい）          | Settings                | 设置                      | 設定                      |\n| ------------------------- | ----------------------- | ------------------------- | ------------------------- |\n| iTunes Store と App Store | iTunes Store＆App Store | iTunes Store 与 App Store | iTunes Store 與 App Store |\n| WalletとApple Pay         | Wallet＆Apple Pay       | 钱包与 Apple Pay          | 錢包與 Apple Pay          |\n\n## 三、操作（そうさ）\n\nアプリ 的操作是人机交互的重要部分，我们通过操作完成人机交互。常用的操作整理如下：\n\n| 日本語               | English | 汉语 | 漢語 |\n| -------------------- | ------- | ---- | ---- |\n| OK                   | OK      | 好的 | 好的 |\n| 確認                 | Comfirm | 确定 | 確定 |\n| キャンセル           | Cancel  | 取消 | 取消 |\n| 完了（かんりょう）   | Finish  | 完成 | 完成 |\n| オン                 | On      | 开启 | 開啟 |\n| オフ                 | Off     | 关闭 | 關閉 |\n| 消去（しょうきょ 1） | Clear   | 清除 | 清除 |\n| 検索（けんさく）     | Search  | 搜索 | 搜尋 |\n| 削除（さくじょ 1）   | Delete  | 删除 | 删除 |\n| 破棄（はき 1）       | Discard | 废弃 | 捨棄 |\n| 元に戻す（もとにもどす） | Undo | 撤消 | 復原 |\n| 開く（ひらく2）      | Open    | 打开 | 打開 |\n| 閉じる（とじる 2）   | Close   | 关闭 | 關閉 |\n| 編集（へんしゅう）   | Edit    | 编辑 | 編輯 |\n| 表示（ひょうじ） | View | 查看 | 檢視 |\n| 送る（おくる） | Send    | 发送 | 發送 |\n| 追加（ついか） | Add | 添加 | 加入 |\n| 新着（しんちゃく） | New | 新增 | 新增 |\n| 報告（ほうこく） | Report | 举报 | 回報 |\n| マーク | Mark | 标记 | 標示 |\n| 再生（さいせい） | Play | 播放 | 播放 |\n| 一時停止（いちじていし） | Pause | 暂停 | 暫停 |\n| 停止（ていし） | Stop | 停止 | 停止 |\n| 登録（とうろく） | Sign Up | 注册 | 註冊 |\n| ログイン | Sign In / Log In | 登录 | 登入 |\n| ログアウト | Sign Out / Log Out | 退出 | 登出 / 退出 |\n\n","source":"_posts/language/jp/keitai-de-nihongo.md","raw":"---\ntitle: 携帯で日本語（手机上的日语）\np: language/jp/keitai-de-nihongo.md\ntags:\n- 日本語\n---\n\n有一天，我把手机上的系统语言设定为日语，觉得读手机上的日语读起来很有趣。边读边猜边查字典认识了不少，于是整理了本文以飨读者。\n\n<!--more-->\n\n## 一、アプリ（应用程序）\n\n手机上的应用叫 「アプリ」(apuri)，取自英语「Application」前三个音节，日语中常有此类将常用英语引进时省略后面音节的做法，比如「パソコン」(pasokon) 取自英语「Personal Computer」第一个单词的前两个音节和后一个单词的第一个音节。值得注意的是，日语中有一个词语：「応用」（ouyou），虽然也是应用的意思，但可不是应用程序的缩写。这与汉语和英语的用法相异，汉语的「应用」和英语的「Application」都有投入实际使用和应用程序的意思。\n\n下面分 システムアプリ（系统应用）和ユーザーアプリ（用户应用）汇总了我手机上的一些 アプリ进行对比。\n\n### （一）システムアプリ（系统应用）\n\n| アプリ                   | Applications         | 应用程序      | 應用程式   |\n| ------------------------ | -------------------- | ------------- | ---------- |\n| アプリストア(apurisutoa) | App store            | 应用商店      | 應用商店   |\n| パスウードとアカウード   | Passwords & Accounts | 密码与账户    | 密碼與賬號 |\n| メール                   | Mail                 | 邮件          | 郵件       |\n| 連絡先（れんらくさき）   | Contacts             | 通讯录        | 聯絡資訊   |\n| カレンダー               | Calendar             | 日历          | 行事曆     |\n| メモ                     | Notes                | 备忘录        | 備忘錄     |\n| リマインダー             | Reminders            | 提醒事项      | 提醒事項   |\n| ボイスメモ               | Voice Memos          | 语言备忘录    | 語音備忘錄 |\n| 電話（でんわ）           | Phone                | 电话          | 電話       |\n| メッセージ               | Messages             | 信息          | 訊息       |\n| FaceTime                 | FaceTime             | FaceTime      | FaceTime   |\n| マップ                   | Maps                 | 地图          | 地圖       |\n| コンパス                 | Compass              | 指南针        | 指南針     |\n| 計測（けいそく）         | Measure              | 测距仪        | 測距儀     |\n| Safari                   | Safari               | Safari 浏览器 | Safari     |\n| 株価（かぶか）           | Stocks               | 股市          | 股市       |\n| ミュージック             | Music                | 音乐          | 音樂       |\n| ビデオ                   | Videos               | 视频          | 影片       |\n| 写真（しゃしん）         | Photos               | 照片          | 照片       |\n| カメラ                   | Camera               | 相机          | 相機       |\n| ブック                   | Books                | 图书          | 書籍       |\n\n备注：\n\n1. 股票：株式（かぶしき）\n2. 股市：株式市場（かぶしきしじょう）\n3. 股价：株価（かぶか）\n\n### （二）ユーザーアプリ（用户应用）\n\n| アプリ                          | Applications | 应用程序 | 應用程式 |\n| ------------------------------- | --------------- | -------- | -------- |\n| 微信 / ウェイシン \\| WeChat / ウィチャット | Wechat          | 微信     | 微信   |\n| QQ / キュキュ           | QQ              | QQ       | QQ     |\n| アリペイ                | Alipay          | 支付宝   | 支付寶 |\n| ビリビリ              | Bilibili        | 哔哩哔哩 | 嗶哩嗶哩 |\n| Google / グーグル       | Google          | 谷歌     | 谷歌   |\n| Kindle / キンドル | Kindle          | Kindle   | Kindle |\n| Chrome / クロム | Chrome | Chrome | Chrome |\n| YouTube / ユーチューブ | YouTube | YouTube | YouTube |\n| Gmail / ジメイル | Gmail | Gmail | Gmail |\n| Google フォト | Google Photo | Google相册 | Google相簿 |\n| 翻訳（ほにゃく） | Translate | 翻译 | 翻譯 |\n| Instagram / インスタグラム | Instagram | Instagram | Instagram |\n| WhatsApp / ワッツアップ | WhatsApp | WhatsApp | WhatsApp |\n| Wunderlist / ワンダーリスト | Wunderlist | 奇妙清单 | 奇妙清單 |\n| NetEase Music / ネットイース ミュージック | NetEase Music | 网易云音乐 | 網易云音樂 |\n| 好奇心日報（こうきしんにっぽう） | Qdaily | 好奇心日报 | 好奇心日報 |\n| Taobao / タオバオ | Taobao | 手机淘宝 | 手機淘寶 |\n| 京東 / ジンドン | JD | 京东 | 京東 |\n| 高德地図 / こうとくちず | Amap | 高德地图 | 高德地圖 |\n| 印象メモ | Evernote | 印象笔记 | 印象筆記 |\n| 招商銀行 / しょうしょうぎんこう | CMB | 招商银行 | 招商銀行 |\n| WeChat 読書（どくしょ 1）? | WeRead | 微信读书 | 微信讀書 |\n| Youku（ヨウク） | Youku | 优酷 | 優酷 |\n| 愛奇芸（アイキゲー） | IQiyi | 爱奇艺 | 愛奇藝 |\n\n## 二、設定（せってい）\n\n「設定」这个词语，不仅含义上，语音上也跟英语的「Setting」相似，很有意思。\n\n下面分「接続設定」（连接设置）、「フィードバック設定」（反馈设置）、「一般設定」（通用设置）和「ストアー設定」（商店设置）进行比较。\n\n### （一）接続（せつぞく）設定（连接设置）\n\n| 設定（せってい）                 | Settings         | 设置         | 設定     |\n| -------------------------------- | ---------------- | ------------ | -------- |\n| 機内モード（きない 1）           | Airplane Mode    | 飞行模式     | 飛航模式 |\n| WLAN                             | WLAN             | 无线网络     | WLAN     |\n| Bluetooth                        | Bluetooth        | 蓝牙         | 藍牙     |\n| モバイル通信（つうしん）         | Cellular         | 蜂窝移动网络 | 行動服務 |\n| インターネット共有（きょうゆう） | Personal Hotspot | 个人热点     | 個人熱點 |\n| VPN                              | VPN              | VPN          | VPN      |\n\n### （二）フィードバック設定（反馈设置）\n\n| 設定（せってい）             | Settings        | 设置         | 設定           |\n| ---------------------------- | --------------- | ------------ | -------------- |\n| 通知（つうち）               | Notifications   | 通知         | 通知           |\n| サウンドと触覚（しょっかく） | Sounds＆Haptics | 声音与触感   | 聲音與觸覺回饋 |\n| おやすみモード               | Do Not Disturb  | 勿扰模式     | 勿擾模式       |\n| スクリーンタイム             | Screen Time     | 屏幕使用时间 | 熒幕使用時間   |\n\n### （三）一般設定（通用设置）\n\n| 設定（せってい）                             | Settings              | 设置           | 設定           |\n| -------------------------------------------- | --------------------- | -------------- | -------------- |\n| 一般（いっぱん）                             | General               | 通用           | 一般           |\n| コントロールセンター                         | Control Center        | 控制中心       | 控制中心       |\n| 画面表示と明るさ（がめんひょうじとあかるさ） | Display ＆ Brightness | 显示与亮度     | 熒幕顯示與亮度 |\n| 壁紙（かべがみ）                             | Wallpaper             | 墙纸           | 背景圖片       |\n| Siriと検索（けんさく）                       | Siri ＆Search         | Siri 与搜索    | Siri 與搜尋    |\n| Face ID とパスコード                         | Face ID & Passcode    | 面容 ID 与密码 | Face ID 與密碼 |\n| 緊急SOS（きんきゅう）                        | Emergency SOS         | SOS 紧急联络   | SOS 緊急服務   |\n| バッテリー                                   | Battery               | 电池           | 電池           |\n| プライバシー                                 | Privacy               | 隐私           | 隱私權         |\n\n### （四）ストアー設定（商店设置）\n\n| 設定（せってい）          | Settings                | 设置                      | 設定                      |\n| ------------------------- | ----------------------- | ------------------------- | ------------------------- |\n| iTunes Store と App Store | iTunes Store＆App Store | iTunes Store 与 App Store | iTunes Store 與 App Store |\n| WalletとApple Pay         | Wallet＆Apple Pay       | 钱包与 Apple Pay          | 錢包與 Apple Pay          |\n\n## 三、操作（そうさ）\n\nアプリ 的操作是人机交互的重要部分，我们通过操作完成人机交互。常用的操作整理如下：\n\n| 日本語               | English | 汉语 | 漢語 |\n| -------------------- | ------- | ---- | ---- |\n| OK                   | OK      | 好的 | 好的 |\n| 確認                 | Comfirm | 确定 | 確定 |\n| キャンセル           | Cancel  | 取消 | 取消 |\n| 完了（かんりょう）   | Finish  | 完成 | 完成 |\n| オン                 | On      | 开启 | 開啟 |\n| オフ                 | Off     | 关闭 | 關閉 |\n| 消去（しょうきょ 1） | Clear   | 清除 | 清除 |\n| 検索（けんさく）     | Search  | 搜索 | 搜尋 |\n| 削除（さくじょ 1）   | Delete  | 删除 | 删除 |\n| 破棄（はき 1）       | Discard | 废弃 | 捨棄 |\n| 元に戻す（もとにもどす） | Undo | 撤消 | 復原 |\n| 開く（ひらく2）      | Open    | 打开 | 打開 |\n| 閉じる（とじる 2）   | Close   | 关闭 | 關閉 |\n| 編集（へんしゅう）   | Edit    | 编辑 | 編輯 |\n| 表示（ひょうじ） | View | 查看 | 檢視 |\n| 送る（おくる） | Send    | 发送 | 發送 |\n| 追加（ついか） | Add | 添加 | 加入 |\n| 新着（しんちゃく） | New | 新增 | 新增 |\n| 報告（ほうこく） | Report | 举报 | 回報 |\n| マーク | Mark | 标记 | 標示 |\n| 再生（さいせい） | Play | 播放 | 播放 |\n| 一時停止（いちじていし） | Pause | 暂停 | 暫停 |\n| 停止（ていし） | Stop | 停止 | 停止 |\n| 登録（とうろく） | Sign Up | 注册 | 註冊 |\n| ログイン | Sign In / Log In | 登录 | 登入 |\n| ログアウト | Sign Out / Log Out | 退出 | 登出 / 退出 |\n\n","slug":"language/jp/keitai-de-nihongo","published":1,"date":"2020-10-04T07:48:34.830Z","updated":"2020-10-04T10:43:03.780Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cki72psxf0009slw8o509sqts","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css\"><p>有一天，我把手机上的系统语言设定为日语，觉得读手机上的日语读起来很有趣。边读边猜边查字典认识了不少，于是整理了本文以飨读者。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"一、アプリ（应用程序）\"><a href=\"#一、アプリ（应用程序）\" class=\"headerlink\" title=\"一、アプリ（应用程序）\"></a>一、アプリ（应用程序）</h2><p>手机上的应用叫 「アプリ」(apuri)，取自英语「Application」前三个音节，日语中常有此类将常用英语引进时省略后面音节的做法，比如「パソコン」(pasokon) 取自英语「Personal Computer」第一个单词的前两个音节和后一个单词的第一个音节。值得注意的是，日语中有一个词语：「応用」（ouyou），虽然也是应用的意思，但可不是应用程序的缩写。这与汉语和英语的用法相异，汉语的「应用」和英语的「Application」都有投入实际使用和应用程序的意思。</p>\n<p>下面分 システムアプリ（系统应用）和ユーザーアプリ（用户应用）汇总了我手机上的一些 アプリ进行对比。</p>\n<h3 id=\"（一）システムアプリ（系统应用）\"><a href=\"#（一）システムアプリ（系统应用）\" class=\"headerlink\" title=\"（一）システムアプリ（系统应用）\"></a>（一）システムアプリ（系统应用）</h3><table>\n<thead>\n<tr>\n<th>アプリ</th>\n<th>Applications</th>\n<th>应用程序</th>\n<th>應用程式</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>アプリストア(apurisutoa)</td>\n<td>App store</td>\n<td>应用商店</td>\n<td>應用商店</td>\n</tr>\n<tr>\n<td>パスウードとアカウード</td>\n<td>Passwords &amp; Accounts</td>\n<td>密码与账户</td>\n<td>密碼與賬號</td>\n</tr>\n<tr>\n<td>メール</td>\n<td>Mail</td>\n<td>邮件</td>\n<td>郵件</td>\n</tr>\n<tr>\n<td>連絡先（れんらくさき）</td>\n<td>Contacts</td>\n<td>通讯录</td>\n<td>聯絡資訊</td>\n</tr>\n<tr>\n<td>カレンダー</td>\n<td>Calendar</td>\n<td>日历</td>\n<td>行事曆</td>\n</tr>\n<tr>\n<td>メモ</td>\n<td>Notes</td>\n<td>备忘录</td>\n<td>備忘錄</td>\n</tr>\n<tr>\n<td>リマインダー</td>\n<td>Reminders</td>\n<td>提醒事项</td>\n<td>提醒事項</td>\n</tr>\n<tr>\n<td>ボイスメモ</td>\n<td>Voice Memos</td>\n<td>语言备忘录</td>\n<td>語音備忘錄</td>\n</tr>\n<tr>\n<td>電話（でんわ）</td>\n<td>Phone</td>\n<td>电话</td>\n<td>電話</td>\n</tr>\n<tr>\n<td>メッセージ</td>\n<td>Messages</td>\n<td>信息</td>\n<td>訊息</td>\n</tr>\n<tr>\n<td>FaceTime</td>\n<td>FaceTime</td>\n<td>FaceTime</td>\n<td>FaceTime</td>\n</tr>\n<tr>\n<td>マップ</td>\n<td>Maps</td>\n<td>地图</td>\n<td>地圖</td>\n</tr>\n<tr>\n<td>コンパス</td>\n<td>Compass</td>\n<td>指南针</td>\n<td>指南針</td>\n</tr>\n<tr>\n<td>計測（けいそく）</td>\n<td>Measure</td>\n<td>测距仪</td>\n<td>測距儀</td>\n</tr>\n<tr>\n<td>Safari</td>\n<td>Safari</td>\n<td>Safari 浏览器</td>\n<td>Safari</td>\n</tr>\n<tr>\n<td>株価（かぶか）</td>\n<td>Stocks</td>\n<td>股市</td>\n<td>股市</td>\n</tr>\n<tr>\n<td>ミュージック</td>\n<td>Music</td>\n<td>音乐</td>\n<td>音樂</td>\n</tr>\n<tr>\n<td>ビデオ</td>\n<td>Videos</td>\n<td>视频</td>\n<td>影片</td>\n</tr>\n<tr>\n<td>写真（しゃしん）</td>\n<td>Photos</td>\n<td>照片</td>\n<td>照片</td>\n</tr>\n<tr>\n<td>カメラ</td>\n<td>Camera</td>\n<td>相机</td>\n<td>相機</td>\n</tr>\n<tr>\n<td>ブック</td>\n<td>Books</td>\n<td>图书</td>\n<td>書籍</td>\n</tr>\n</tbody></table>\n<p>备注：</p>\n<ol>\n<li>股票：株式（かぶしき）</li>\n<li>股市：株式市場（かぶしきしじょう）</li>\n<li>股价：株価（かぶか）</li>\n</ol>\n<h3 id=\"（二）ユーザーアプリ（用户应用）\"><a href=\"#（二）ユーザーアプリ（用户应用）\" class=\"headerlink\" title=\"（二）ユーザーアプリ（用户应用）\"></a>（二）ユーザーアプリ（用户应用）</h3><table>\n<thead>\n<tr>\n<th>アプリ</th>\n<th>Applications</th>\n<th>应用程序</th>\n<th>應用程式</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>微信 / ウェイシン | WeChat / ウィチャット</td>\n<td>Wechat</td>\n<td>微信</td>\n<td>微信</td>\n</tr>\n<tr>\n<td>QQ / キュキュ</td>\n<td>QQ</td>\n<td>QQ</td>\n<td>QQ</td>\n</tr>\n<tr>\n<td>アリペイ</td>\n<td>Alipay</td>\n<td>支付宝</td>\n<td>支付寶</td>\n</tr>\n<tr>\n<td>ビリビリ</td>\n<td>Bilibili</td>\n<td>哔哩哔哩</td>\n<td>嗶哩嗶哩</td>\n</tr>\n<tr>\n<td>Google / グーグル</td>\n<td>Google</td>\n<td>谷歌</td>\n<td>谷歌</td>\n</tr>\n<tr>\n<td>Kindle / キンドル</td>\n<td>Kindle</td>\n<td>Kindle</td>\n<td>Kindle</td>\n</tr>\n<tr>\n<td>Chrome / クロム</td>\n<td>Chrome</td>\n<td>Chrome</td>\n<td>Chrome</td>\n</tr>\n<tr>\n<td>YouTube / ユーチューブ</td>\n<td>YouTube</td>\n<td>YouTube</td>\n<td>YouTube</td>\n</tr>\n<tr>\n<td>Gmail / ジメイル</td>\n<td>Gmail</td>\n<td>Gmail</td>\n<td>Gmail</td>\n</tr>\n<tr>\n<td>Google フォト</td>\n<td>Google Photo</td>\n<td>Google相册</td>\n<td>Google相簿</td>\n</tr>\n<tr>\n<td>翻訳（ほにゃく）</td>\n<td>Translate</td>\n<td>翻译</td>\n<td>翻譯</td>\n</tr>\n<tr>\n<td>Instagram / インスタグラム</td>\n<td>Instagram</td>\n<td>Instagram</td>\n<td>Instagram</td>\n</tr>\n<tr>\n<td>WhatsApp / ワッツアップ</td>\n<td>WhatsApp</td>\n<td>WhatsApp</td>\n<td>WhatsApp</td>\n</tr>\n<tr>\n<td>Wunderlist / ワンダーリスト</td>\n<td>Wunderlist</td>\n<td>奇妙清单</td>\n<td>奇妙清單</td>\n</tr>\n<tr>\n<td>NetEase Music / ネットイース ミュージック</td>\n<td>NetEase Music</td>\n<td>网易云音乐</td>\n<td>網易云音樂</td>\n</tr>\n<tr>\n<td>好奇心日報（こうきしんにっぽう）</td>\n<td>Qdaily</td>\n<td>好奇心日报</td>\n<td>好奇心日報</td>\n</tr>\n<tr>\n<td>Taobao / タオバオ</td>\n<td>Taobao</td>\n<td>手机淘宝</td>\n<td>手機淘寶</td>\n</tr>\n<tr>\n<td>京東 / ジンドン</td>\n<td>JD</td>\n<td>京东</td>\n<td>京東</td>\n</tr>\n<tr>\n<td>高德地図 / こうとくちず</td>\n<td>Amap</td>\n<td>高德地图</td>\n<td>高德地圖</td>\n</tr>\n<tr>\n<td>印象メモ</td>\n<td>Evernote</td>\n<td>印象笔记</td>\n<td>印象筆記</td>\n</tr>\n<tr>\n<td>招商銀行 / しょうしょうぎんこう</td>\n<td>CMB</td>\n<td>招商银行</td>\n<td>招商銀行</td>\n</tr>\n<tr>\n<td>WeChat 読書（どくしょ 1）?</td>\n<td>WeRead</td>\n<td>微信读书</td>\n<td>微信讀書</td>\n</tr>\n<tr>\n<td>Youku（ヨウク）</td>\n<td>Youku</td>\n<td>优酷</td>\n<td>優酷</td>\n</tr>\n<tr>\n<td>愛奇芸（アイキゲー）</td>\n<td>IQiyi</td>\n<td>爱奇艺</td>\n<td>愛奇藝</td>\n</tr>\n</tbody></table>\n<h2 id=\"二、設定（せってい）\"><a href=\"#二、設定（せってい）\" class=\"headerlink\" title=\"二、設定（せってい）\"></a>二、設定（せってい）</h2><p>「設定」这个词语，不仅含义上，语音上也跟英语的「Setting」相似，很有意思。</p>\n<p>下面分「接続設定」（连接设置）、「フィードバック設定」（反馈设置）、「一般設定」（通用设置）和「ストアー設定」（商店设置）进行比较。</p>\n<h3 id=\"（一）接続（せつぞく）設定（连接设置）\"><a href=\"#（一）接続（せつぞく）設定（连接设置）\" class=\"headerlink\" title=\"（一）接続（せつぞく）設定（连接设置）\"></a>（一）接続（せつぞく）設定（连接设置）</h3><table>\n<thead>\n<tr>\n<th>設定（せってい）</th>\n<th>Settings</th>\n<th>设置</th>\n<th>設定</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>機内モード（きない 1）</td>\n<td>Airplane Mode</td>\n<td>飞行模式</td>\n<td>飛航模式</td>\n</tr>\n<tr>\n<td>WLAN</td>\n<td>WLAN</td>\n<td>无线网络</td>\n<td>WLAN</td>\n</tr>\n<tr>\n<td>Bluetooth</td>\n<td>Bluetooth</td>\n<td>蓝牙</td>\n<td>藍牙</td>\n</tr>\n<tr>\n<td>モバイル通信（つうしん）</td>\n<td>Cellular</td>\n<td>蜂窝移动网络</td>\n<td>行動服務</td>\n</tr>\n<tr>\n<td>インターネット共有（きょうゆう）</td>\n<td>Personal Hotspot</td>\n<td>个人热点</td>\n<td>個人熱點</td>\n</tr>\n<tr>\n<td>VPN</td>\n<td>VPN</td>\n<td>VPN</td>\n<td>VPN</td>\n</tr>\n</tbody></table>\n<h3 id=\"（二）フィードバック設定（反馈设置）\"><a href=\"#（二）フィードバック設定（反馈设置）\" class=\"headerlink\" title=\"（二）フィードバック設定（反馈设置）\"></a>（二）フィードバック設定（反馈设置）</h3><table>\n<thead>\n<tr>\n<th>設定（せってい）</th>\n<th>Settings</th>\n<th>设置</th>\n<th>設定</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>通知（つうち）</td>\n<td>Notifications</td>\n<td>通知</td>\n<td>通知</td>\n</tr>\n<tr>\n<td>サウンドと触覚（しょっかく）</td>\n<td>Sounds＆Haptics</td>\n<td>声音与触感</td>\n<td>聲音與觸覺回饋</td>\n</tr>\n<tr>\n<td>おやすみモード</td>\n<td>Do Not Disturb</td>\n<td>勿扰模式</td>\n<td>勿擾模式</td>\n</tr>\n<tr>\n<td>スクリーンタイム</td>\n<td>Screen Time</td>\n<td>屏幕使用时间</td>\n<td>熒幕使用時間</td>\n</tr>\n</tbody></table>\n<h3 id=\"（三）一般設定（通用设置）\"><a href=\"#（三）一般設定（通用设置）\" class=\"headerlink\" title=\"（三）一般設定（通用设置）\"></a>（三）一般設定（通用设置）</h3><table>\n<thead>\n<tr>\n<th>設定（せってい）</th>\n<th>Settings</th>\n<th>设置</th>\n<th>設定</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>一般（いっぱん）</td>\n<td>General</td>\n<td>通用</td>\n<td>一般</td>\n</tr>\n<tr>\n<td>コントロールセンター</td>\n<td>Control Center</td>\n<td>控制中心</td>\n<td>控制中心</td>\n</tr>\n<tr>\n<td>画面表示と明るさ（がめんひょうじとあかるさ）</td>\n<td>Display ＆ Brightness</td>\n<td>显示与亮度</td>\n<td>熒幕顯示與亮度</td>\n</tr>\n<tr>\n<td>壁紙（かべがみ）</td>\n<td>Wallpaper</td>\n<td>墙纸</td>\n<td>背景圖片</td>\n</tr>\n<tr>\n<td>Siriと検索（けんさく）</td>\n<td>Siri ＆Search</td>\n<td>Siri 与搜索</td>\n<td>Siri 與搜尋</td>\n</tr>\n<tr>\n<td>Face ID とパスコード</td>\n<td>Face ID &amp; Passcode</td>\n<td>面容 ID 与密码</td>\n<td>Face ID 與密碼</td>\n</tr>\n<tr>\n<td>緊急SOS（きんきゅう）</td>\n<td>Emergency SOS</td>\n<td>SOS 紧急联络</td>\n<td>SOS 緊急服務</td>\n</tr>\n<tr>\n<td>バッテリー</td>\n<td>Battery</td>\n<td>电池</td>\n<td>電池</td>\n</tr>\n<tr>\n<td>プライバシー</td>\n<td>Privacy</td>\n<td>隐私</td>\n<td>隱私權</td>\n</tr>\n</tbody></table>\n<h3 id=\"（四）ストアー設定（商店设置）\"><a href=\"#（四）ストアー設定（商店设置）\" class=\"headerlink\" title=\"（四）ストアー設定（商店设置）\"></a>（四）ストアー設定（商店设置）</h3><table>\n<thead>\n<tr>\n<th>設定（せってい）</th>\n<th>Settings</th>\n<th>设置</th>\n<th>設定</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>iTunes Store と App Store</td>\n<td>iTunes Store＆App Store</td>\n<td>iTunes Store 与 App Store</td>\n<td>iTunes Store 與 App Store</td>\n</tr>\n<tr>\n<td>WalletとApple Pay</td>\n<td>Wallet＆Apple Pay</td>\n<td>钱包与 Apple Pay</td>\n<td>錢包與 Apple Pay</td>\n</tr>\n</tbody></table>\n<h2 id=\"三、操作（そうさ）\"><a href=\"#三、操作（そうさ）\" class=\"headerlink\" title=\"三、操作（そうさ）\"></a>三、操作（そうさ）</h2><p>アプリ 的操作是人机交互的重要部分，我们通过操作完成人机交互。常用的操作整理如下：</p>\n<table>\n<thead>\n<tr>\n<th>日本語</th>\n<th>English</th>\n<th>汉语</th>\n<th>漢語</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>OK</td>\n<td>OK</td>\n<td>好的</td>\n<td>好的</td>\n</tr>\n<tr>\n<td>確認</td>\n<td>Comfirm</td>\n<td>确定</td>\n<td>確定</td>\n</tr>\n<tr>\n<td>キャンセル</td>\n<td>Cancel</td>\n<td>取消</td>\n<td>取消</td>\n</tr>\n<tr>\n<td>完了（かんりょう）</td>\n<td>Finish</td>\n<td>完成</td>\n<td>完成</td>\n</tr>\n<tr>\n<td>オン</td>\n<td>On</td>\n<td>开启</td>\n<td>開啟</td>\n</tr>\n<tr>\n<td>オフ</td>\n<td>Off</td>\n<td>关闭</td>\n<td>關閉</td>\n</tr>\n<tr>\n<td>消去（しょうきょ 1）</td>\n<td>Clear</td>\n<td>清除</td>\n<td>清除</td>\n</tr>\n<tr>\n<td>検索（けんさく）</td>\n<td>Search</td>\n<td>搜索</td>\n<td>搜尋</td>\n</tr>\n<tr>\n<td>削除（さくじょ 1）</td>\n<td>Delete</td>\n<td>删除</td>\n<td>删除</td>\n</tr>\n<tr>\n<td>破棄（はき 1）</td>\n<td>Discard</td>\n<td>废弃</td>\n<td>捨棄</td>\n</tr>\n<tr>\n<td>元に戻す（もとにもどす）</td>\n<td>Undo</td>\n<td>撤消</td>\n<td>復原</td>\n</tr>\n<tr>\n<td>開く（ひらく2）</td>\n<td>Open</td>\n<td>打开</td>\n<td>打開</td>\n</tr>\n<tr>\n<td>閉じる（とじる 2）</td>\n<td>Close</td>\n<td>关闭</td>\n<td>關閉</td>\n</tr>\n<tr>\n<td>編集（へんしゅう）</td>\n<td>Edit</td>\n<td>编辑</td>\n<td>編輯</td>\n</tr>\n<tr>\n<td>表示（ひょうじ）</td>\n<td>View</td>\n<td>查看</td>\n<td>檢視</td>\n</tr>\n<tr>\n<td>送る（おくる）</td>\n<td>Send</td>\n<td>发送</td>\n<td>發送</td>\n</tr>\n<tr>\n<td>追加（ついか）</td>\n<td>Add</td>\n<td>添加</td>\n<td>加入</td>\n</tr>\n<tr>\n<td>新着（しんちゃく）</td>\n<td>New</td>\n<td>新增</td>\n<td>新增</td>\n</tr>\n<tr>\n<td>報告（ほうこく）</td>\n<td>Report</td>\n<td>举报</td>\n<td>回報</td>\n</tr>\n<tr>\n<td>マーク</td>\n<td>Mark</td>\n<td>标记</td>\n<td>標示</td>\n</tr>\n<tr>\n<td>再生（さいせい）</td>\n<td>Play</td>\n<td>播放</td>\n<td>播放</td>\n</tr>\n<tr>\n<td>一時停止（いちじていし）</td>\n<td>Pause</td>\n<td>暂停</td>\n<td>暫停</td>\n</tr>\n<tr>\n<td>停止（ていし）</td>\n<td>Stop</td>\n<td>停止</td>\n<td>停止</td>\n</tr>\n<tr>\n<td>登録（とうろく）</td>\n<td>Sign Up</td>\n<td>注册</td>\n<td>註冊</td>\n</tr>\n<tr>\n<td>ログイン</td>\n<td>Sign In / Log In</td>\n<td>登录</td>\n<td>登入</td>\n</tr>\n<tr>\n<td>ログアウト</td>\n<td>Sign Out / Log Out</td>\n<td>退出</td>\n<td>登出 / 退出</td>\n</tr>\n</tbody></table>\n","site":{"data":{}},"excerpt":"<p>有一天，我把手机上的系统语言设定为日语，觉得读手机上的日语读起来很有趣。边读边猜边查字典认识了不少，于是整理了本文以飨读者。</p>","more":"<h2 id=\"一、アプリ（应用程序）\"><a href=\"#一、アプリ（应用程序）\" class=\"headerlink\" title=\"一、アプリ（应用程序）\"></a>一、アプリ（应用程序）</h2><p>手机上的应用叫 「アプリ」(apuri)，取自英语「Application」前三个音节，日语中常有此类将常用英语引进时省略后面音节的做法，比如「パソコン」(pasokon) 取自英语「Personal Computer」第一个单词的前两个音节和后一个单词的第一个音节。值得注意的是，日语中有一个词语：「応用」（ouyou），虽然也是应用的意思，但可不是应用程序的缩写。这与汉语和英语的用法相异，汉语的「应用」和英语的「Application」都有投入实际使用和应用程序的意思。</p>\n<p>下面分 システムアプリ（系统应用）和ユーザーアプリ（用户应用）汇总了我手机上的一些 アプリ进行对比。</p>\n<h3 id=\"（一）システムアプリ（系统应用）\"><a href=\"#（一）システムアプリ（系统应用）\" class=\"headerlink\" title=\"（一）システムアプリ（系统应用）\"></a>（一）システムアプリ（系统应用）</h3><table>\n<thead>\n<tr>\n<th>アプリ</th>\n<th>Applications</th>\n<th>应用程序</th>\n<th>應用程式</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>アプリストア(apurisutoa)</td>\n<td>App store</td>\n<td>应用商店</td>\n<td>應用商店</td>\n</tr>\n<tr>\n<td>パスウードとアカウード</td>\n<td>Passwords &amp; Accounts</td>\n<td>密码与账户</td>\n<td>密碼與賬號</td>\n</tr>\n<tr>\n<td>メール</td>\n<td>Mail</td>\n<td>邮件</td>\n<td>郵件</td>\n</tr>\n<tr>\n<td>連絡先（れんらくさき）</td>\n<td>Contacts</td>\n<td>通讯录</td>\n<td>聯絡資訊</td>\n</tr>\n<tr>\n<td>カレンダー</td>\n<td>Calendar</td>\n<td>日历</td>\n<td>行事曆</td>\n</tr>\n<tr>\n<td>メモ</td>\n<td>Notes</td>\n<td>备忘录</td>\n<td>備忘錄</td>\n</tr>\n<tr>\n<td>リマインダー</td>\n<td>Reminders</td>\n<td>提醒事项</td>\n<td>提醒事項</td>\n</tr>\n<tr>\n<td>ボイスメモ</td>\n<td>Voice Memos</td>\n<td>语言备忘录</td>\n<td>語音備忘錄</td>\n</tr>\n<tr>\n<td>電話（でんわ）</td>\n<td>Phone</td>\n<td>电话</td>\n<td>電話</td>\n</tr>\n<tr>\n<td>メッセージ</td>\n<td>Messages</td>\n<td>信息</td>\n<td>訊息</td>\n</tr>\n<tr>\n<td>FaceTime</td>\n<td>FaceTime</td>\n<td>FaceTime</td>\n<td>FaceTime</td>\n</tr>\n<tr>\n<td>マップ</td>\n<td>Maps</td>\n<td>地图</td>\n<td>地圖</td>\n</tr>\n<tr>\n<td>コンパス</td>\n<td>Compass</td>\n<td>指南针</td>\n<td>指南針</td>\n</tr>\n<tr>\n<td>計測（けいそく）</td>\n<td>Measure</td>\n<td>测距仪</td>\n<td>測距儀</td>\n</tr>\n<tr>\n<td>Safari</td>\n<td>Safari</td>\n<td>Safari 浏览器</td>\n<td>Safari</td>\n</tr>\n<tr>\n<td>株価（かぶか）</td>\n<td>Stocks</td>\n<td>股市</td>\n<td>股市</td>\n</tr>\n<tr>\n<td>ミュージック</td>\n<td>Music</td>\n<td>音乐</td>\n<td>音樂</td>\n</tr>\n<tr>\n<td>ビデオ</td>\n<td>Videos</td>\n<td>视频</td>\n<td>影片</td>\n</tr>\n<tr>\n<td>写真（しゃしん）</td>\n<td>Photos</td>\n<td>照片</td>\n<td>照片</td>\n</tr>\n<tr>\n<td>カメラ</td>\n<td>Camera</td>\n<td>相机</td>\n<td>相機</td>\n</tr>\n<tr>\n<td>ブック</td>\n<td>Books</td>\n<td>图书</td>\n<td>書籍</td>\n</tr>\n</tbody></table>\n<p>备注：</p>\n<ol>\n<li>股票：株式（かぶしき）</li>\n<li>股市：株式市場（かぶしきしじょう）</li>\n<li>股价：株価（かぶか）</li>\n</ol>\n<h3 id=\"（二）ユーザーアプリ（用户应用）\"><a href=\"#（二）ユーザーアプリ（用户应用）\" class=\"headerlink\" title=\"（二）ユーザーアプリ（用户应用）\"></a>（二）ユーザーアプリ（用户应用）</h3><table>\n<thead>\n<tr>\n<th>アプリ</th>\n<th>Applications</th>\n<th>应用程序</th>\n<th>應用程式</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>微信 / ウェイシン | WeChat / ウィチャット</td>\n<td>Wechat</td>\n<td>微信</td>\n<td>微信</td>\n</tr>\n<tr>\n<td>QQ / キュキュ</td>\n<td>QQ</td>\n<td>QQ</td>\n<td>QQ</td>\n</tr>\n<tr>\n<td>アリペイ</td>\n<td>Alipay</td>\n<td>支付宝</td>\n<td>支付寶</td>\n</tr>\n<tr>\n<td>ビリビリ</td>\n<td>Bilibili</td>\n<td>哔哩哔哩</td>\n<td>嗶哩嗶哩</td>\n</tr>\n<tr>\n<td>Google / グーグル</td>\n<td>Google</td>\n<td>谷歌</td>\n<td>谷歌</td>\n</tr>\n<tr>\n<td>Kindle / キンドル</td>\n<td>Kindle</td>\n<td>Kindle</td>\n<td>Kindle</td>\n</tr>\n<tr>\n<td>Chrome / クロム</td>\n<td>Chrome</td>\n<td>Chrome</td>\n<td>Chrome</td>\n</tr>\n<tr>\n<td>YouTube / ユーチューブ</td>\n<td>YouTube</td>\n<td>YouTube</td>\n<td>YouTube</td>\n</tr>\n<tr>\n<td>Gmail / ジメイル</td>\n<td>Gmail</td>\n<td>Gmail</td>\n<td>Gmail</td>\n</tr>\n<tr>\n<td>Google フォト</td>\n<td>Google Photo</td>\n<td>Google相册</td>\n<td>Google相簿</td>\n</tr>\n<tr>\n<td>翻訳（ほにゃく）</td>\n<td>Translate</td>\n<td>翻译</td>\n<td>翻譯</td>\n</tr>\n<tr>\n<td>Instagram / インスタグラム</td>\n<td>Instagram</td>\n<td>Instagram</td>\n<td>Instagram</td>\n</tr>\n<tr>\n<td>WhatsApp / ワッツアップ</td>\n<td>WhatsApp</td>\n<td>WhatsApp</td>\n<td>WhatsApp</td>\n</tr>\n<tr>\n<td>Wunderlist / ワンダーリスト</td>\n<td>Wunderlist</td>\n<td>奇妙清单</td>\n<td>奇妙清單</td>\n</tr>\n<tr>\n<td>NetEase Music / ネットイース ミュージック</td>\n<td>NetEase Music</td>\n<td>网易云音乐</td>\n<td>網易云音樂</td>\n</tr>\n<tr>\n<td>好奇心日報（こうきしんにっぽう）</td>\n<td>Qdaily</td>\n<td>好奇心日报</td>\n<td>好奇心日報</td>\n</tr>\n<tr>\n<td>Taobao / タオバオ</td>\n<td>Taobao</td>\n<td>手机淘宝</td>\n<td>手機淘寶</td>\n</tr>\n<tr>\n<td>京東 / ジンドン</td>\n<td>JD</td>\n<td>京东</td>\n<td>京東</td>\n</tr>\n<tr>\n<td>高德地図 / こうとくちず</td>\n<td>Amap</td>\n<td>高德地图</td>\n<td>高德地圖</td>\n</tr>\n<tr>\n<td>印象メモ</td>\n<td>Evernote</td>\n<td>印象笔记</td>\n<td>印象筆記</td>\n</tr>\n<tr>\n<td>招商銀行 / しょうしょうぎんこう</td>\n<td>CMB</td>\n<td>招商银行</td>\n<td>招商銀行</td>\n</tr>\n<tr>\n<td>WeChat 読書（どくしょ 1）?</td>\n<td>WeRead</td>\n<td>微信读书</td>\n<td>微信讀書</td>\n</tr>\n<tr>\n<td>Youku（ヨウク）</td>\n<td>Youku</td>\n<td>优酷</td>\n<td>優酷</td>\n</tr>\n<tr>\n<td>愛奇芸（アイキゲー）</td>\n<td>IQiyi</td>\n<td>爱奇艺</td>\n<td>愛奇藝</td>\n</tr>\n</tbody></table>\n<h2 id=\"二、設定（せってい）\"><a href=\"#二、設定（せってい）\" class=\"headerlink\" title=\"二、設定（せってい）\"></a>二、設定（せってい）</h2><p>「設定」这个词语，不仅含义上，语音上也跟英语的「Setting」相似，很有意思。</p>\n<p>下面分「接続設定」（连接设置）、「フィードバック設定」（反馈设置）、「一般設定」（通用设置）和「ストアー設定」（商店设置）进行比较。</p>\n<h3 id=\"（一）接続（せつぞく）設定（连接设置）\"><a href=\"#（一）接続（せつぞく）設定（连接设置）\" class=\"headerlink\" title=\"（一）接続（せつぞく）設定（连接设置）\"></a>（一）接続（せつぞく）設定（连接设置）</h3><table>\n<thead>\n<tr>\n<th>設定（せってい）</th>\n<th>Settings</th>\n<th>设置</th>\n<th>設定</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>機内モード（きない 1）</td>\n<td>Airplane Mode</td>\n<td>飞行模式</td>\n<td>飛航模式</td>\n</tr>\n<tr>\n<td>WLAN</td>\n<td>WLAN</td>\n<td>无线网络</td>\n<td>WLAN</td>\n</tr>\n<tr>\n<td>Bluetooth</td>\n<td>Bluetooth</td>\n<td>蓝牙</td>\n<td>藍牙</td>\n</tr>\n<tr>\n<td>モバイル通信（つうしん）</td>\n<td>Cellular</td>\n<td>蜂窝移动网络</td>\n<td>行動服務</td>\n</tr>\n<tr>\n<td>インターネット共有（きょうゆう）</td>\n<td>Personal Hotspot</td>\n<td>个人热点</td>\n<td>個人熱點</td>\n</tr>\n<tr>\n<td>VPN</td>\n<td>VPN</td>\n<td>VPN</td>\n<td>VPN</td>\n</tr>\n</tbody></table>\n<h3 id=\"（二）フィードバック設定（反馈设置）\"><a href=\"#（二）フィードバック設定（反馈设置）\" class=\"headerlink\" title=\"（二）フィードバック設定（反馈设置）\"></a>（二）フィードバック設定（反馈设置）</h3><table>\n<thead>\n<tr>\n<th>設定（せってい）</th>\n<th>Settings</th>\n<th>设置</th>\n<th>設定</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>通知（つうち）</td>\n<td>Notifications</td>\n<td>通知</td>\n<td>通知</td>\n</tr>\n<tr>\n<td>サウンドと触覚（しょっかく）</td>\n<td>Sounds＆Haptics</td>\n<td>声音与触感</td>\n<td>聲音與觸覺回饋</td>\n</tr>\n<tr>\n<td>おやすみモード</td>\n<td>Do Not Disturb</td>\n<td>勿扰模式</td>\n<td>勿擾模式</td>\n</tr>\n<tr>\n<td>スクリーンタイム</td>\n<td>Screen Time</td>\n<td>屏幕使用时间</td>\n<td>熒幕使用時間</td>\n</tr>\n</tbody></table>\n<h3 id=\"（三）一般設定（通用设置）\"><a href=\"#（三）一般設定（通用设置）\" class=\"headerlink\" title=\"（三）一般設定（通用设置）\"></a>（三）一般設定（通用设置）</h3><table>\n<thead>\n<tr>\n<th>設定（せってい）</th>\n<th>Settings</th>\n<th>设置</th>\n<th>設定</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>一般（いっぱん）</td>\n<td>General</td>\n<td>通用</td>\n<td>一般</td>\n</tr>\n<tr>\n<td>コントロールセンター</td>\n<td>Control Center</td>\n<td>控制中心</td>\n<td>控制中心</td>\n</tr>\n<tr>\n<td>画面表示と明るさ（がめんひょうじとあかるさ）</td>\n<td>Display ＆ Brightness</td>\n<td>显示与亮度</td>\n<td>熒幕顯示與亮度</td>\n</tr>\n<tr>\n<td>壁紙（かべがみ）</td>\n<td>Wallpaper</td>\n<td>墙纸</td>\n<td>背景圖片</td>\n</tr>\n<tr>\n<td>Siriと検索（けんさく）</td>\n<td>Siri ＆Search</td>\n<td>Siri 与搜索</td>\n<td>Siri 與搜尋</td>\n</tr>\n<tr>\n<td>Face ID とパスコード</td>\n<td>Face ID &amp; Passcode</td>\n<td>面容 ID 与密码</td>\n<td>Face ID 與密碼</td>\n</tr>\n<tr>\n<td>緊急SOS（きんきゅう）</td>\n<td>Emergency SOS</td>\n<td>SOS 紧急联络</td>\n<td>SOS 緊急服務</td>\n</tr>\n<tr>\n<td>バッテリー</td>\n<td>Battery</td>\n<td>电池</td>\n<td>電池</td>\n</tr>\n<tr>\n<td>プライバシー</td>\n<td>Privacy</td>\n<td>隐私</td>\n<td>隱私權</td>\n</tr>\n</tbody></table>\n<h3 id=\"（四）ストアー設定（商店设置）\"><a href=\"#（四）ストアー設定（商店设置）\" class=\"headerlink\" title=\"（四）ストアー設定（商店设置）\"></a>（四）ストアー設定（商店设置）</h3><table>\n<thead>\n<tr>\n<th>設定（せってい）</th>\n<th>Settings</th>\n<th>设置</th>\n<th>設定</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>iTunes Store と App Store</td>\n<td>iTunes Store＆App Store</td>\n<td>iTunes Store 与 App Store</td>\n<td>iTunes Store 與 App Store</td>\n</tr>\n<tr>\n<td>WalletとApple Pay</td>\n<td>Wallet＆Apple Pay</td>\n<td>钱包与 Apple Pay</td>\n<td>錢包與 Apple Pay</td>\n</tr>\n</tbody></table>\n<h2 id=\"三、操作（そうさ）\"><a href=\"#三、操作（そうさ）\" class=\"headerlink\" title=\"三、操作（そうさ）\"></a>三、操作（そうさ）</h2><p>アプリ 的操作是人机交互的重要部分，我们通过操作完成人机交互。常用的操作整理如下：</p>\n<table>\n<thead>\n<tr>\n<th>日本語</th>\n<th>English</th>\n<th>汉语</th>\n<th>漢語</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>OK</td>\n<td>OK</td>\n<td>好的</td>\n<td>好的</td>\n</tr>\n<tr>\n<td>確認</td>\n<td>Comfirm</td>\n<td>确定</td>\n<td>確定</td>\n</tr>\n<tr>\n<td>キャンセル</td>\n<td>Cancel</td>\n<td>取消</td>\n<td>取消</td>\n</tr>\n<tr>\n<td>完了（かんりょう）</td>\n<td>Finish</td>\n<td>完成</td>\n<td>完成</td>\n</tr>\n<tr>\n<td>オン</td>\n<td>On</td>\n<td>开启</td>\n<td>開啟</td>\n</tr>\n<tr>\n<td>オフ</td>\n<td>Off</td>\n<td>关闭</td>\n<td>關閉</td>\n</tr>\n<tr>\n<td>消去（しょうきょ 1）</td>\n<td>Clear</td>\n<td>清除</td>\n<td>清除</td>\n</tr>\n<tr>\n<td>検索（けんさく）</td>\n<td>Search</td>\n<td>搜索</td>\n<td>搜尋</td>\n</tr>\n<tr>\n<td>削除（さくじょ 1）</td>\n<td>Delete</td>\n<td>删除</td>\n<td>删除</td>\n</tr>\n<tr>\n<td>破棄（はき 1）</td>\n<td>Discard</td>\n<td>废弃</td>\n<td>捨棄</td>\n</tr>\n<tr>\n<td>元に戻す（もとにもどす）</td>\n<td>Undo</td>\n<td>撤消</td>\n<td>復原</td>\n</tr>\n<tr>\n<td>開く（ひらく2）</td>\n<td>Open</td>\n<td>打开</td>\n<td>打開</td>\n</tr>\n<tr>\n<td>閉じる（とじる 2）</td>\n<td>Close</td>\n<td>关闭</td>\n<td>關閉</td>\n</tr>\n<tr>\n<td>編集（へんしゅう）</td>\n<td>Edit</td>\n<td>编辑</td>\n<td>編輯</td>\n</tr>\n<tr>\n<td>表示（ひょうじ）</td>\n<td>View</td>\n<td>查看</td>\n<td>檢視</td>\n</tr>\n<tr>\n<td>送る（おくる）</td>\n<td>Send</td>\n<td>发送</td>\n<td>發送</td>\n</tr>\n<tr>\n<td>追加（ついか）</td>\n<td>Add</td>\n<td>添加</td>\n<td>加入</td>\n</tr>\n<tr>\n<td>新着（しんちゃく）</td>\n<td>New</td>\n<td>新增</td>\n<td>新增</td>\n</tr>\n<tr>\n<td>報告（ほうこく）</td>\n<td>Report</td>\n<td>举报</td>\n<td>回報</td>\n</tr>\n<tr>\n<td>マーク</td>\n<td>Mark</td>\n<td>标记</td>\n<td>標示</td>\n</tr>\n<tr>\n<td>再生（さいせい）</td>\n<td>Play</td>\n<td>播放</td>\n<td>播放</td>\n</tr>\n<tr>\n<td>一時停止（いちじていし）</td>\n<td>Pause</td>\n<td>暂停</td>\n<td>暫停</td>\n</tr>\n<tr>\n<td>停止（ていし）</td>\n<td>Stop</td>\n<td>停止</td>\n<td>停止</td>\n</tr>\n<tr>\n<td>登録（とうろく）</td>\n<td>Sign Up</td>\n<td>注册</td>\n<td>註冊</td>\n</tr>\n<tr>\n<td>ログイン</td>\n<td>Sign In / Log In</td>\n<td>登录</td>\n<td>登入</td>\n</tr>\n<tr>\n<td>ログアウト</td>\n<td>Sign Out / Log Out</td>\n<td>退出</td>\n<td>登出 / 退出</td>\n</tr>\n</tbody></table>"},{"title":"潮州話與甲子話韻母差異（稿）","p":"language/min/vowel","_content":"\n![](teochew-kahtsi-vowel/202010042112.png)\n\n## 概述\n\n本文所說的潮州話指的是狹義的潮州話，即潮州市內通行的閩南語，甲子話則是指陸豐市甲子鎮內通行的閩南語。\n通過比較，發現甲子話沒有潮州話中的 e、eh、eng、ou、iou、iouh、uê、uêh、uên、uêng、uêg、iê、iêh、iên、iêng、iêg 等韻，而與之相對應的是 u、uh、ng、ao、iao、iaoh、oi、oih、oin、uang、êng、iang、oig、io、ioh、ion、iang、iag 等等韻。\n\n## 潮州 do(to) / 甲子 dê(tê)\n\n例如：\n1. do / dê：短、代、袋\n2. to / tê：退、褪、推、胎、蛻\n\n例外：\n1. do / do：刀、多、朵、躲、倒、戴、逃、桃、在、萄\n2. to / to：討、妥、唾、橢、馱、陀、沱、跎、桃\n\n<!--more-->\n\n## 潮州 e(eh) / 甲子 u(uh)\n\n例如：\n1. e / u：於\n2. ce / cu：蛆、此、鼠、徐\n3. de / du：豬、除、鋤、箸\n4. ge / gu：車、居、舉、齲、據、距\n5. ghe / ghu：馭、御\n6. he / hu：虛、墟、噓、許、滸、魚、漁\n7. ke / ku：去、渠、瞿\n8. le / lu：汝、旅、膂、驢、閭、櫚、呂、侶、鋁、慮、濾\n9. re / ru：爾、而、荋\n10. se / su：師、思、私、斯、廝、撕、嘶、史、事、賜、駟、肆、詞、祠、伺、嗣、辭（又音si）、士、仕、似、姒（又音 sai）、嶼、祀、俟、峙、耜\n11. ze / zu：之、書、芝、孜、姿、咨、資、茲、輜、訾、齜 \n\n例外：\n1. ghe / ngo：語\n2. he / hê：許（～搭）\n3. keh / kig：乞（～丐）\n4. keh / koh：乞（～汝）\n5. re / ri：耳（木～）、洱、餌、貳、膩\n6. se / si：始\n\n☞ 甲子話中「吾」旁的基本都是發 ngo 音，如下：\n1. u / ngo： 吾\n2. nge / ngo： 語\n3. ngo / ngo：悟、晤、梧、寤、遇、愚\n\n## 潮州 eng / 甲子 ing、ng\n\n例如：\n1. eng / ing：恩、摁\n2. geng / ging：巾、斤、近、根、筋、均、鈞、謹、僅、緊、覲\n3. ngeng / nging：銀、垠、齦、鄞、元、圓\n4. heng / hing：很、狠、恨\n5. keng / king：勤、芹、鏗（又音kiang，☞ king kiang 即爲「鏗鏗」）\n6. ceng / cng：倉、瘡、艙、村、床\n7. deng / dng：當、擋、返、轉、頓、長、傳、腸、唐、堂、塘、蕩、斷、段、緞\n8. keng / kng：勸、囥、糠\n9. meng / mng：晚、門、們、捫、問\n10. neng / nng：女、軟、鑽、郎、卵、浪\n11. seng / sng：孫、喪（～事）、酸、霜、耍、蒜、算\n12. teng / tng：湯、捅、燙、褪、糖\n13. zeng / zng：莊、妝、磚、贓、樁、裝、鑽、葬、旋\n\n例外：\n1. seng / siong 桑\n2. keng / kêng：墾、懇\n\n## 潮州 eg / 甲子 ig、iag\n\n例如：\n1. keg / kig ：仡（～佬族）\n2. keg / kiag：橛、镢\n3. ngeg / ngiag：迄、訖、屹\n\n例外：\n1. ngeg / ngib：吃\n\n## 潮州 iê(iêh) / 甲子 io(ioh)\n\n例如：\n1. iê / io：腰、姚、窯、揺\n2. iêh / ioh：約、藥\n3. biê / bio：表\n4. biê & piao / pio & biao：標、飆\n5. bhiê / bhio：描、廟\n6. ciê / cio：笑、唱\n7. ciêh / cioh：尺、席\n8. diê / dio：跳、潮\n9. diêh / dioh： 著\n10. giê / gio：叫、茄、橋\n11. hiêh / hioh：葉、頁\n12. kiêh / kioh：挈/𢭪\n13. liê / lio：撈\n14. niê / nio：兩、娘、量、讓 \n15. piê / pio：票、鰾\n16. riê / rio：尿\n17. riêh / rioh：若\n18. siê / sio：相、燒、小\n19. siêh / sioh：惜、液\n20. tiê / tio：挑、糶\n21. ziê / zio：招、蕉、少、照\n22. ziêh / zioh：質、借、石\n\n## 潮州 iên / 甲子 ion\n\n例如：\n1. iên / ion：鴦、羊、陽、楊、洋、樣\n2. ciên / cion：槍、鯧、搶、牆、象、匠\n3. diên / dion：張、長、帳、脹、賬、場、丈、趙\n4. giên / gion： 姜、強、彊\n5. hiên / hion：香、鄉\n6. kiên / kion：腔\n7. siên / sion：傷、廂、箱、鑲、賞、消、相、像、常、嘗\n8. ziên / zion 漿、章、樟、蔣、掌、醬、上、癢\n\n例外： \n1. diên / dio 釣（☞ 鼻音完全脫落）\n\n## 潮州 iêng(iêg) / iang(iag)\n\n例如：\n1. iêng / iang：鳶、淵、焉、蔫、遠、咽、延、涎、衍、筵、羨、援\n2. biêng / biang：邊、砭、鞭、變、遍、便、辯\n3. ciêng / ciang：阡、遷、芊、纖、淺\n4. ciêg / ciag：切\n5. diêng / diang：鎮（又音ding）、顛（又音ding）、滇、典、展、腆、電、甸、墊、澱、腆、輾、珍\n6. giêng /giang：堅、捐、鵑、見、建、鍵\n7. hiêng /hiang：掀、顯、絢、憲、釁、獻、玄、賢、炫、嫻、癇\n8. kiêng /kiang：虔、愆、騫、犬、乾\n9. liêng / liang：臉、連、憐、蓮、吝、躪、練\n10. miêng /miang：免、勉、娩、憫、敏、緬、腼、綿\n11. ngiêng / ngiang：妍、研、齴\n12. ngiêg / ngiag：嚙（～齒）\n\n## 潮州 ing(ig) / 甲子êng(êg) 、 iang(iag)\n\n例如：\n1. mig / mêg：默、陌\n2. ing / iang：沿、鉛\n3. mig / miag：滅、蔑\n4. zing / ziang：薦\n\n例外：\n1. ing / ing：因、姻、胭、湮、引、癮、印、應、寅、演\n2. ing / hing：暈\n3. bing / bing：乒、賓、彬、斌、稟\n4. big / big：筆、必、畢、蓽、篳、弼\n5. bhig / bhig：蜜\n6. cing / cing：親、臣、秦\n7. cig / cig：七\n8. ding / ding：顛、振、鎮、塵、藤、陣\n9. cing / cim：襯\n10. king / king：輕、氫\n11. ling / ling：鄰、遴、嶙、麟\n12. ming / ming：民、氓、泯、眠、面\n13. mig / mig 密、蜜、冪、覓、謐\n14. ning / ning 恁\n15. ping / ping：牝、貧、蘋、砭、貶、屏、瓶、頻\n16. bing / ping：品\n17. ring / ring：人、仁、認\n18. sing / sing： 申、伸、紳、神、辛、莘、新、薪、身、訊、迅、汛、信、辰、娠、蜃、晨、繩、蠅、盛\n19. ting / ting： 烴、陳、澄\n20. zing / zing：甄、津、真、嗔、臻、拯、振、賑、震、晉、進、盡、燼\n21. zing / ding 珍\n\n## 潮州 iou(iouh) / 甲子 iao(iaoh)\n\n例如：\n1. iou / iao：一、幺、夭、妖、要、枵、邀、窈、搖、耀\n2. biou / biao：表、婊\n3. ciou / ciao：悄、稍、朝、嘲、瞧、晁\n4. diou / diao：刁、叼、凋、雕、吊、弔、兆、條、召、調、掉\n5. giou / giao：嬌、驕、矯、餃、攪（又音 ga/gao）、繳、撬\n6. hiou / hiao：僥、梟、驍、曉\n7. kiou / kiao：磽、蹺、敲（又音ka）、巧（又音ka）、竅、翹、喬、僑\n8. liou / liao：了、潦（又音lo）、遼、療、寥、聊、料、鷺\n9. miou / miao：杳、秒、淼、渺、妙、瞄、描（又音 bhiê）\n10. niou / niao：撓、裊、皺\n11. ngiou / ngiao：貓、堯\n12. piou / piao：飄、漂、嫖、樸\n13. piou / biao：標\n14. riou / riao：爪、擾、嬈、繞、饒\n15. siou / siao：肖、宵、消、捎、梢、霄、搜、宿、瀟、數、小、紹、肇、韶\n16. tiou / tiao：迢、挑、超、窕、柱\n17. ziou / ziao：釗、招（又音ziê）、昭、朝、焦、樵、礁、鳥、皭\n\n## 潮州 iong / 甲子 êng\n\n例如：\n1. iong / êng：永、詠、泳、榮、蠑、塋、熒、縈、螢、嬴\n\n## 潮州 ong / iong\n\n例如：\n1. dong / diong：重、中、忠、仲\n2. rong / riong：戎、絨、茸\n3. zong / ziong：眾\n4. rong / riong：仍、扔\n5. song / siong：松、訟、誦、頌\n\n例外：\n1. cong / cong：從、充、衝\n\n## 潮州 ng / 甲子 ing\n\n例如：\n1. ng / ing：尹、隱\n2. hng / hing：軒、欣、鍁、勳、殷\n\n## 潮州 oin / 甲子 ain\n\n例如：\n1. oin / ain：閒\n2. boin / bain：斑、反、板、爿\n3. coin / cain：千、蠶\n4. doin / dain：殿\n5. goin / gain：間、肩、繭\n6. hoin / hain：蜆、還、莧\n7. koin / kain：蓋\n8. soin / sain：先\n\n例外：\n1. toin / toin：睇\n2. noin / nai：蓮（☞ 鼻音完全脫落）\n\n☞  根據李新魁先生的研究，「與現代潮音比較，最重要的差異是：（1）清代潮音【-n】尾諸韻尚未並入【-ŋ】，（2）現代一些地方唸【oi】、【õ】韻母的字，清代尚唸【ai】、【ãi】。」（見李新魁《二百年前的潮州音》廣東社會科學 1993 年第 2 期）。可見甲子話之保守和存古，仍讀【ain】而非【oin】。\n\n## 潮州 uê(uêh) / 甲子 oi(oih)\n\n例如：\n1. uê / oi：鍋、穢、尉、慰、蔚、話、畫、衛\n2. uêh / oih：划、畫\n3. buê / boi：飛、杯、掊、倍、培、賠 、焙、蓓、悖、貝、狽、背、輩、佩\n4. buê / poi：陪\n5. bhuê / bhoi：尾、枚、莓、梅、酶、霉、煤、媒、未\n6. cuê / coi：吹、炊、髓、覓\n7. duê / doi：綴、兌\n8. guê / goi：瓜、果、餜、粿、裹、過、怪、卦、掛（～紙）、葵（～笠）\n9. guêh / goih：郭、橛\n10. ghuêh / ghoih8：月\n11. huê / hoi：化、華、花、貨、灰、詼、恢、火、伙、夥、歲、誨、悔、晦、回、茴、蛔、匯、會、薈、燴、瓦（～匙）\n12. huêh / hoih：血\n13. kuê / koi：科、蝌、課、稞、瘸\n14. kuêh / koih：缺、闕、闋\n15. muêh / moih：物\n16. muê / moi：每、糜、妹、昧、寐、魅、袂\n17. nuê / noi：餒\n18. puê / poi：皮、被、坯、胚、配、裴\n19. puêh / poih：詖、坺\n20. ruê / roi：枘、蚋、銳、睿\n21. suê / soi：衰、歲、帥（俗音 suai）、戍、說、稅\n22. suêh / soih：說\n23. tuê / toi：頹\n24. zuê / zoi：最、襊、罪、㩼\n\n例外：\n1. bhuêh / ghoih：襪\n2. kuê / kui：盔\n3. suêh / suah：刷、涮\n\n## 潮州 uên / 甲子 oin\n\n例如：\n1. guên / goin：關、果\n2. huên / hoin：橫\n\n## 潮州 uêng(uêg) / 甲子 uang(uag)\n\n例如：\n1. uêng / uang：彎、冤、鴛、淵、宛、苑、怨、完、莞、烷、丸、袁、轅、緣\n2. uêg / uag：曰、斡、鉞、越、粵\n3. buêng / puang：叛\n4. buêg / buag：拔、跋、魃、勃、悖、荸、餑、渤\n5. bhuêng / muan：幔（☞ 後鼻音退成鼻化音）\n6. cuêng / cuang：川、穿、舛、喘、篡、闖、串、全、醛、栓\n7. cuêg / cuag：啜、綴、輟\n8. duêng / duang：端、斷、鍛、段（又音deng）、篆\n9. guêng / guang：關、觀、冠、鰥\n10. guêg / guag：決、訣、抉、玦、聒、譎\n11. guêg / kuag：括\n12. huêng / huang：歡、番、蕃（又音hang）、翻、反、返、販、緩、幻、奐、喚、還、環、煩、寰、繁、宦、豢\n13. huêg / huag：發、髮、乏、穴、伐、罰、閥\n14. kuêng / kuang：寬、圈、髖、權、款、蜷\n15. kuêg / kuag：擴\n16. luêng / luang：暖、戀、巒、孿、鸞、亂\n17. luêg / luag：劣\n18. muêg / muag：末、沫、秣\n19. nguêng / nguang：阮、玩、頑、元、原、源、願\n20. puêng / puang：藩、判、拌（又音puan）、胖、畔、盤（又音buan）、磐、蹣\n21. puêng / puan：般（☞ 後鼻音退成鼻化音）\n22. puêg / puag：潑、銖\n23. ruêng / ruang：亂\n24. ruêg / ruag：悅\n25. suêng / suang：選、算（又音 seng）、旋、漩\n26. tuêng / tuang：湍、團、傳\n27. zuêng / zuang： 專、轉、鐫、顓、撰\n28. zuêg / zuag：拙、茁、咄、絀\n\n例外：\n1. bhuêng/mang：萬、饅、慢、漫\n2. kuêng /  kêng：傾、頃、卿\n3. huêng / hoin：衡\n4. huêg / hoig：或 、惑\n5. uêg / oig：獲 、域、役、鑊\n6. guêng / goin：囧、炯、耿、穎\n7. nguêng / ngiang：顏\n8. nguêng / iang：芫\n\n## 其餘\n1. 宿舍：潮州 suah⁴ sia³  / 甲子 sog⁴ sia³\n2. 唔肯：潮州m⁶ kêng² / 甲子m⁶ kêng² 或 m⁶ kiang²\n3. 言語：潮州 ngang⁵ ghe² / 甲子 ngiang⁵ ngo²\n4. 瓊、煢：潮州kuang⁵ / 甲子kêng⁵\n5. 舀：潮州 io² / 甲子ion² ","source":"_posts/language/min/teochew-kahtsi-vowel.md","raw":"---\ntitle: 潮州話與甲子話韻母差異（稿）\np: language/min/vowel\ntags:\n- 閩南語\n- 潮州話\n- 甲子話\n---\n\n![](teochew-kahtsi-vowel/202010042112.png)\n\n## 概述\n\n本文所說的潮州話指的是狹義的潮州話，即潮州市內通行的閩南語，甲子話則是指陸豐市甲子鎮內通行的閩南語。\n通過比較，發現甲子話沒有潮州話中的 e、eh、eng、ou、iou、iouh、uê、uêh、uên、uêng、uêg、iê、iêh、iên、iêng、iêg 等韻，而與之相對應的是 u、uh、ng、ao、iao、iaoh、oi、oih、oin、uang、êng、iang、oig、io、ioh、ion、iang、iag 等等韻。\n\n## 潮州 do(to) / 甲子 dê(tê)\n\n例如：\n1. do / dê：短、代、袋\n2. to / tê：退、褪、推、胎、蛻\n\n例外：\n1. do / do：刀、多、朵、躲、倒、戴、逃、桃、在、萄\n2. to / to：討、妥、唾、橢、馱、陀、沱、跎、桃\n\n<!--more-->\n\n## 潮州 e(eh) / 甲子 u(uh)\n\n例如：\n1. e / u：於\n2. ce / cu：蛆、此、鼠、徐\n3. de / du：豬、除、鋤、箸\n4. ge / gu：車、居、舉、齲、據、距\n5. ghe / ghu：馭、御\n6. he / hu：虛、墟、噓、許、滸、魚、漁\n7. ke / ku：去、渠、瞿\n8. le / lu：汝、旅、膂、驢、閭、櫚、呂、侶、鋁、慮、濾\n9. re / ru：爾、而、荋\n10. se / su：師、思、私、斯、廝、撕、嘶、史、事、賜、駟、肆、詞、祠、伺、嗣、辭（又音si）、士、仕、似、姒（又音 sai）、嶼、祀、俟、峙、耜\n11. ze / zu：之、書、芝、孜、姿、咨、資、茲、輜、訾、齜 \n\n例外：\n1. ghe / ngo：語\n2. he / hê：許（～搭）\n3. keh / kig：乞（～丐）\n4. keh / koh：乞（～汝）\n5. re / ri：耳（木～）、洱、餌、貳、膩\n6. se / si：始\n\n☞ 甲子話中「吾」旁的基本都是發 ngo 音，如下：\n1. u / ngo： 吾\n2. nge / ngo： 語\n3. ngo / ngo：悟、晤、梧、寤、遇、愚\n\n## 潮州 eng / 甲子 ing、ng\n\n例如：\n1. eng / ing：恩、摁\n2. geng / ging：巾、斤、近、根、筋、均、鈞、謹、僅、緊、覲\n3. ngeng / nging：銀、垠、齦、鄞、元、圓\n4. heng / hing：很、狠、恨\n5. keng / king：勤、芹、鏗（又音kiang，☞ king kiang 即爲「鏗鏗」）\n6. ceng / cng：倉、瘡、艙、村、床\n7. deng / dng：當、擋、返、轉、頓、長、傳、腸、唐、堂、塘、蕩、斷、段、緞\n8. keng / kng：勸、囥、糠\n9. meng / mng：晚、門、們、捫、問\n10. neng / nng：女、軟、鑽、郎、卵、浪\n11. seng / sng：孫、喪（～事）、酸、霜、耍、蒜、算\n12. teng / tng：湯、捅、燙、褪、糖\n13. zeng / zng：莊、妝、磚、贓、樁、裝、鑽、葬、旋\n\n例外：\n1. seng / siong 桑\n2. keng / kêng：墾、懇\n\n## 潮州 eg / 甲子 ig、iag\n\n例如：\n1. keg / kig ：仡（～佬族）\n2. keg / kiag：橛、镢\n3. ngeg / ngiag：迄、訖、屹\n\n例外：\n1. ngeg / ngib：吃\n\n## 潮州 iê(iêh) / 甲子 io(ioh)\n\n例如：\n1. iê / io：腰、姚、窯、揺\n2. iêh / ioh：約、藥\n3. biê / bio：表\n4. biê & piao / pio & biao：標、飆\n5. bhiê / bhio：描、廟\n6. ciê / cio：笑、唱\n7. ciêh / cioh：尺、席\n8. diê / dio：跳、潮\n9. diêh / dioh： 著\n10. giê / gio：叫、茄、橋\n11. hiêh / hioh：葉、頁\n12. kiêh / kioh：挈/𢭪\n13. liê / lio：撈\n14. niê / nio：兩、娘、量、讓 \n15. piê / pio：票、鰾\n16. riê / rio：尿\n17. riêh / rioh：若\n18. siê / sio：相、燒、小\n19. siêh / sioh：惜、液\n20. tiê / tio：挑、糶\n21. ziê / zio：招、蕉、少、照\n22. ziêh / zioh：質、借、石\n\n## 潮州 iên / 甲子 ion\n\n例如：\n1. iên / ion：鴦、羊、陽、楊、洋、樣\n2. ciên / cion：槍、鯧、搶、牆、象、匠\n3. diên / dion：張、長、帳、脹、賬、場、丈、趙\n4. giên / gion： 姜、強、彊\n5. hiên / hion：香、鄉\n6. kiên / kion：腔\n7. siên / sion：傷、廂、箱、鑲、賞、消、相、像、常、嘗\n8. ziên / zion 漿、章、樟、蔣、掌、醬、上、癢\n\n例外： \n1. diên / dio 釣（☞ 鼻音完全脫落）\n\n## 潮州 iêng(iêg) / iang(iag)\n\n例如：\n1. iêng / iang：鳶、淵、焉、蔫、遠、咽、延、涎、衍、筵、羨、援\n2. biêng / biang：邊、砭、鞭、變、遍、便、辯\n3. ciêng / ciang：阡、遷、芊、纖、淺\n4. ciêg / ciag：切\n5. diêng / diang：鎮（又音ding）、顛（又音ding）、滇、典、展、腆、電、甸、墊、澱、腆、輾、珍\n6. giêng /giang：堅、捐、鵑、見、建、鍵\n7. hiêng /hiang：掀、顯、絢、憲、釁、獻、玄、賢、炫、嫻、癇\n8. kiêng /kiang：虔、愆、騫、犬、乾\n9. liêng / liang：臉、連、憐、蓮、吝、躪、練\n10. miêng /miang：免、勉、娩、憫、敏、緬、腼、綿\n11. ngiêng / ngiang：妍、研、齴\n12. ngiêg / ngiag：嚙（～齒）\n\n## 潮州 ing(ig) / 甲子êng(êg) 、 iang(iag)\n\n例如：\n1. mig / mêg：默、陌\n2. ing / iang：沿、鉛\n3. mig / miag：滅、蔑\n4. zing / ziang：薦\n\n例外：\n1. ing / ing：因、姻、胭、湮、引、癮、印、應、寅、演\n2. ing / hing：暈\n3. bing / bing：乒、賓、彬、斌、稟\n4. big / big：筆、必、畢、蓽、篳、弼\n5. bhig / bhig：蜜\n6. cing / cing：親、臣、秦\n7. cig / cig：七\n8. ding / ding：顛、振、鎮、塵、藤、陣\n9. cing / cim：襯\n10. king / king：輕、氫\n11. ling / ling：鄰、遴、嶙、麟\n12. ming / ming：民、氓、泯、眠、面\n13. mig / mig 密、蜜、冪、覓、謐\n14. ning / ning 恁\n15. ping / ping：牝、貧、蘋、砭、貶、屏、瓶、頻\n16. bing / ping：品\n17. ring / ring：人、仁、認\n18. sing / sing： 申、伸、紳、神、辛、莘、新、薪、身、訊、迅、汛、信、辰、娠、蜃、晨、繩、蠅、盛\n19. ting / ting： 烴、陳、澄\n20. zing / zing：甄、津、真、嗔、臻、拯、振、賑、震、晉、進、盡、燼\n21. zing / ding 珍\n\n## 潮州 iou(iouh) / 甲子 iao(iaoh)\n\n例如：\n1. iou / iao：一、幺、夭、妖、要、枵、邀、窈、搖、耀\n2. biou / biao：表、婊\n3. ciou / ciao：悄、稍、朝、嘲、瞧、晁\n4. diou / diao：刁、叼、凋、雕、吊、弔、兆、條、召、調、掉\n5. giou / giao：嬌、驕、矯、餃、攪（又音 ga/gao）、繳、撬\n6. hiou / hiao：僥、梟、驍、曉\n7. kiou / kiao：磽、蹺、敲（又音ka）、巧（又音ka）、竅、翹、喬、僑\n8. liou / liao：了、潦（又音lo）、遼、療、寥、聊、料、鷺\n9. miou / miao：杳、秒、淼、渺、妙、瞄、描（又音 bhiê）\n10. niou / niao：撓、裊、皺\n11. ngiou / ngiao：貓、堯\n12. piou / piao：飄、漂、嫖、樸\n13. piou / biao：標\n14. riou / riao：爪、擾、嬈、繞、饒\n15. siou / siao：肖、宵、消、捎、梢、霄、搜、宿、瀟、數、小、紹、肇、韶\n16. tiou / tiao：迢、挑、超、窕、柱\n17. ziou / ziao：釗、招（又音ziê）、昭、朝、焦、樵、礁、鳥、皭\n\n## 潮州 iong / 甲子 êng\n\n例如：\n1. iong / êng：永、詠、泳、榮、蠑、塋、熒、縈、螢、嬴\n\n## 潮州 ong / iong\n\n例如：\n1. dong / diong：重、中、忠、仲\n2. rong / riong：戎、絨、茸\n3. zong / ziong：眾\n4. rong / riong：仍、扔\n5. song / siong：松、訟、誦、頌\n\n例外：\n1. cong / cong：從、充、衝\n\n## 潮州 ng / 甲子 ing\n\n例如：\n1. ng / ing：尹、隱\n2. hng / hing：軒、欣、鍁、勳、殷\n\n## 潮州 oin / 甲子 ain\n\n例如：\n1. oin / ain：閒\n2. boin / bain：斑、反、板、爿\n3. coin / cain：千、蠶\n4. doin / dain：殿\n5. goin / gain：間、肩、繭\n6. hoin / hain：蜆、還、莧\n7. koin / kain：蓋\n8. soin / sain：先\n\n例外：\n1. toin / toin：睇\n2. noin / nai：蓮（☞ 鼻音完全脫落）\n\n☞  根據李新魁先生的研究，「與現代潮音比較，最重要的差異是：（1）清代潮音【-n】尾諸韻尚未並入【-ŋ】，（2）現代一些地方唸【oi】、【õ】韻母的字，清代尚唸【ai】、【ãi】。」（見李新魁《二百年前的潮州音》廣東社會科學 1993 年第 2 期）。可見甲子話之保守和存古，仍讀【ain】而非【oin】。\n\n## 潮州 uê(uêh) / 甲子 oi(oih)\n\n例如：\n1. uê / oi：鍋、穢、尉、慰、蔚、話、畫、衛\n2. uêh / oih：划、畫\n3. buê / boi：飛、杯、掊、倍、培、賠 、焙、蓓、悖、貝、狽、背、輩、佩\n4. buê / poi：陪\n5. bhuê / bhoi：尾、枚、莓、梅、酶、霉、煤、媒、未\n6. cuê / coi：吹、炊、髓、覓\n7. duê / doi：綴、兌\n8. guê / goi：瓜、果、餜、粿、裹、過、怪、卦、掛（～紙）、葵（～笠）\n9. guêh / goih：郭、橛\n10. ghuêh / ghoih8：月\n11. huê / hoi：化、華、花、貨、灰、詼、恢、火、伙、夥、歲、誨、悔、晦、回、茴、蛔、匯、會、薈、燴、瓦（～匙）\n12. huêh / hoih：血\n13. kuê / koi：科、蝌、課、稞、瘸\n14. kuêh / koih：缺、闕、闋\n15. muêh / moih：物\n16. muê / moi：每、糜、妹、昧、寐、魅、袂\n17. nuê / noi：餒\n18. puê / poi：皮、被、坯、胚、配、裴\n19. puêh / poih：詖、坺\n20. ruê / roi：枘、蚋、銳、睿\n21. suê / soi：衰、歲、帥（俗音 suai）、戍、說、稅\n22. suêh / soih：說\n23. tuê / toi：頹\n24. zuê / zoi：最、襊、罪、㩼\n\n例外：\n1. bhuêh / ghoih：襪\n2. kuê / kui：盔\n3. suêh / suah：刷、涮\n\n## 潮州 uên / 甲子 oin\n\n例如：\n1. guên / goin：關、果\n2. huên / hoin：橫\n\n## 潮州 uêng(uêg) / 甲子 uang(uag)\n\n例如：\n1. uêng / uang：彎、冤、鴛、淵、宛、苑、怨、完、莞、烷、丸、袁、轅、緣\n2. uêg / uag：曰、斡、鉞、越、粵\n3. buêng / puang：叛\n4. buêg / buag：拔、跋、魃、勃、悖、荸、餑、渤\n5. bhuêng / muan：幔（☞ 後鼻音退成鼻化音）\n6. cuêng / cuang：川、穿、舛、喘、篡、闖、串、全、醛、栓\n7. cuêg / cuag：啜、綴、輟\n8. duêng / duang：端、斷、鍛、段（又音deng）、篆\n9. guêng / guang：關、觀、冠、鰥\n10. guêg / guag：決、訣、抉、玦、聒、譎\n11. guêg / kuag：括\n12. huêng / huang：歡、番、蕃（又音hang）、翻、反、返、販、緩、幻、奐、喚、還、環、煩、寰、繁、宦、豢\n13. huêg / huag：發、髮、乏、穴、伐、罰、閥\n14. kuêng / kuang：寬、圈、髖、權、款、蜷\n15. kuêg / kuag：擴\n16. luêng / luang：暖、戀、巒、孿、鸞、亂\n17. luêg / luag：劣\n18. muêg / muag：末、沫、秣\n19. nguêng / nguang：阮、玩、頑、元、原、源、願\n20. puêng / puang：藩、判、拌（又音puan）、胖、畔、盤（又音buan）、磐、蹣\n21. puêng / puan：般（☞ 後鼻音退成鼻化音）\n22. puêg / puag：潑、銖\n23. ruêng / ruang：亂\n24. ruêg / ruag：悅\n25. suêng / suang：選、算（又音 seng）、旋、漩\n26. tuêng / tuang：湍、團、傳\n27. zuêng / zuang： 專、轉、鐫、顓、撰\n28. zuêg / zuag：拙、茁、咄、絀\n\n例外：\n1. bhuêng/mang：萬、饅、慢、漫\n2. kuêng /  kêng：傾、頃、卿\n3. huêng / hoin：衡\n4. huêg / hoig：或 、惑\n5. uêg / oig：獲 、域、役、鑊\n6. guêng / goin：囧、炯、耿、穎\n7. nguêng / ngiang：顏\n8. nguêng / iang：芫\n\n## 其餘\n1. 宿舍：潮州 suah⁴ sia³  / 甲子 sog⁴ sia³\n2. 唔肯：潮州m⁶ kêng² / 甲子m⁶ kêng² 或 m⁶ kiang²\n3. 言語：潮州 ngang⁵ ghe² / 甲子 ngiang⁵ ngo²\n4. 瓊、煢：潮州kuang⁵ / 甲子kêng⁵\n5. 舀：潮州 io² / 甲子ion² ","slug":"language/min/teochew-kahtsi-vowel","published":1,"date":"2020-10-04T09:48:48.801Z","updated":"2020-12-02T03:32:41.725Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cki72psxg000aslw8ooxp6kf5","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css\"><p><img src=\"/2020/10/04/language/min/teochew-kahtsi-vowel/202010042112.png\" alt></p>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>本文所說的潮州話指的是狹義的潮州話，即潮州市內通行的閩南語，甲子話則是指陸豐市甲子鎮內通行的閩南語。<br>通過比較，發現甲子話沒有潮州話中的 e、eh、eng、ou、iou、iouh、uê、uêh、uên、uêng、uêg、iê、iêh、iên、iêng、iêg 等韻，而與之相對應的是 u、uh、ng、ao、iao、iaoh、oi、oih、oin、uang、êng、iang、oig、io、ioh、ion、iang、iag 等等韻。</p>\n<h2 id=\"潮州-do-to-甲子-de-te\"><a href=\"#潮州-do-to-甲子-de-te\" class=\"headerlink\" title=\"潮州 do(to) / 甲子 dê(tê)\"></a>潮州 do(to) / 甲子 dê(tê)</h2><p>例如：</p>\n<ol>\n<li>do / dê：短、代、袋</li>\n<li>to / tê：退、褪、推、胎、蛻</li>\n</ol>\n<p>例外：</p>\n<ol>\n<li>do / do：刀、多、朵、躲、倒、戴、逃、桃、在、萄</li>\n<li>to / to：討、妥、唾、橢、馱、陀、沱、跎、桃</li>\n</ol>\n<a id=\"more\"></a>\n\n<h2 id=\"潮州-e-eh-甲子-u-uh\"><a href=\"#潮州-e-eh-甲子-u-uh\" class=\"headerlink\" title=\"潮州 e(eh) / 甲子 u(uh)\"></a>潮州 e(eh) / 甲子 u(uh)</h2><p>例如：</p>\n<ol>\n<li>e / u：於</li>\n<li>ce / cu：蛆、此、鼠、徐</li>\n<li>de / du：豬、除、鋤、箸</li>\n<li>ge / gu：車、居、舉、齲、據、距</li>\n<li>ghe / ghu：馭、御</li>\n<li>he / hu：虛、墟、噓、許、滸、魚、漁</li>\n<li>ke / ku：去、渠、瞿</li>\n<li>le / lu：汝、旅、膂、驢、閭、櫚、呂、侶、鋁、慮、濾</li>\n<li>re / ru：爾、而、荋</li>\n<li>se / su：師、思、私、斯、廝、撕、嘶、史、事、賜、駟、肆、詞、祠、伺、嗣、辭（又音si）、士、仕、似、姒（又音 sai）、嶼、祀、俟、峙、耜</li>\n<li>ze / zu：之、書、芝、孜、姿、咨、資、茲、輜、訾、齜 </li>\n</ol>\n<p>例外：</p>\n<ol>\n<li>ghe / ngo：語</li>\n<li>he / hê：許（～搭）</li>\n<li>keh / kig：乞（～丐）</li>\n<li>keh / koh：乞（～汝）</li>\n<li>re / ri：耳（木～）、洱、餌、貳、膩</li>\n<li>se / si：始</li>\n</ol>\n<p>☞ 甲子話中「吾」旁的基本都是發 ngo 音，如下：</p>\n<ol>\n<li>u / ngo： 吾</li>\n<li>nge / ngo： 語</li>\n<li>ngo / ngo：悟、晤、梧、寤、遇、愚</li>\n</ol>\n<h2 id=\"潮州-eng-甲子-ing、ng\"><a href=\"#潮州-eng-甲子-ing、ng\" class=\"headerlink\" title=\"潮州 eng / 甲子 ing、ng\"></a>潮州 eng / 甲子 ing、ng</h2><p>例如：</p>\n<ol>\n<li>eng / ing：恩、摁</li>\n<li>geng / ging：巾、斤、近、根、筋、均、鈞、謹、僅、緊、覲</li>\n<li>ngeng / nging：銀、垠、齦、鄞、元、圓</li>\n<li>heng / hing：很、狠、恨</li>\n<li>keng / king：勤、芹、鏗（又音kiang，☞ king kiang 即爲「鏗鏗」）</li>\n<li>ceng / cng：倉、瘡、艙、村、床</li>\n<li>deng / dng：當、擋、返、轉、頓、長、傳、腸、唐、堂、塘、蕩、斷、段、緞</li>\n<li>keng / kng：勸、囥、糠</li>\n<li>meng / mng：晚、門、們、捫、問</li>\n<li>neng / nng：女、軟、鑽、郎、卵、浪</li>\n<li>seng / sng：孫、喪（～事）、酸、霜、耍、蒜、算</li>\n<li>teng / tng：湯、捅、燙、褪、糖</li>\n<li>zeng / zng：莊、妝、磚、贓、樁、裝、鑽、葬、旋</li>\n</ol>\n<p>例外：</p>\n<ol>\n<li>seng / siong 桑</li>\n<li>keng / kêng：墾、懇</li>\n</ol>\n<h2 id=\"潮州-eg-甲子-ig、iag\"><a href=\"#潮州-eg-甲子-ig、iag\" class=\"headerlink\" title=\"潮州 eg / 甲子 ig、iag\"></a>潮州 eg / 甲子 ig、iag</h2><p>例如：</p>\n<ol>\n<li>keg / kig ：仡（～佬族）</li>\n<li>keg / kiag：橛、镢</li>\n<li>ngeg / ngiag：迄、訖、屹</li>\n</ol>\n<p>例外：</p>\n<ol>\n<li>ngeg / ngib：吃</li>\n</ol>\n<h2 id=\"潮州-ie-ieh-甲子-io-ioh\"><a href=\"#潮州-ie-ieh-甲子-io-ioh\" class=\"headerlink\" title=\"潮州 iê(iêh) / 甲子 io(ioh)\"></a>潮州 iê(iêh) / 甲子 io(ioh)</h2><p>例如：</p>\n<ol>\n<li>iê / io：腰、姚、窯、揺</li>\n<li>iêh / ioh：約、藥</li>\n<li>biê / bio：表</li>\n<li>biê &amp; piao / pio &amp; biao：標、飆</li>\n<li>bhiê / bhio：描、廟</li>\n<li>ciê / cio：笑、唱</li>\n<li>ciêh / cioh：尺、席</li>\n<li>diê / dio：跳、潮</li>\n<li>diêh / dioh： 著</li>\n<li>giê / gio：叫、茄、橋</li>\n<li>hiêh / hioh：葉、頁</li>\n<li>kiêh / kioh：挈/𢭪</li>\n<li>liê / lio：撈</li>\n<li>niê / nio：兩、娘、量、讓 </li>\n<li>piê / pio：票、鰾</li>\n<li>riê / rio：尿</li>\n<li>riêh / rioh：若</li>\n<li>siê / sio：相、燒、小</li>\n<li>siêh / sioh：惜、液</li>\n<li>tiê / tio：挑、糶</li>\n<li>ziê / zio：招、蕉、少、照</li>\n<li>ziêh / zioh：質、借、石</li>\n</ol>\n<h2 id=\"潮州-ien-甲子-ion\"><a href=\"#潮州-ien-甲子-ion\" class=\"headerlink\" title=\"潮州 iên / 甲子 ion\"></a>潮州 iên / 甲子 ion</h2><p>例如：</p>\n<ol>\n<li>iên / ion：鴦、羊、陽、楊、洋、樣</li>\n<li>ciên / cion：槍、鯧、搶、牆、象、匠</li>\n<li>diên / dion：張、長、帳、脹、賬、場、丈、趙</li>\n<li>giên / gion： 姜、強、彊</li>\n<li>hiên / hion：香、鄉</li>\n<li>kiên / kion：腔</li>\n<li>siên / sion：傷、廂、箱、鑲、賞、消、相、像、常、嘗</li>\n<li>ziên / zion 漿、章、樟、蔣、掌、醬、上、癢</li>\n</ol>\n<p>例外： </p>\n<ol>\n<li>diên / dio 釣（☞ 鼻音完全脫落）</li>\n</ol>\n<h2 id=\"潮州-ieng-ieg-iang-iag\"><a href=\"#潮州-ieng-ieg-iang-iag\" class=\"headerlink\" title=\"潮州 iêng(iêg) / iang(iag)\"></a>潮州 iêng(iêg) / iang(iag)</h2><p>例如：</p>\n<ol>\n<li>iêng / iang：鳶、淵、焉、蔫、遠、咽、延、涎、衍、筵、羨、援</li>\n<li>biêng / biang：邊、砭、鞭、變、遍、便、辯</li>\n<li>ciêng / ciang：阡、遷、芊、纖、淺</li>\n<li>ciêg / ciag：切</li>\n<li>diêng / diang：鎮（又音ding）、顛（又音ding）、滇、典、展、腆、電、甸、墊、澱、腆、輾、珍</li>\n<li>giêng /giang：堅、捐、鵑、見、建、鍵</li>\n<li>hiêng /hiang：掀、顯、絢、憲、釁、獻、玄、賢、炫、嫻、癇</li>\n<li>kiêng /kiang：虔、愆、騫、犬、乾</li>\n<li>liêng / liang：臉、連、憐、蓮、吝、躪、練</li>\n<li>miêng /miang：免、勉、娩、憫、敏、緬、腼、綿</li>\n<li>ngiêng / ngiang：妍、研、齴</li>\n<li>ngiêg / ngiag：嚙（～齒）</li>\n</ol>\n<h2 id=\"潮州-ing-ig-甲子eng-eg-、-iang-iag\"><a href=\"#潮州-ing-ig-甲子eng-eg-、-iang-iag\" class=\"headerlink\" title=\"潮州 ing(ig) / 甲子êng(êg) 、 iang(iag)\"></a>潮州 ing(ig) / 甲子êng(êg) 、 iang(iag)</h2><p>例如：</p>\n<ol>\n<li>mig / mêg：默、陌</li>\n<li>ing / iang：沿、鉛</li>\n<li>mig / miag：滅、蔑</li>\n<li>zing / ziang：薦</li>\n</ol>\n<p>例外：</p>\n<ol>\n<li>ing / ing：因、姻、胭、湮、引、癮、印、應、寅、演</li>\n<li>ing / hing：暈</li>\n<li>bing / bing：乒、賓、彬、斌、稟</li>\n<li>big / big：筆、必、畢、蓽、篳、弼</li>\n<li>bhig / bhig：蜜</li>\n<li>cing / cing：親、臣、秦</li>\n<li>cig / cig：七</li>\n<li>ding / ding：顛、振、鎮、塵、藤、陣</li>\n<li>cing / cim：襯</li>\n<li>king / king：輕、氫</li>\n<li>ling / ling：鄰、遴、嶙、麟</li>\n<li>ming / ming：民、氓、泯、眠、面</li>\n<li>mig / mig 密、蜜、冪、覓、謐</li>\n<li>ning / ning 恁</li>\n<li>ping / ping：牝、貧、蘋、砭、貶、屏、瓶、頻</li>\n<li>bing / ping：品</li>\n<li>ring / ring：人、仁、認</li>\n<li>sing / sing： 申、伸、紳、神、辛、莘、新、薪、身、訊、迅、汛、信、辰、娠、蜃、晨、繩、蠅、盛</li>\n<li>ting / ting： 烴、陳、澄</li>\n<li>zing / zing：甄、津、真、嗔、臻、拯、振、賑、震、晉、進、盡、燼</li>\n<li>zing / ding 珍</li>\n</ol>\n<h2 id=\"潮州-iou-iouh-甲子-iao-iaoh\"><a href=\"#潮州-iou-iouh-甲子-iao-iaoh\" class=\"headerlink\" title=\"潮州 iou(iouh) / 甲子 iao(iaoh)\"></a>潮州 iou(iouh) / 甲子 iao(iaoh)</h2><p>例如：</p>\n<ol>\n<li>iou / iao：一、幺、夭、妖、要、枵、邀、窈、搖、耀</li>\n<li>biou / biao：表、婊</li>\n<li>ciou / ciao：悄、稍、朝、嘲、瞧、晁</li>\n<li>diou / diao：刁、叼、凋、雕、吊、弔、兆、條、召、調、掉</li>\n<li>giou / giao：嬌、驕、矯、餃、攪（又音 ga/gao）、繳、撬</li>\n<li>hiou / hiao：僥、梟、驍、曉</li>\n<li>kiou / kiao：磽、蹺、敲（又音ka）、巧（又音ka）、竅、翹、喬、僑</li>\n<li>liou / liao：了、潦（又音lo）、遼、療、寥、聊、料、鷺</li>\n<li>miou / miao：杳、秒、淼、渺、妙、瞄、描（又音 bhiê）</li>\n<li>niou / niao：撓、裊、皺</li>\n<li>ngiou / ngiao：貓、堯</li>\n<li>piou / piao：飄、漂、嫖、樸</li>\n<li>piou / biao：標</li>\n<li>riou / riao：爪、擾、嬈、繞、饒</li>\n<li>siou / siao：肖、宵、消、捎、梢、霄、搜、宿、瀟、數、小、紹、肇、韶</li>\n<li>tiou / tiao：迢、挑、超、窕、柱</li>\n<li>ziou / ziao：釗、招（又音ziê）、昭、朝、焦、樵、礁、鳥、皭</li>\n</ol>\n<h2 id=\"潮州-iong-甲子-eng\"><a href=\"#潮州-iong-甲子-eng\" class=\"headerlink\" title=\"潮州 iong / 甲子 êng\"></a>潮州 iong / 甲子 êng</h2><p>例如：</p>\n<ol>\n<li>iong / êng：永、詠、泳、榮、蠑、塋、熒、縈、螢、嬴</li>\n</ol>\n<h2 id=\"潮州-ong-iong\"><a href=\"#潮州-ong-iong\" class=\"headerlink\" title=\"潮州 ong / iong\"></a>潮州 ong / iong</h2><p>例如：</p>\n<ol>\n<li>dong / diong：重、中、忠、仲</li>\n<li>rong / riong：戎、絨、茸</li>\n<li>zong / ziong：眾</li>\n<li>rong / riong：仍、扔</li>\n<li>song / siong：松、訟、誦、頌</li>\n</ol>\n<p>例外：</p>\n<ol>\n<li>cong / cong：從、充、衝</li>\n</ol>\n<h2 id=\"潮州-ng-甲子-ing\"><a href=\"#潮州-ng-甲子-ing\" class=\"headerlink\" title=\"潮州 ng / 甲子 ing\"></a>潮州 ng / 甲子 ing</h2><p>例如：</p>\n<ol>\n<li>ng / ing：尹、隱</li>\n<li>hng / hing：軒、欣、鍁、勳、殷</li>\n</ol>\n<h2 id=\"潮州-oin-甲子-ain\"><a href=\"#潮州-oin-甲子-ain\" class=\"headerlink\" title=\"潮州 oin / 甲子 ain\"></a>潮州 oin / 甲子 ain</h2><p>例如：</p>\n<ol>\n<li>oin / ain：閒</li>\n<li>boin / bain：斑、反、板、爿</li>\n<li>coin / cain：千、蠶</li>\n<li>doin / dain：殿</li>\n<li>goin / gain：間、肩、繭</li>\n<li>hoin / hain：蜆、還、莧</li>\n<li>koin / kain：蓋</li>\n<li>soin / sain：先</li>\n</ol>\n<p>例外：</p>\n<ol>\n<li>toin / toin：睇</li>\n<li>noin / nai：蓮（☞ 鼻音完全脫落）</li>\n</ol>\n<p>☞  根據李新魁先生的研究，「與現代潮音比較，最重要的差異是：（1）清代潮音【-n】尾諸韻尚未並入【-ŋ】，（2）現代一些地方唸【oi】、【õ】韻母的字，清代尚唸【ai】、【ãi】。」（見李新魁《二百年前的潮州音》廣東社會科學 1993 年第 2 期）。可見甲子話之保守和存古，仍讀【ain】而非【oin】。</p>\n<h2 id=\"潮州-ue-ueh-甲子-oi-oih\"><a href=\"#潮州-ue-ueh-甲子-oi-oih\" class=\"headerlink\" title=\"潮州 uê(uêh) / 甲子 oi(oih)\"></a>潮州 uê(uêh) / 甲子 oi(oih)</h2><p>例如：</p>\n<ol>\n<li>uê / oi：鍋、穢、尉、慰、蔚、話、畫、衛</li>\n<li>uêh / oih：划、畫</li>\n<li>buê / boi：飛、杯、掊、倍、培、賠 、焙、蓓、悖、貝、狽、背、輩、佩</li>\n<li>buê / poi：陪</li>\n<li>bhuê / bhoi：尾、枚、莓、梅、酶、霉、煤、媒、未</li>\n<li>cuê / coi：吹、炊、髓、覓</li>\n<li>duê / doi：綴、兌</li>\n<li>guê / goi：瓜、果、餜、粿、裹、過、怪、卦、掛（～紙）、葵（～笠）</li>\n<li>guêh / goih：郭、橛</li>\n<li>ghuêh / ghoih8：月</li>\n<li>huê / hoi：化、華、花、貨、灰、詼、恢、火、伙、夥、歲、誨、悔、晦、回、茴、蛔、匯、會、薈、燴、瓦（～匙）</li>\n<li>huêh / hoih：血</li>\n<li>kuê / koi：科、蝌、課、稞、瘸</li>\n<li>kuêh / koih：缺、闕、闋</li>\n<li>muêh / moih：物</li>\n<li>muê / moi：每、糜、妹、昧、寐、魅、袂</li>\n<li>nuê / noi：餒</li>\n<li>puê / poi：皮、被、坯、胚、配、裴</li>\n<li>puêh / poih：詖、坺</li>\n<li>ruê / roi：枘、蚋、銳、睿</li>\n<li>suê / soi：衰、歲、帥（俗音 suai）、戍、說、稅</li>\n<li>suêh / soih：說</li>\n<li>tuê / toi：頹</li>\n<li>zuê / zoi：最、襊、罪、㩼</li>\n</ol>\n<p>例外：</p>\n<ol>\n<li>bhuêh / ghoih：襪</li>\n<li>kuê / kui：盔</li>\n<li>suêh / suah：刷、涮</li>\n</ol>\n<h2 id=\"潮州-uen-甲子-oin\"><a href=\"#潮州-uen-甲子-oin\" class=\"headerlink\" title=\"潮州 uên / 甲子 oin\"></a>潮州 uên / 甲子 oin</h2><p>例如：</p>\n<ol>\n<li>guên / goin：關、果</li>\n<li>huên / hoin：橫</li>\n</ol>\n<h2 id=\"潮州-ueng-ueg-甲子-uang-uag\"><a href=\"#潮州-ueng-ueg-甲子-uang-uag\" class=\"headerlink\" title=\"潮州 uêng(uêg) / 甲子 uang(uag)\"></a>潮州 uêng(uêg) / 甲子 uang(uag)</h2><p>例如：</p>\n<ol>\n<li>uêng / uang：彎、冤、鴛、淵、宛、苑、怨、完、莞、烷、丸、袁、轅、緣</li>\n<li>uêg / uag：曰、斡、鉞、越、粵</li>\n<li>buêng / puang：叛</li>\n<li>buêg / buag：拔、跋、魃、勃、悖、荸、餑、渤</li>\n<li>bhuêng / muan：幔（☞ 後鼻音退成鼻化音）</li>\n<li>cuêng / cuang：川、穿、舛、喘、篡、闖、串、全、醛、栓</li>\n<li>cuêg / cuag：啜、綴、輟</li>\n<li>duêng / duang：端、斷、鍛、段（又音deng）、篆</li>\n<li>guêng / guang：關、觀、冠、鰥</li>\n<li>guêg / guag：決、訣、抉、玦、聒、譎</li>\n<li>guêg / kuag：括</li>\n<li>huêng / huang：歡、番、蕃（又音hang）、翻、反、返、販、緩、幻、奐、喚、還、環、煩、寰、繁、宦、豢</li>\n<li>huêg / huag：發、髮、乏、穴、伐、罰、閥</li>\n<li>kuêng / kuang：寬、圈、髖、權、款、蜷</li>\n<li>kuêg / kuag：擴</li>\n<li>luêng / luang：暖、戀、巒、孿、鸞、亂</li>\n<li>luêg / luag：劣</li>\n<li>muêg / muag：末、沫、秣</li>\n<li>nguêng / nguang：阮、玩、頑、元、原、源、願</li>\n<li>puêng / puang：藩、判、拌（又音puan）、胖、畔、盤（又音buan）、磐、蹣</li>\n<li>puêng / puan：般（☞ 後鼻音退成鼻化音）</li>\n<li>puêg / puag：潑、銖</li>\n<li>ruêng / ruang：亂</li>\n<li>ruêg / ruag：悅</li>\n<li>suêng / suang：選、算（又音 seng）、旋、漩</li>\n<li>tuêng / tuang：湍、團、傳</li>\n<li>zuêng / zuang： 專、轉、鐫、顓、撰</li>\n<li>zuêg / zuag：拙、茁、咄、絀</li>\n</ol>\n<p>例外：</p>\n<ol>\n<li>bhuêng/mang：萬、饅、慢、漫</li>\n<li>kuêng /  kêng：傾、頃、卿</li>\n<li>huêng / hoin：衡</li>\n<li>huêg / hoig：或 、惑</li>\n<li>uêg / oig：獲 、域、役、鑊</li>\n<li>guêng / goin：囧、炯、耿、穎</li>\n<li>nguêng / ngiang：顏</li>\n<li>nguêng / iang：芫</li>\n</ol>\n<h2 id=\"其餘\"><a href=\"#其餘\" class=\"headerlink\" title=\"其餘\"></a>其餘</h2><ol>\n<li>宿舍：潮州 suah⁴ sia³  / 甲子 sog⁴ sia³</li>\n<li>唔肯：潮州m⁶ kêng² / 甲子m⁶ kêng² 或 m⁶ kiang²</li>\n<li>言語：潮州 ngang⁵ ghe² / 甲子 ngiang⁵ ngo²</li>\n<li>瓊、煢：潮州kuang⁵ / 甲子kêng⁵</li>\n<li>舀：潮州 io² / 甲子ion² </li>\n</ol>\n","site":{"data":{}},"excerpt":"<p><img src=\"/2020/10/04/language/min/teochew-kahtsi-vowel/202010042112.png\" alt></p>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>本文所說的潮州話指的是狹義的潮州話，即潮州市內通行的閩南語，甲子話則是指陸豐市甲子鎮內通行的閩南語。<br>通過比較，發現甲子話沒有潮州話中的 e、eh、eng、ou、iou、iouh、uê、uêh、uên、uêng、uêg、iê、iêh、iên、iêng、iêg 等韻，而與之相對應的是 u、uh、ng、ao、iao、iaoh、oi、oih、oin、uang、êng、iang、oig、io、ioh、ion、iang、iag 等等韻。</p>\n<h2 id=\"潮州-do-to-甲子-de-te\"><a href=\"#潮州-do-to-甲子-de-te\" class=\"headerlink\" title=\"潮州 do(to) / 甲子 dê(tê)\"></a>潮州 do(to) / 甲子 dê(tê)</h2><p>例如：</p>\n<ol>\n<li>do / dê：短、代、袋</li>\n<li>to / tê：退、褪、推、胎、蛻</li>\n</ol>\n<p>例外：</p>\n<ol>\n<li>do / do：刀、多、朵、躲、倒、戴、逃、桃、在、萄</li>\n<li>to / to：討、妥、唾、橢、馱、陀、沱、跎、桃</li>\n</ol>","more":"<h2 id=\"潮州-e-eh-甲子-u-uh\"><a href=\"#潮州-e-eh-甲子-u-uh\" class=\"headerlink\" title=\"潮州 e(eh) / 甲子 u(uh)\"></a>潮州 e(eh) / 甲子 u(uh)</h2><p>例如：</p>\n<ol>\n<li>e / u：於</li>\n<li>ce / cu：蛆、此、鼠、徐</li>\n<li>de / du：豬、除、鋤、箸</li>\n<li>ge / gu：車、居、舉、齲、據、距</li>\n<li>ghe / ghu：馭、御</li>\n<li>he / hu：虛、墟、噓、許、滸、魚、漁</li>\n<li>ke / ku：去、渠、瞿</li>\n<li>le / lu：汝、旅、膂、驢、閭、櫚、呂、侶、鋁、慮、濾</li>\n<li>re / ru：爾、而、荋</li>\n<li>se / su：師、思、私、斯、廝、撕、嘶、史、事、賜、駟、肆、詞、祠、伺、嗣、辭（又音si）、士、仕、似、姒（又音 sai）、嶼、祀、俟、峙、耜</li>\n<li>ze / zu：之、書、芝、孜、姿、咨、資、茲、輜、訾、齜 </li>\n</ol>\n<p>例外：</p>\n<ol>\n<li>ghe / ngo：語</li>\n<li>he / hê：許（～搭）</li>\n<li>keh / kig：乞（～丐）</li>\n<li>keh / koh：乞（～汝）</li>\n<li>re / ri：耳（木～）、洱、餌、貳、膩</li>\n<li>se / si：始</li>\n</ol>\n<p>☞ 甲子話中「吾」旁的基本都是發 ngo 音，如下：</p>\n<ol>\n<li>u / ngo： 吾</li>\n<li>nge / ngo： 語</li>\n<li>ngo / ngo：悟、晤、梧、寤、遇、愚</li>\n</ol>\n<h2 id=\"潮州-eng-甲子-ing、ng\"><a href=\"#潮州-eng-甲子-ing、ng\" class=\"headerlink\" title=\"潮州 eng / 甲子 ing、ng\"></a>潮州 eng / 甲子 ing、ng</h2><p>例如：</p>\n<ol>\n<li>eng / ing：恩、摁</li>\n<li>geng / ging：巾、斤、近、根、筋、均、鈞、謹、僅、緊、覲</li>\n<li>ngeng / nging：銀、垠、齦、鄞、元、圓</li>\n<li>heng / hing：很、狠、恨</li>\n<li>keng / king：勤、芹、鏗（又音kiang，☞ king kiang 即爲「鏗鏗」）</li>\n<li>ceng / cng：倉、瘡、艙、村、床</li>\n<li>deng / dng：當、擋、返、轉、頓、長、傳、腸、唐、堂、塘、蕩、斷、段、緞</li>\n<li>keng / kng：勸、囥、糠</li>\n<li>meng / mng：晚、門、們、捫、問</li>\n<li>neng / nng：女、軟、鑽、郎、卵、浪</li>\n<li>seng / sng：孫、喪（～事）、酸、霜、耍、蒜、算</li>\n<li>teng / tng：湯、捅、燙、褪、糖</li>\n<li>zeng / zng：莊、妝、磚、贓、樁、裝、鑽、葬、旋</li>\n</ol>\n<p>例外：</p>\n<ol>\n<li>seng / siong 桑</li>\n<li>keng / kêng：墾、懇</li>\n</ol>\n<h2 id=\"潮州-eg-甲子-ig、iag\"><a href=\"#潮州-eg-甲子-ig、iag\" class=\"headerlink\" title=\"潮州 eg / 甲子 ig、iag\"></a>潮州 eg / 甲子 ig、iag</h2><p>例如：</p>\n<ol>\n<li>keg / kig ：仡（～佬族）</li>\n<li>keg / kiag：橛、镢</li>\n<li>ngeg / ngiag：迄、訖、屹</li>\n</ol>\n<p>例外：</p>\n<ol>\n<li>ngeg / ngib：吃</li>\n</ol>\n<h2 id=\"潮州-ie-ieh-甲子-io-ioh\"><a href=\"#潮州-ie-ieh-甲子-io-ioh\" class=\"headerlink\" title=\"潮州 iê(iêh) / 甲子 io(ioh)\"></a>潮州 iê(iêh) / 甲子 io(ioh)</h2><p>例如：</p>\n<ol>\n<li>iê / io：腰、姚、窯、揺</li>\n<li>iêh / ioh：約、藥</li>\n<li>biê / bio：表</li>\n<li>biê &amp; piao / pio &amp; biao：標、飆</li>\n<li>bhiê / bhio：描、廟</li>\n<li>ciê / cio：笑、唱</li>\n<li>ciêh / cioh：尺、席</li>\n<li>diê / dio：跳、潮</li>\n<li>diêh / dioh： 著</li>\n<li>giê / gio：叫、茄、橋</li>\n<li>hiêh / hioh：葉、頁</li>\n<li>kiêh / kioh：挈/𢭪</li>\n<li>liê / lio：撈</li>\n<li>niê / nio：兩、娘、量、讓 </li>\n<li>piê / pio：票、鰾</li>\n<li>riê / rio：尿</li>\n<li>riêh / rioh：若</li>\n<li>siê / sio：相、燒、小</li>\n<li>siêh / sioh：惜、液</li>\n<li>tiê / tio：挑、糶</li>\n<li>ziê / zio：招、蕉、少、照</li>\n<li>ziêh / zioh：質、借、石</li>\n</ol>\n<h2 id=\"潮州-ien-甲子-ion\"><a href=\"#潮州-ien-甲子-ion\" class=\"headerlink\" title=\"潮州 iên / 甲子 ion\"></a>潮州 iên / 甲子 ion</h2><p>例如：</p>\n<ol>\n<li>iên / ion：鴦、羊、陽、楊、洋、樣</li>\n<li>ciên / cion：槍、鯧、搶、牆、象、匠</li>\n<li>diên / dion：張、長、帳、脹、賬、場、丈、趙</li>\n<li>giên / gion： 姜、強、彊</li>\n<li>hiên / hion：香、鄉</li>\n<li>kiên / kion：腔</li>\n<li>siên / sion：傷、廂、箱、鑲、賞、消、相、像、常、嘗</li>\n<li>ziên / zion 漿、章、樟、蔣、掌、醬、上、癢</li>\n</ol>\n<p>例外： </p>\n<ol>\n<li>diên / dio 釣（☞ 鼻音完全脫落）</li>\n</ol>\n<h2 id=\"潮州-ieng-ieg-iang-iag\"><a href=\"#潮州-ieng-ieg-iang-iag\" class=\"headerlink\" title=\"潮州 iêng(iêg) / iang(iag)\"></a>潮州 iêng(iêg) / iang(iag)</h2><p>例如：</p>\n<ol>\n<li>iêng / iang：鳶、淵、焉、蔫、遠、咽、延、涎、衍、筵、羨、援</li>\n<li>biêng / biang：邊、砭、鞭、變、遍、便、辯</li>\n<li>ciêng / ciang：阡、遷、芊、纖、淺</li>\n<li>ciêg / ciag：切</li>\n<li>diêng / diang：鎮（又音ding）、顛（又音ding）、滇、典、展、腆、電、甸、墊、澱、腆、輾、珍</li>\n<li>giêng /giang：堅、捐、鵑、見、建、鍵</li>\n<li>hiêng /hiang：掀、顯、絢、憲、釁、獻、玄、賢、炫、嫻、癇</li>\n<li>kiêng /kiang：虔、愆、騫、犬、乾</li>\n<li>liêng / liang：臉、連、憐、蓮、吝、躪、練</li>\n<li>miêng /miang：免、勉、娩、憫、敏、緬、腼、綿</li>\n<li>ngiêng / ngiang：妍、研、齴</li>\n<li>ngiêg / ngiag：嚙（～齒）</li>\n</ol>\n<h2 id=\"潮州-ing-ig-甲子eng-eg-、-iang-iag\"><a href=\"#潮州-ing-ig-甲子eng-eg-、-iang-iag\" class=\"headerlink\" title=\"潮州 ing(ig) / 甲子êng(êg) 、 iang(iag)\"></a>潮州 ing(ig) / 甲子êng(êg) 、 iang(iag)</h2><p>例如：</p>\n<ol>\n<li>mig / mêg：默、陌</li>\n<li>ing / iang：沿、鉛</li>\n<li>mig / miag：滅、蔑</li>\n<li>zing / ziang：薦</li>\n</ol>\n<p>例外：</p>\n<ol>\n<li>ing / ing：因、姻、胭、湮、引、癮、印、應、寅、演</li>\n<li>ing / hing：暈</li>\n<li>bing / bing：乒、賓、彬、斌、稟</li>\n<li>big / big：筆、必、畢、蓽、篳、弼</li>\n<li>bhig / bhig：蜜</li>\n<li>cing / cing：親、臣、秦</li>\n<li>cig / cig：七</li>\n<li>ding / ding：顛、振、鎮、塵、藤、陣</li>\n<li>cing / cim：襯</li>\n<li>king / king：輕、氫</li>\n<li>ling / ling：鄰、遴、嶙、麟</li>\n<li>ming / ming：民、氓、泯、眠、面</li>\n<li>mig / mig 密、蜜、冪、覓、謐</li>\n<li>ning / ning 恁</li>\n<li>ping / ping：牝、貧、蘋、砭、貶、屏、瓶、頻</li>\n<li>bing / ping：品</li>\n<li>ring / ring：人、仁、認</li>\n<li>sing / sing： 申、伸、紳、神、辛、莘、新、薪、身、訊、迅、汛、信、辰、娠、蜃、晨、繩、蠅、盛</li>\n<li>ting / ting： 烴、陳、澄</li>\n<li>zing / zing：甄、津、真、嗔、臻、拯、振、賑、震、晉、進、盡、燼</li>\n<li>zing / ding 珍</li>\n</ol>\n<h2 id=\"潮州-iou-iouh-甲子-iao-iaoh\"><a href=\"#潮州-iou-iouh-甲子-iao-iaoh\" class=\"headerlink\" title=\"潮州 iou(iouh) / 甲子 iao(iaoh)\"></a>潮州 iou(iouh) / 甲子 iao(iaoh)</h2><p>例如：</p>\n<ol>\n<li>iou / iao：一、幺、夭、妖、要、枵、邀、窈、搖、耀</li>\n<li>biou / biao：表、婊</li>\n<li>ciou / ciao：悄、稍、朝、嘲、瞧、晁</li>\n<li>diou / diao：刁、叼、凋、雕、吊、弔、兆、條、召、調、掉</li>\n<li>giou / giao：嬌、驕、矯、餃、攪（又音 ga/gao）、繳、撬</li>\n<li>hiou / hiao：僥、梟、驍、曉</li>\n<li>kiou / kiao：磽、蹺、敲（又音ka）、巧（又音ka）、竅、翹、喬、僑</li>\n<li>liou / liao：了、潦（又音lo）、遼、療、寥、聊、料、鷺</li>\n<li>miou / miao：杳、秒、淼、渺、妙、瞄、描（又音 bhiê）</li>\n<li>niou / niao：撓、裊、皺</li>\n<li>ngiou / ngiao：貓、堯</li>\n<li>piou / piao：飄、漂、嫖、樸</li>\n<li>piou / biao：標</li>\n<li>riou / riao：爪、擾、嬈、繞、饒</li>\n<li>siou / siao：肖、宵、消、捎、梢、霄、搜、宿、瀟、數、小、紹、肇、韶</li>\n<li>tiou / tiao：迢、挑、超、窕、柱</li>\n<li>ziou / ziao：釗、招（又音ziê）、昭、朝、焦、樵、礁、鳥、皭</li>\n</ol>\n<h2 id=\"潮州-iong-甲子-eng\"><a href=\"#潮州-iong-甲子-eng\" class=\"headerlink\" title=\"潮州 iong / 甲子 êng\"></a>潮州 iong / 甲子 êng</h2><p>例如：</p>\n<ol>\n<li>iong / êng：永、詠、泳、榮、蠑、塋、熒、縈、螢、嬴</li>\n</ol>\n<h2 id=\"潮州-ong-iong\"><a href=\"#潮州-ong-iong\" class=\"headerlink\" title=\"潮州 ong / iong\"></a>潮州 ong / iong</h2><p>例如：</p>\n<ol>\n<li>dong / diong：重、中、忠、仲</li>\n<li>rong / riong：戎、絨、茸</li>\n<li>zong / ziong：眾</li>\n<li>rong / riong：仍、扔</li>\n<li>song / siong：松、訟、誦、頌</li>\n</ol>\n<p>例外：</p>\n<ol>\n<li>cong / cong：從、充、衝</li>\n</ol>\n<h2 id=\"潮州-ng-甲子-ing\"><a href=\"#潮州-ng-甲子-ing\" class=\"headerlink\" title=\"潮州 ng / 甲子 ing\"></a>潮州 ng / 甲子 ing</h2><p>例如：</p>\n<ol>\n<li>ng / ing：尹、隱</li>\n<li>hng / hing：軒、欣、鍁、勳、殷</li>\n</ol>\n<h2 id=\"潮州-oin-甲子-ain\"><a href=\"#潮州-oin-甲子-ain\" class=\"headerlink\" title=\"潮州 oin / 甲子 ain\"></a>潮州 oin / 甲子 ain</h2><p>例如：</p>\n<ol>\n<li>oin / ain：閒</li>\n<li>boin / bain：斑、反、板、爿</li>\n<li>coin / cain：千、蠶</li>\n<li>doin / dain：殿</li>\n<li>goin / gain：間、肩、繭</li>\n<li>hoin / hain：蜆、還、莧</li>\n<li>koin / kain：蓋</li>\n<li>soin / sain：先</li>\n</ol>\n<p>例外：</p>\n<ol>\n<li>toin / toin：睇</li>\n<li>noin / nai：蓮（☞ 鼻音完全脫落）</li>\n</ol>\n<p>☞  根據李新魁先生的研究，「與現代潮音比較，最重要的差異是：（1）清代潮音【-n】尾諸韻尚未並入【-ŋ】，（2）現代一些地方唸【oi】、【õ】韻母的字，清代尚唸【ai】、【ãi】。」（見李新魁《二百年前的潮州音》廣東社會科學 1993 年第 2 期）。可見甲子話之保守和存古，仍讀【ain】而非【oin】。</p>\n<h2 id=\"潮州-ue-ueh-甲子-oi-oih\"><a href=\"#潮州-ue-ueh-甲子-oi-oih\" class=\"headerlink\" title=\"潮州 uê(uêh) / 甲子 oi(oih)\"></a>潮州 uê(uêh) / 甲子 oi(oih)</h2><p>例如：</p>\n<ol>\n<li>uê / oi：鍋、穢、尉、慰、蔚、話、畫、衛</li>\n<li>uêh / oih：划、畫</li>\n<li>buê / boi：飛、杯、掊、倍、培、賠 、焙、蓓、悖、貝、狽、背、輩、佩</li>\n<li>buê / poi：陪</li>\n<li>bhuê / bhoi：尾、枚、莓、梅、酶、霉、煤、媒、未</li>\n<li>cuê / coi：吹、炊、髓、覓</li>\n<li>duê / doi：綴、兌</li>\n<li>guê / goi：瓜、果、餜、粿、裹、過、怪、卦、掛（～紙）、葵（～笠）</li>\n<li>guêh / goih：郭、橛</li>\n<li>ghuêh / ghoih8：月</li>\n<li>huê / hoi：化、華、花、貨、灰、詼、恢、火、伙、夥、歲、誨、悔、晦、回、茴、蛔、匯、會、薈、燴、瓦（～匙）</li>\n<li>huêh / hoih：血</li>\n<li>kuê / koi：科、蝌、課、稞、瘸</li>\n<li>kuêh / koih：缺、闕、闋</li>\n<li>muêh / moih：物</li>\n<li>muê / moi：每、糜、妹、昧、寐、魅、袂</li>\n<li>nuê / noi：餒</li>\n<li>puê / poi：皮、被、坯、胚、配、裴</li>\n<li>puêh / poih：詖、坺</li>\n<li>ruê / roi：枘、蚋、銳、睿</li>\n<li>suê / soi：衰、歲、帥（俗音 suai）、戍、說、稅</li>\n<li>suêh / soih：說</li>\n<li>tuê / toi：頹</li>\n<li>zuê / zoi：最、襊、罪、㩼</li>\n</ol>\n<p>例外：</p>\n<ol>\n<li>bhuêh / ghoih：襪</li>\n<li>kuê / kui：盔</li>\n<li>suêh / suah：刷、涮</li>\n</ol>\n<h2 id=\"潮州-uen-甲子-oin\"><a href=\"#潮州-uen-甲子-oin\" class=\"headerlink\" title=\"潮州 uên / 甲子 oin\"></a>潮州 uên / 甲子 oin</h2><p>例如：</p>\n<ol>\n<li>guên / goin：關、果</li>\n<li>huên / hoin：橫</li>\n</ol>\n<h2 id=\"潮州-ueng-ueg-甲子-uang-uag\"><a href=\"#潮州-ueng-ueg-甲子-uang-uag\" class=\"headerlink\" title=\"潮州 uêng(uêg) / 甲子 uang(uag)\"></a>潮州 uêng(uêg) / 甲子 uang(uag)</h2><p>例如：</p>\n<ol>\n<li>uêng / uang：彎、冤、鴛、淵、宛、苑、怨、完、莞、烷、丸、袁、轅、緣</li>\n<li>uêg / uag：曰、斡、鉞、越、粵</li>\n<li>buêng / puang：叛</li>\n<li>buêg / buag：拔、跋、魃、勃、悖、荸、餑、渤</li>\n<li>bhuêng / muan：幔（☞ 後鼻音退成鼻化音）</li>\n<li>cuêng / cuang：川、穿、舛、喘、篡、闖、串、全、醛、栓</li>\n<li>cuêg / cuag：啜、綴、輟</li>\n<li>duêng / duang：端、斷、鍛、段（又音deng）、篆</li>\n<li>guêng / guang：關、觀、冠、鰥</li>\n<li>guêg / guag：決、訣、抉、玦、聒、譎</li>\n<li>guêg / kuag：括</li>\n<li>huêng / huang：歡、番、蕃（又音hang）、翻、反、返、販、緩、幻、奐、喚、還、環、煩、寰、繁、宦、豢</li>\n<li>huêg / huag：發、髮、乏、穴、伐、罰、閥</li>\n<li>kuêng / kuang：寬、圈、髖、權、款、蜷</li>\n<li>kuêg / kuag：擴</li>\n<li>luêng / luang：暖、戀、巒、孿、鸞、亂</li>\n<li>luêg / luag：劣</li>\n<li>muêg / muag：末、沫、秣</li>\n<li>nguêng / nguang：阮、玩、頑、元、原、源、願</li>\n<li>puêng / puang：藩、判、拌（又音puan）、胖、畔、盤（又音buan）、磐、蹣</li>\n<li>puêng / puan：般（☞ 後鼻音退成鼻化音）</li>\n<li>puêg / puag：潑、銖</li>\n<li>ruêng / ruang：亂</li>\n<li>ruêg / ruag：悅</li>\n<li>suêng / suang：選、算（又音 seng）、旋、漩</li>\n<li>tuêng / tuang：湍、團、傳</li>\n<li>zuêng / zuang： 專、轉、鐫、顓、撰</li>\n<li>zuêg / zuag：拙、茁、咄、絀</li>\n</ol>\n<p>例外：</p>\n<ol>\n<li>bhuêng/mang：萬、饅、慢、漫</li>\n<li>kuêng /  kêng：傾、頃、卿</li>\n<li>huêng / hoin：衡</li>\n<li>huêg / hoig：或 、惑</li>\n<li>uêg / oig：獲 、域、役、鑊</li>\n<li>guêng / goin：囧、炯、耿、穎</li>\n<li>nguêng / ngiang：顏</li>\n<li>nguêng / iang：芫</li>\n</ol>\n<h2 id=\"其餘\"><a href=\"#其餘\" class=\"headerlink\" title=\"其餘\"></a>其餘</h2><ol>\n<li>宿舍：潮州 suah⁴ sia³  / 甲子 sog⁴ sia³</li>\n<li>唔肯：潮州m⁶ kêng² / 甲子m⁶ kêng² 或 m⁶ kiang²</li>\n<li>言語：潮州 ngang⁵ ghe² / 甲子 ngiang⁵ ngo²</li>\n<li>瓊、煢：潮州kuang⁵ / 甲子kêng⁵</li>\n<li>舀：潮州 io² / 甲子ion² </li>\n</ol>"},{"title":"在潮劇中學之《玉堂春》","p":"language/min/teochew-opera-ghêgdengcung","_content":"\n潮劇自明朝已然形成，發展到現在有近 500 年的歷史，據統計截止 2007 年 6 月已有超過 5000 個劇目。明朝嘉靖丙寅年（1566年）刊本的《荔鏡記》，是迄今所能見到的最早一個運用「泉潮腔」演唱的演出劇本。它於 2006 年被列入首批國家級非物質文化遺產保護名錄。\n\n潮劇的語音特點是：最早的潮劇基本上是以潮州府城音爲主要音系來表演的，但迴避了潮州音的最明顯的特徵音韻母——潮州府城話的 iêng/iêg、uêng/uêg、iêm/iêb 等韻母，換成了跟其他方言相同的 iang/iag、uang/uag 和 iam/iab 韻母。然後，還參雜了揭陽話的一些特點。（引自林倫倫《潮劇是用哪個地方的方言來演唱的？》）\n\n今日要講的是明朝一段跟名妓玉堂春有關的冤案。請看視頻（時長 4:35:52）：\n<iframe width=\"720\" height=\"480\" src=\"https://www.youtube.com/embed/_F8IQgDZjnw\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n\n<!--more-->\n\n## 故事概要\n蘇三，花名玉堂春，原名周玉潔，明朝山西大同府周家莊人，因被販賣到燕京的「蘇淮妓院」而改姓蘇，又在妓女中排行第三，是爲蘇三。在馮夢龍版的故事裏，故事的男主角叫王景隆，其父令其到燕京收債，得銀三萬兩，遂到妓院尋歡，傾盡身資，佔有了才貌雙全的蘇三，兩人許下山盟海誓。不到一年，身資喪盡，被鴇婆趕出妓院。蘇三勸王景隆考取功名，王景隆回到金陵，奮發圖強，上京趕考，中了進士，選任真定府理刑判官。後爲父所迫，娶了劉都堂之女爲妻。\n\n另一方面，蘇三被老鴇以白銀一千兩百兩賣給山西洪洞縣馬販沈洪爲妾，因記與王景隆之山盟，不肯與沈洪同牀。沈洪正室皮氏與趙監生昴有姦情，聯合毒害了沈洪，並栽贓給蘇三，賄賂官府。蘇三遂入獄。\n\n恰逢王景隆改任山西八府巡按，得知蘇三犯了死罪，感念昔日恩情，微服私訪，探查蘇三冤情，後命縣衙起解蘇三等到太原府三堂會審。後沉冤昭雪，知縣被革職查辦，趙昴、皮氏被正法，蘇三獲釋。\n\n在各大劇中，王景隆被改爲王金龍，潮劇也不例外。潮劇中故事情節多有改動，但大體如此。本次欣賞的是林初發飾演王金龍、張儀鳳飾演蘇三的版本，唱腔依循黃欽賜，可從梅雪亭中「風啊……，風卷松聲魂欲銷，愁人慘境筆墨難描」唱段看出。\n\n網絡上蒐集的潮劇《玉堂春》相關歷史脈絡：\n- 明朝，馮夢龍《警世通言》第24卷《玉堂春落難逢夫》。\n- 20世紀30年代，**林如烈**編導《王金龍》，即《玉堂春》。\n-  1962年，潮劇元華潮劇團排演《梅亭雪》。該折子戲以林如烈的《玉堂春》中「雪淚情天」一折爲藍本。劇本整理謝吟、王老漢（王菲）、何苦（吳南生），作曲黃玉鬥、金林表、吳錫有，導演翁炳林。\n- 1981年，廣東潮劇院整理《梅亭雪》。劇本整理謝吟、王菲、鄭文風，唱腔設計**黃欽賜**，導演吳峰。由姚璇秋、鄭小霞飾蘇三，陳麗華、陳瑜飾王金龍，李有存、鄭蔡岳、林建東飾獄吏，謝素貞、馬嬋如飾獄婆。林如烈的雪淚情天，以「風打松聲儂心焦，愁人慘境筆墨難描」爲開始，是爲「如烈曲」；黃欽賜的梅亭雪，以「風啊……，風卷松聲魂欲銷，愁人慘境筆墨難描」爲開始。\n\n## 潮劇筆記\n\n### 上集第一場 \n故事概要：鴇婆強迫蘇三梳攏接客，蘇三拒絕遭打。王金龍出銀百兩解救蘇三，與蘇三一見鍾情。\n1. 5:01 衋(gêg⁴)心：傷心。\n2. 5:13 煩惱(huang⁵ lo²)：擔心。\n3. 5:22 變(bin³)作寶。\n4. 5:44 相(siên³)輔：幫忙。\n5. 5:58 祭到這老：吃到這麼老。祭，七月半祭孤，餓鬼來享用食物。所以用「祭孤」/「祭」來指人像餓鬼一般狼吞虎嚥或者沒有勞動坐享其成。\n6. 7:24 鴇(bao²)婆。\n7. 9:12 人客：客人。\n8. 10:10 雨來囉：不是說真的雨來了，通常在認爲別人的話語或行爲不合邏輯或不合時宜時會這樣出言制止。\n9. 10:31 梳攏(siu¹ lang⁵)：指妓女首次接客。妓院中處女只梳辮，接客後梳髻，稱「梳攏」。\n10. 10:55 十五貫錢，買作菜脯，儉儉好食一年。\n11. 10:59 鄙相(pi² siên³)：看人低賤，抑是用話來罵人低賤的意思。同義的有「睇相」。\n12. 11:27 個面七個空，怎知汝是乜人。\n13. 11:37 縣衙(guin⁷ ghê⁵)。\n14. 11:41 頭欹欹(ki¹)：歪頭狀。\n15. 11:57 常來常往，若敢胡來，就著知慘。\n16. 12:47 稍(ciao²)候。\n17. 13:10 至切：一定。如：至切勿上錯牀。\n18. 15:04 吃(ngeg⁴)。\n19. 15:48 參詳：商量。如：這事好參詳。\n20. 15:49 偪側(bêg⁴ cêg⁴)：逼迫。\n21. 16:14 娉婷(pêng³ têng⁵)。\n22. 16:53 後生人：年輕人。\n23. 16:54 通朗(tang¹ lang⁵)：洞明事理。如：呾話唔通朗。\n24. 17:03 愈更：更加。如：愈更胡說。\n25. 17:20 強扭之瓜不甜，強掰之花不香。\n26. 17:37 翹楚：翹，高出仰起。楚，荊木，可做杖。翹楚是高出一般灌木的荊木。喻指厲害、超群。如：你若翹楚，同樣𢭪(kiêh⁸ 拿)出三十兩銀。\n\n### 上集第二場\n故事概要：王金龍三萬兩銀錢爲蘇三建了留春院北樓，飲酒作樂過了一年。其父發覺後到留春院將其掠回處置。\n1. 21:14王(hêng⁵)瓊。\n2. 23:09 才華洋溢(iang⁵ êg⁸)。\n3. 25:12 鴛鴦(uang¹ iang¹)。\n4. 27:56 絢(sung¹)麗。\n5. 28:09 秦樓楚館煙(ing¹)花地。\n6. 30:30 銅錢落草草會青，豈容坐食破大家。\n7. 30:42 仔細：客氣。如：免仔細。\n8. 30:43 熟人免行生(cên¹)禮(loi²)。\n9. 32:02 一朝無食夫妻無義。\n10. 33:33 沈溺(dim⁵ nêg⁸)。\n11. 33:33 紈絝(iang⁵ kou³)子弟。\n12. 33:51 戰戰兢兢(kêng¹)。\n13. 35:08 食罪陷百罹(li⁵)。\n14. 38:15 鵬程(pong⁵ têng⁵)。\n15. 38:30 擔承：承擔。\n16. 39:25 畜(têg⁴)生。\n17. 40:00 戲歇棚拆：比喻世態炎涼，人情淡薄，類似的有「人走茶涼」。\n18. 40:13 如其不然。\n\n### 上集第三場 關王廟♥️\n![](teochew-opera-ghêgdengcung/2020-10-14-12.41.34.png)\n故事概要：蘇三以爲王金龍已被其父打死，遂前往關王廟祭奠王金龍。而殊不知王金龍僥倖逃脫，淪落爲乞丐，剛好也在關王廟。蘇三勸王金龍應效仿呂蒙正去考取功名。\n1. 41:40 奇事年年有，無年奇相同。\n2. 42:00 花子(hua¹ ze²)：叫花子。\n3. 42:13 庵寺：尼寺、僧寺的通稱。\n4. 42:24 照書行事。\n5. 44:42 膠漆(ga¹ cag⁴)。如：情如膠漆割捨不能。\n6. 45:16 殷勤(heng¹ keng⁵)。\n7. 46:57 人事不省(sêng³)。\n8. 48:12 五行：面相，處境。\n9. 48:37 忍淚吞聲(sêng¹)。\n10. 49:35 訴(su³)苦。\n11. 49:35 顏(nguang⁵)色。\n12. 50:13 烏雲密佈(bu³)。\n13. 50:24 時運不濟。\n14. 52:21 鶉(sung⁵)衣百結(gag⁴)：鵪鶉小頭禿尾， 羽毛赤褐色，雜有暗黃色斑點和條文，像一件沒有下擺，布滿補丁的衣服。形容衣服破爛不堪。\n15. 53:52 坫(diam³)：躲藏。如：走去坫牀下。\n16. 55:09 祭奠(diang⁶)。\n17. 56:14 齊備(ci⁵ bi⁶)：齊全完備。\n18. 56:21 包山包海：包攬全活。如：爲儉錢銀，一人包山包海。\n19. 1:00:27 愁雲冉冉難見晴空。\n20. 1:00:49 飛禍疊(tah⁸)至慘無窮。\n21. 1:01:13 噩耗(ngag⁸ ho³)。\n22. 1:04:35 衣衫襤褸(nam⁵ nu²)。\n23. 1:05:08 邂逅(hai⁶ hou⁶)。\n24. 1:05:44 一霎(siab⁴)時。\n25. 1:07:09 果(guan²)然。\n26. 1:07:17 妾願隨君陰曹去，從此聚首不分離。\n27. 1:09:23 嗟嘆(za¹ tam³)。\n28. 1:09:55 寂寞(sog⁴ mog⁸)。\n29. 1:10:49 啜(coih⁴)泣。\n30. 1:11:43 甌：大碗。\n31. 1:11:44 箸：筷子。\n32. 1:13:22 朱買臣：字翁子，西漢會稽吳人。家貧好學，以賣薪自給，妻羞之，改適他人，後買臣顯貴，婦慚，自縊而死；買臣官至丞相長史，因與張湯相傾軋，遭誅殺。\n33. 1:13:33 呂蒙正(mong⁵ zêng³)：宋朝人，自幼父母雙亡，因此淪落爲乞丐，但其非常好學，把分來的錢都會拿去買書。因其在尚未發達當官之前，白天乞討，並投靠於佛院，晚上住於破窯。\n34. 1:16:52 鄭元和：元石君寶李亞仙花酒曲江池雜劇中的人物。鄭元和爲洛陽府尹鄭公弼的兒子，因與妓女李亞仙相戀，以致散盡錢財，荒廢學業，淪爲乞丐。歷盡一番滄桑後，終在李亞仙的鼓勵下，專心向學，得以應試高中，返家團圓。\n\n### 上集第四場\n故事概要：蘇三被留春院賣給馬販沈洪爲妾。王金龍回鄉備考，途中盤纏被劫。\n1. 1:19:22 未是孥囝砌宮闈，騙汝好怎呢？\n2. 1:19:48 排比：不是指修辭手法，而是安排的意思。《全唐詩．卷七九八．花蕊夫人．宮詞》：「今宵駕幸池頭宿，排比椒房得暖無。」\n3. 1:22:48 主僕(bog⁸)。\n4. 1:22:58 擺踩：調侃、嘲弄、嘲諷、批評。「踩」字存疑。如：奴才，敢掠阿爺來擺踩。\n5. 1:23:15 會哩開嘴，𠀾就放屁，一旁咬蝨(sag⁴)。\n6. 1:26:29 惆悵(tiu⁵ ziang³)。\n7. 1:26:46 贖(sog⁸)身。\n8. 1:26:48 解倒懸(dao² hiang⁵)：倒懸，縛人兩足倒掛。比喻極爲困苦。解倒懸比喻解救人於困苦之境。\n9. 1:30:53 主施：不是施主的意思，而是處理的意思。如：進退兩難怎主施？\n\n### 上集第五場\n故事概要：沈洪妻子皮氏下毒麵欲殺蘇三，不料蘇三拒食，湯麵爲沈洪所食，暴斃。\n1. 1:34:11 眼中釘(ding¹/dêng¹)。\n2. 1:40:47 聰穎(kêng²)。\n3. 1:41:22 物輕意重。\n4. 1:42:26 狗母蛇假龍。\n5. 1:42:45 好心分你作歹意。\n6. 1:42:56 皮燈籠，肚內明。\n7. 1:43:45 二山相疊出出出。\n8. 1:48:16 拖三延四。\n9. 1:51:36 糙米錔(tag⁴)空臼(ku⁶)。\n\n### 上集第六場 縣衙公堂\n故事概要：皮氏連同情夫趙監生賄賂縣太爺，蘇三遭屈打成招、打入死牢。\n1. 2:01:17 踉蹌(lang⁵ cang¹)。如：步履踉蹌肝腸斷。\n2. 2:01:17 淚涔涔(ngim⁵)。如：百感交集淚涔涔。\n3. 2:02:53 嫩(lung³)。如：鮮花嫩蕊悅死鬼。\n4. 2:04:25 蛇蠍(hiah⁴)心腸(ciang⁵)。\n5. 2:05:40 好貨墊底。\n6. 2:09:42 砒(bi¹)霜。\n7. 2:11:02 舵(dua⁶)。如：轉舵往回走。\n8. 2:14:41 因依：原委、緣由。如：時晴時雨何因依。\n9. 2:15:21 呼嘯(hu¹ sao³)。如：狂風呼嘯心膽寒。\n10. 2:17:32 死牢(lo⁵)。\n\n### 下集第一場\n故事概要：王金龍中了進士，封官到太原府任巡按。路過洪洞縣，調查蘇三的冤情並命縣令將蘇三起解太原。\n1. 名譽(u⁶)。\n2. 花腳：比喻閒游浪蕩﹑愛串門子的人。如：一個花腳，一個風流。\n3. 蹺蹊(kiao¹ ki¹)：蹊蹺。\n\n### 下集第二場 荒野 ♥️\n![](teochew-opera-ghêgdengcung/2020-10-15-1.10.20.png)\n故事概要：蘇三起解太原。解差程公道知道蘇三的冤情後，中途休息時爲其解開枷鎖，並令其將訴狀放到枷鎖中以避免被搜身。蘇三感恩，認程公道爲乾爹。\n1. 2:35:13 蘇三(sam¹)離了洪洞(tong⁵)境，一步一淚暗傷(siang¹)情。\n2. 2:36:54 跋涉(buag⁸ siab⁴)。\n3. 2:37:35 拚駁：盡力辯駁。\n4. 2:41:20 勿許生哩免這生，欲許生哩著這生。\n5. 2:42:18 含冤負屈。\n6. 2:48:07 顧身都唔離(li⁷)：照顧自己都不能全，無法放開手腳去理會他人。離：放開。\n7. 2:49:18 一死如死，現死駁賒死。\n8. 2:50:53 合(hah⁸)卺(geng²)酒：卺，古代結婚時用作酒器的一種瓢。舊時夫妻結婚的一種儀式，把一個匏瓜剖成兩個瓢，新郎新娘各拿一個飲酒。\n9. 2:51:33 契走囝：乾女兒。走，是諸母(za¹ bhou²，泛指婦女)的合音借詞。\n\n### 下集第三場 太原府公堂 ♥️\n![](teochew-opera-ghêgdengcung/2020-10-15-1.11.30.png)\n故事概要：王巡按金龍，連同按察使何布政使，三司會審蘇三。按察使、布政使戲弄王金龍。\n1. 2:55:28布(bu³)政使(sai³)，官名。\n2. 2:59:24寸步難行(hêng⁵)。\n3. 3:03:13 昏厥(kiag⁴)。\n4. 3:12:26 修葺(cib⁴)。\n5. 3:16:50 梟(hiao¹)情絕義：無情無義。\n6. 3:20:18 吹毛求疵(cuê¹ mo⁵ kiu⁵ ce⁵)。\n\n### 下集第四場\n故事概要：皮氏到太原按察使劉秉義府，以金環、金釵賄賂其妻。按察使大公無私，設下凍雪計。\n1. 3:28:46 金釵(toi¹)。\n2. 3:29:16 擺宴(ang³)。\n3. 3:31:55 家無常禮(li²)。\n\n### 下集第五場♥️ 城外五里亭（梅亭）\n![](teochew-opera-ghêgdengcung/2020-10-15-1.12.28.png)\n故事概要：蘇三被按察使置於梅亭，是夜，大雪紛飛，天寒地凍。王金龙冒雪前往看望。兩人互訴衷情。按察使暗中觀看，察明案情。\n1. 3:37:56 怨疊疊(tah⁸)，恨重重。\n2. 3:41:05 履(li²)薄衣單(dang¹)。\n3. 3:42:05 證(zêng³)龜成(zian⁵)鱉：將烏龜說成甲魚，比喻蓄意歪曲，顛倒是非。同義詞有「指鹿爲馬」。\n4. 3:44:04 坐摩(mua⁵)些。摩，近。\n5. 3:46:11 風呀……風卷松聲魂欲銷，愁人慘境筆墨難描。\n6. 3:55:39 啱(ngam¹)：恰好。\n7. 3.58:33得魚忘筌(cuang⁵)：指捕得到了魚，便忘掉了用來捕魚的筌。比喻悟道者忘其形骸。也比喻人在達到目的以後，就忘記他賴以成功的憑藉。\n8. 4:01:06 假惺惺(sêng¹)。\n9. 4:01:07 寒夜無燈心自明。\n10. 4:08:46 失寵(tong²)。\n11. 4:17:10 珍重(diang¹ dong⁶)。\n12. 4:19:12 草芥(gai⁶)。如：功名利祿如草芥。\n\n### 下集第六場\n故事概要：三司再審蘇三案，眾招供，皮巧英被判終生監禁，趙監生被判秋後處斬，洪洞縣縣令被革職查辦，蘇三無罪釋放。沈冤得雪，歌舞收場。\n1. 4:21:35 親幫親，鄰幫鄰，老鼠幫戶蠅。戶蠅，蒼蠅。\n2. 4:27:25 馬入中宮(dong¹ giong¹)，𠀾死必凶。\n3. 4:30:06 助紂(diu⁶)爲虐(ngiag⁸)。\n","source":"_posts/language/min/teochew-opera-ghêgdengcung.md","raw":"---\ntitle: 在潮劇中學之《玉堂春》\np: language/min/teochew-opera-ghêgdengcung\ntags:\n- 潮劇\n- 潮州話\n- 閩南語\n---\n\n潮劇自明朝已然形成，發展到現在有近 500 年的歷史，據統計截止 2007 年 6 月已有超過 5000 個劇目。明朝嘉靖丙寅年（1566年）刊本的《荔鏡記》，是迄今所能見到的最早一個運用「泉潮腔」演唱的演出劇本。它於 2006 年被列入首批國家級非物質文化遺產保護名錄。\n\n潮劇的語音特點是：最早的潮劇基本上是以潮州府城音爲主要音系來表演的，但迴避了潮州音的最明顯的特徵音韻母——潮州府城話的 iêng/iêg、uêng/uêg、iêm/iêb 等韻母，換成了跟其他方言相同的 iang/iag、uang/uag 和 iam/iab 韻母。然後，還參雜了揭陽話的一些特點。（引自林倫倫《潮劇是用哪個地方的方言來演唱的？》）\n\n今日要講的是明朝一段跟名妓玉堂春有關的冤案。請看視頻（時長 4:35:52）：\n<iframe width=\"720\" height=\"480\" src=\"https://www.youtube.com/embed/_F8IQgDZjnw\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n\n<!--more-->\n\n## 故事概要\n蘇三，花名玉堂春，原名周玉潔，明朝山西大同府周家莊人，因被販賣到燕京的「蘇淮妓院」而改姓蘇，又在妓女中排行第三，是爲蘇三。在馮夢龍版的故事裏，故事的男主角叫王景隆，其父令其到燕京收債，得銀三萬兩，遂到妓院尋歡，傾盡身資，佔有了才貌雙全的蘇三，兩人許下山盟海誓。不到一年，身資喪盡，被鴇婆趕出妓院。蘇三勸王景隆考取功名，王景隆回到金陵，奮發圖強，上京趕考，中了進士，選任真定府理刑判官。後爲父所迫，娶了劉都堂之女爲妻。\n\n另一方面，蘇三被老鴇以白銀一千兩百兩賣給山西洪洞縣馬販沈洪爲妾，因記與王景隆之山盟，不肯與沈洪同牀。沈洪正室皮氏與趙監生昴有姦情，聯合毒害了沈洪，並栽贓給蘇三，賄賂官府。蘇三遂入獄。\n\n恰逢王景隆改任山西八府巡按，得知蘇三犯了死罪，感念昔日恩情，微服私訪，探查蘇三冤情，後命縣衙起解蘇三等到太原府三堂會審。後沉冤昭雪，知縣被革職查辦，趙昴、皮氏被正法，蘇三獲釋。\n\n在各大劇中，王景隆被改爲王金龍，潮劇也不例外。潮劇中故事情節多有改動，但大體如此。本次欣賞的是林初發飾演王金龍、張儀鳳飾演蘇三的版本，唱腔依循黃欽賜，可從梅雪亭中「風啊……，風卷松聲魂欲銷，愁人慘境筆墨難描」唱段看出。\n\n網絡上蒐集的潮劇《玉堂春》相關歷史脈絡：\n- 明朝，馮夢龍《警世通言》第24卷《玉堂春落難逢夫》。\n- 20世紀30年代，**林如烈**編導《王金龍》，即《玉堂春》。\n-  1962年，潮劇元華潮劇團排演《梅亭雪》。該折子戲以林如烈的《玉堂春》中「雪淚情天」一折爲藍本。劇本整理謝吟、王老漢（王菲）、何苦（吳南生），作曲黃玉鬥、金林表、吳錫有，導演翁炳林。\n- 1981年，廣東潮劇院整理《梅亭雪》。劇本整理謝吟、王菲、鄭文風，唱腔設計**黃欽賜**，導演吳峰。由姚璇秋、鄭小霞飾蘇三，陳麗華、陳瑜飾王金龍，李有存、鄭蔡岳、林建東飾獄吏，謝素貞、馬嬋如飾獄婆。林如烈的雪淚情天，以「風打松聲儂心焦，愁人慘境筆墨難描」爲開始，是爲「如烈曲」；黃欽賜的梅亭雪，以「風啊……，風卷松聲魂欲銷，愁人慘境筆墨難描」爲開始。\n\n## 潮劇筆記\n\n### 上集第一場 \n故事概要：鴇婆強迫蘇三梳攏接客，蘇三拒絕遭打。王金龍出銀百兩解救蘇三，與蘇三一見鍾情。\n1. 5:01 衋(gêg⁴)心：傷心。\n2. 5:13 煩惱(huang⁵ lo²)：擔心。\n3. 5:22 變(bin³)作寶。\n4. 5:44 相(siên³)輔：幫忙。\n5. 5:58 祭到這老：吃到這麼老。祭，七月半祭孤，餓鬼來享用食物。所以用「祭孤」/「祭」來指人像餓鬼一般狼吞虎嚥或者沒有勞動坐享其成。\n6. 7:24 鴇(bao²)婆。\n7. 9:12 人客：客人。\n8. 10:10 雨來囉：不是說真的雨來了，通常在認爲別人的話語或行爲不合邏輯或不合時宜時會這樣出言制止。\n9. 10:31 梳攏(siu¹ lang⁵)：指妓女首次接客。妓院中處女只梳辮，接客後梳髻，稱「梳攏」。\n10. 10:55 十五貫錢，買作菜脯，儉儉好食一年。\n11. 10:59 鄙相(pi² siên³)：看人低賤，抑是用話來罵人低賤的意思。同義的有「睇相」。\n12. 11:27 個面七個空，怎知汝是乜人。\n13. 11:37 縣衙(guin⁷ ghê⁵)。\n14. 11:41 頭欹欹(ki¹)：歪頭狀。\n15. 11:57 常來常往，若敢胡來，就著知慘。\n16. 12:47 稍(ciao²)候。\n17. 13:10 至切：一定。如：至切勿上錯牀。\n18. 15:04 吃(ngeg⁴)。\n19. 15:48 參詳：商量。如：這事好參詳。\n20. 15:49 偪側(bêg⁴ cêg⁴)：逼迫。\n21. 16:14 娉婷(pêng³ têng⁵)。\n22. 16:53 後生人：年輕人。\n23. 16:54 通朗(tang¹ lang⁵)：洞明事理。如：呾話唔通朗。\n24. 17:03 愈更：更加。如：愈更胡說。\n25. 17:20 強扭之瓜不甜，強掰之花不香。\n26. 17:37 翹楚：翹，高出仰起。楚，荊木，可做杖。翹楚是高出一般灌木的荊木。喻指厲害、超群。如：你若翹楚，同樣𢭪(kiêh⁸ 拿)出三十兩銀。\n\n### 上集第二場\n故事概要：王金龍三萬兩銀錢爲蘇三建了留春院北樓，飲酒作樂過了一年。其父發覺後到留春院將其掠回處置。\n1. 21:14王(hêng⁵)瓊。\n2. 23:09 才華洋溢(iang⁵ êg⁸)。\n3. 25:12 鴛鴦(uang¹ iang¹)。\n4. 27:56 絢(sung¹)麗。\n5. 28:09 秦樓楚館煙(ing¹)花地。\n6. 30:30 銅錢落草草會青，豈容坐食破大家。\n7. 30:42 仔細：客氣。如：免仔細。\n8. 30:43 熟人免行生(cên¹)禮(loi²)。\n9. 32:02 一朝無食夫妻無義。\n10. 33:33 沈溺(dim⁵ nêg⁸)。\n11. 33:33 紈絝(iang⁵ kou³)子弟。\n12. 33:51 戰戰兢兢(kêng¹)。\n13. 35:08 食罪陷百罹(li⁵)。\n14. 38:15 鵬程(pong⁵ têng⁵)。\n15. 38:30 擔承：承擔。\n16. 39:25 畜(têg⁴)生。\n17. 40:00 戲歇棚拆：比喻世態炎涼，人情淡薄，類似的有「人走茶涼」。\n18. 40:13 如其不然。\n\n### 上集第三場 關王廟♥️\n![](teochew-opera-ghêgdengcung/2020-10-14-12.41.34.png)\n故事概要：蘇三以爲王金龍已被其父打死，遂前往關王廟祭奠王金龍。而殊不知王金龍僥倖逃脫，淪落爲乞丐，剛好也在關王廟。蘇三勸王金龍應效仿呂蒙正去考取功名。\n1. 41:40 奇事年年有，無年奇相同。\n2. 42:00 花子(hua¹ ze²)：叫花子。\n3. 42:13 庵寺：尼寺、僧寺的通稱。\n4. 42:24 照書行事。\n5. 44:42 膠漆(ga¹ cag⁴)。如：情如膠漆割捨不能。\n6. 45:16 殷勤(heng¹ keng⁵)。\n7. 46:57 人事不省(sêng³)。\n8. 48:12 五行：面相，處境。\n9. 48:37 忍淚吞聲(sêng¹)。\n10. 49:35 訴(su³)苦。\n11. 49:35 顏(nguang⁵)色。\n12. 50:13 烏雲密佈(bu³)。\n13. 50:24 時運不濟。\n14. 52:21 鶉(sung⁵)衣百結(gag⁴)：鵪鶉小頭禿尾， 羽毛赤褐色，雜有暗黃色斑點和條文，像一件沒有下擺，布滿補丁的衣服。形容衣服破爛不堪。\n15. 53:52 坫(diam³)：躲藏。如：走去坫牀下。\n16. 55:09 祭奠(diang⁶)。\n17. 56:14 齊備(ci⁵ bi⁶)：齊全完備。\n18. 56:21 包山包海：包攬全活。如：爲儉錢銀，一人包山包海。\n19. 1:00:27 愁雲冉冉難見晴空。\n20. 1:00:49 飛禍疊(tah⁸)至慘無窮。\n21. 1:01:13 噩耗(ngag⁸ ho³)。\n22. 1:04:35 衣衫襤褸(nam⁵ nu²)。\n23. 1:05:08 邂逅(hai⁶ hou⁶)。\n24. 1:05:44 一霎(siab⁴)時。\n25. 1:07:09 果(guan²)然。\n26. 1:07:17 妾願隨君陰曹去，從此聚首不分離。\n27. 1:09:23 嗟嘆(za¹ tam³)。\n28. 1:09:55 寂寞(sog⁴ mog⁸)。\n29. 1:10:49 啜(coih⁴)泣。\n30. 1:11:43 甌：大碗。\n31. 1:11:44 箸：筷子。\n32. 1:13:22 朱買臣：字翁子，西漢會稽吳人。家貧好學，以賣薪自給，妻羞之，改適他人，後買臣顯貴，婦慚，自縊而死；買臣官至丞相長史，因與張湯相傾軋，遭誅殺。\n33. 1:13:33 呂蒙正(mong⁵ zêng³)：宋朝人，自幼父母雙亡，因此淪落爲乞丐，但其非常好學，把分來的錢都會拿去買書。因其在尚未發達當官之前，白天乞討，並投靠於佛院，晚上住於破窯。\n34. 1:16:52 鄭元和：元石君寶李亞仙花酒曲江池雜劇中的人物。鄭元和爲洛陽府尹鄭公弼的兒子，因與妓女李亞仙相戀，以致散盡錢財，荒廢學業，淪爲乞丐。歷盡一番滄桑後，終在李亞仙的鼓勵下，專心向學，得以應試高中，返家團圓。\n\n### 上集第四場\n故事概要：蘇三被留春院賣給馬販沈洪爲妾。王金龍回鄉備考，途中盤纏被劫。\n1. 1:19:22 未是孥囝砌宮闈，騙汝好怎呢？\n2. 1:19:48 排比：不是指修辭手法，而是安排的意思。《全唐詩．卷七九八．花蕊夫人．宮詞》：「今宵駕幸池頭宿，排比椒房得暖無。」\n3. 1:22:48 主僕(bog⁸)。\n4. 1:22:58 擺踩：調侃、嘲弄、嘲諷、批評。「踩」字存疑。如：奴才，敢掠阿爺來擺踩。\n5. 1:23:15 會哩開嘴，𠀾就放屁，一旁咬蝨(sag⁴)。\n6. 1:26:29 惆悵(tiu⁵ ziang³)。\n7. 1:26:46 贖(sog⁸)身。\n8. 1:26:48 解倒懸(dao² hiang⁵)：倒懸，縛人兩足倒掛。比喻極爲困苦。解倒懸比喻解救人於困苦之境。\n9. 1:30:53 主施：不是施主的意思，而是處理的意思。如：進退兩難怎主施？\n\n### 上集第五場\n故事概要：沈洪妻子皮氏下毒麵欲殺蘇三，不料蘇三拒食，湯麵爲沈洪所食，暴斃。\n1. 1:34:11 眼中釘(ding¹/dêng¹)。\n2. 1:40:47 聰穎(kêng²)。\n3. 1:41:22 物輕意重。\n4. 1:42:26 狗母蛇假龍。\n5. 1:42:45 好心分你作歹意。\n6. 1:42:56 皮燈籠，肚內明。\n7. 1:43:45 二山相疊出出出。\n8. 1:48:16 拖三延四。\n9. 1:51:36 糙米錔(tag⁴)空臼(ku⁶)。\n\n### 上集第六場 縣衙公堂\n故事概要：皮氏連同情夫趙監生賄賂縣太爺，蘇三遭屈打成招、打入死牢。\n1. 2:01:17 踉蹌(lang⁵ cang¹)。如：步履踉蹌肝腸斷。\n2. 2:01:17 淚涔涔(ngim⁵)。如：百感交集淚涔涔。\n3. 2:02:53 嫩(lung³)。如：鮮花嫩蕊悅死鬼。\n4. 2:04:25 蛇蠍(hiah⁴)心腸(ciang⁵)。\n5. 2:05:40 好貨墊底。\n6. 2:09:42 砒(bi¹)霜。\n7. 2:11:02 舵(dua⁶)。如：轉舵往回走。\n8. 2:14:41 因依：原委、緣由。如：時晴時雨何因依。\n9. 2:15:21 呼嘯(hu¹ sao³)。如：狂風呼嘯心膽寒。\n10. 2:17:32 死牢(lo⁵)。\n\n### 下集第一場\n故事概要：王金龍中了進士，封官到太原府任巡按。路過洪洞縣，調查蘇三的冤情並命縣令將蘇三起解太原。\n1. 名譽(u⁶)。\n2. 花腳：比喻閒游浪蕩﹑愛串門子的人。如：一個花腳，一個風流。\n3. 蹺蹊(kiao¹ ki¹)：蹊蹺。\n\n### 下集第二場 荒野 ♥️\n![](teochew-opera-ghêgdengcung/2020-10-15-1.10.20.png)\n故事概要：蘇三起解太原。解差程公道知道蘇三的冤情後，中途休息時爲其解開枷鎖，並令其將訴狀放到枷鎖中以避免被搜身。蘇三感恩，認程公道爲乾爹。\n1. 2:35:13 蘇三(sam¹)離了洪洞(tong⁵)境，一步一淚暗傷(siang¹)情。\n2. 2:36:54 跋涉(buag⁸ siab⁴)。\n3. 2:37:35 拚駁：盡力辯駁。\n4. 2:41:20 勿許生哩免這生，欲許生哩著這生。\n5. 2:42:18 含冤負屈。\n6. 2:48:07 顧身都唔離(li⁷)：照顧自己都不能全，無法放開手腳去理會他人。離：放開。\n7. 2:49:18 一死如死，現死駁賒死。\n8. 2:50:53 合(hah⁸)卺(geng²)酒：卺，古代結婚時用作酒器的一種瓢。舊時夫妻結婚的一種儀式，把一個匏瓜剖成兩個瓢，新郎新娘各拿一個飲酒。\n9. 2:51:33 契走囝：乾女兒。走，是諸母(za¹ bhou²，泛指婦女)的合音借詞。\n\n### 下集第三場 太原府公堂 ♥️\n![](teochew-opera-ghêgdengcung/2020-10-15-1.11.30.png)\n故事概要：王巡按金龍，連同按察使何布政使，三司會審蘇三。按察使、布政使戲弄王金龍。\n1. 2:55:28布(bu³)政使(sai³)，官名。\n2. 2:59:24寸步難行(hêng⁵)。\n3. 3:03:13 昏厥(kiag⁴)。\n4. 3:12:26 修葺(cib⁴)。\n5. 3:16:50 梟(hiao¹)情絕義：無情無義。\n6. 3:20:18 吹毛求疵(cuê¹ mo⁵ kiu⁵ ce⁵)。\n\n### 下集第四場\n故事概要：皮氏到太原按察使劉秉義府，以金環、金釵賄賂其妻。按察使大公無私，設下凍雪計。\n1. 3:28:46 金釵(toi¹)。\n2. 3:29:16 擺宴(ang³)。\n3. 3:31:55 家無常禮(li²)。\n\n### 下集第五場♥️ 城外五里亭（梅亭）\n![](teochew-opera-ghêgdengcung/2020-10-15-1.12.28.png)\n故事概要：蘇三被按察使置於梅亭，是夜，大雪紛飛，天寒地凍。王金龙冒雪前往看望。兩人互訴衷情。按察使暗中觀看，察明案情。\n1. 3:37:56 怨疊疊(tah⁸)，恨重重。\n2. 3:41:05 履(li²)薄衣單(dang¹)。\n3. 3:42:05 證(zêng³)龜成(zian⁵)鱉：將烏龜說成甲魚，比喻蓄意歪曲，顛倒是非。同義詞有「指鹿爲馬」。\n4. 3:44:04 坐摩(mua⁵)些。摩，近。\n5. 3:46:11 風呀……風卷松聲魂欲銷，愁人慘境筆墨難描。\n6. 3:55:39 啱(ngam¹)：恰好。\n7. 3.58:33得魚忘筌(cuang⁵)：指捕得到了魚，便忘掉了用來捕魚的筌。比喻悟道者忘其形骸。也比喻人在達到目的以後，就忘記他賴以成功的憑藉。\n8. 4:01:06 假惺惺(sêng¹)。\n9. 4:01:07 寒夜無燈心自明。\n10. 4:08:46 失寵(tong²)。\n11. 4:17:10 珍重(diang¹ dong⁶)。\n12. 4:19:12 草芥(gai⁶)。如：功名利祿如草芥。\n\n### 下集第六場\n故事概要：三司再審蘇三案，眾招供，皮巧英被判終生監禁，趙監生被判秋後處斬，洪洞縣縣令被革職查辦，蘇三無罪釋放。沈冤得雪，歌舞收場。\n1. 4:21:35 親幫親，鄰幫鄰，老鼠幫戶蠅。戶蠅，蒼蠅。\n2. 4:27:25 馬入中宮(dong¹ giong¹)，𠀾死必凶。\n3. 4:30:06 助紂(diu⁶)爲虐(ngiag⁸)。\n","slug":"language/min/teochew-opera-ghêgdengcung","published":1,"date":"2020-10-15T05:16:09.930Z","updated":"2020-10-15T15:51:36.531Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cki72psxj000bslw86owdexyz","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css\"><p>潮劇自明朝已然形成，發展到現在有近 500 年的歷史，據統計截止 2007 年 6 月已有超過 5000 個劇目。明朝嘉靖丙寅年（1566年）刊本的《荔鏡記》，是迄今所能見到的最早一個運用「泉潮腔」演唱的演出劇本。它於 2006 年被列入首批國家級非物質文化遺產保護名錄。</p>\n<p>潮劇的語音特點是：最早的潮劇基本上是以潮州府城音爲主要音系來表演的，但迴避了潮州音的最明顯的特徵音韻母——潮州府城話的 iêng/iêg、uêng/uêg、iêm/iêb 等韻母，換成了跟其他方言相同的 iang/iag、uang/uag 和 iam/iab 韻母。然後，還參雜了揭陽話的一些特點。（引自林倫倫《潮劇是用哪個地方的方言來演唱的？》）</p>\n<p>今日要講的是明朝一段跟名妓玉堂春有關的冤案。請看視頻（時長 4:35:52）：</p>\n<iframe width=\"720\" height=\"480\" src=\"https://www.youtube.com/embed/_F8IQgDZjnw\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n\n<a id=\"more\"></a>\n\n<h2 id=\"故事概要\"><a href=\"#故事概要\" class=\"headerlink\" title=\"故事概要\"></a>故事概要</h2><p>蘇三，花名玉堂春，原名周玉潔，明朝山西大同府周家莊人，因被販賣到燕京的「蘇淮妓院」而改姓蘇，又在妓女中排行第三，是爲蘇三。在馮夢龍版的故事裏，故事的男主角叫王景隆，其父令其到燕京收債，得銀三萬兩，遂到妓院尋歡，傾盡身資，佔有了才貌雙全的蘇三，兩人許下山盟海誓。不到一年，身資喪盡，被鴇婆趕出妓院。蘇三勸王景隆考取功名，王景隆回到金陵，奮發圖強，上京趕考，中了進士，選任真定府理刑判官。後爲父所迫，娶了劉都堂之女爲妻。</p>\n<p>另一方面，蘇三被老鴇以白銀一千兩百兩賣給山西洪洞縣馬販沈洪爲妾，因記與王景隆之山盟，不肯與沈洪同牀。沈洪正室皮氏與趙監生昴有姦情，聯合毒害了沈洪，並栽贓給蘇三，賄賂官府。蘇三遂入獄。</p>\n<p>恰逢王景隆改任山西八府巡按，得知蘇三犯了死罪，感念昔日恩情，微服私訪，探查蘇三冤情，後命縣衙起解蘇三等到太原府三堂會審。後沉冤昭雪，知縣被革職查辦，趙昴、皮氏被正法，蘇三獲釋。</p>\n<p>在各大劇中，王景隆被改爲王金龍，潮劇也不例外。潮劇中故事情節多有改動，但大體如此。本次欣賞的是林初發飾演王金龍、張儀鳳飾演蘇三的版本，唱腔依循黃欽賜，可從梅雪亭中「風啊……，風卷松聲魂欲銷，愁人慘境筆墨難描」唱段看出。</p>\n<p>網絡上蒐集的潮劇《玉堂春》相關歷史脈絡：</p>\n<ul>\n<li>明朝，馮夢龍《警世通言》第24卷《玉堂春落難逢夫》。</li>\n<li>20世紀30年代，<strong>林如烈</strong>編導《王金龍》，即《玉堂春》。</li>\n<li>1962年，潮劇元華潮劇團排演《梅亭雪》。該折子戲以林如烈的《玉堂春》中「雪淚情天」一折爲藍本。劇本整理謝吟、王老漢（王菲）、何苦（吳南生），作曲黃玉鬥、金林表、吳錫有，導演翁炳林。</li>\n<li>1981年，廣東潮劇院整理《梅亭雪》。劇本整理謝吟、王菲、鄭文風，唱腔設計<strong>黃欽賜</strong>，導演吳峰。由姚璇秋、鄭小霞飾蘇三，陳麗華、陳瑜飾王金龍，李有存、鄭蔡岳、林建東飾獄吏，謝素貞、馬嬋如飾獄婆。林如烈的雪淚情天，以「風打松聲儂心焦，愁人慘境筆墨難描」爲開始，是爲「如烈曲」；黃欽賜的梅亭雪，以「風啊……，風卷松聲魂欲銷，愁人慘境筆墨難描」爲開始。</li>\n</ul>\n<h2 id=\"潮劇筆記\"><a href=\"#潮劇筆記\" class=\"headerlink\" title=\"潮劇筆記\"></a>潮劇筆記</h2><h3 id=\"上集第一場\"><a href=\"#上集第一場\" class=\"headerlink\" title=\"上集第一場\"></a>上集第一場</h3><p>故事概要：鴇婆強迫蘇三梳攏接客，蘇三拒絕遭打。王金龍出銀百兩解救蘇三，與蘇三一見鍾情。</p>\n<ol>\n<li>5:01 衋(gêg⁴)心：傷心。</li>\n<li>5:13 煩惱(huang⁵ lo²)：擔心。</li>\n<li>5:22 變(bin³)作寶。</li>\n<li>5:44 相(siên³)輔：幫忙。</li>\n<li>5:58 祭到這老：吃到這麼老。祭，七月半祭孤，餓鬼來享用食物。所以用「祭孤」/「祭」來指人像餓鬼一般狼吞虎嚥或者沒有勞動坐享其成。</li>\n<li>7:24 鴇(bao²)婆。</li>\n<li>9:12 人客：客人。</li>\n<li>10:10 雨來囉：不是說真的雨來了，通常在認爲別人的話語或行爲不合邏輯或不合時宜時會這樣出言制止。</li>\n<li>10:31 梳攏(siu¹ lang⁵)：指妓女首次接客。妓院中處女只梳辮，接客後梳髻，稱「梳攏」。</li>\n<li>10:55 十五貫錢，買作菜脯，儉儉好食一年。</li>\n<li>10:59 鄙相(pi² siên³)：看人低賤，抑是用話來罵人低賤的意思。同義的有「睇相」。</li>\n<li>11:27 個面七個空，怎知汝是乜人。</li>\n<li>11:37 縣衙(guin⁷ ghê⁵)。</li>\n<li>11:41 頭欹欹(ki¹)：歪頭狀。</li>\n<li>11:57 常來常往，若敢胡來，就著知慘。</li>\n<li>12:47 稍(ciao²)候。</li>\n<li>13:10 至切：一定。如：至切勿上錯牀。</li>\n<li>15:04 吃(ngeg⁴)。</li>\n<li>15:48 參詳：商量。如：這事好參詳。</li>\n<li>15:49 偪側(bêg⁴ cêg⁴)：逼迫。</li>\n<li>16:14 娉婷(pêng³ têng⁵)。</li>\n<li>16:53 後生人：年輕人。</li>\n<li>16:54 通朗(tang¹ lang⁵)：洞明事理。如：呾話唔通朗。</li>\n<li>17:03 愈更：更加。如：愈更胡說。</li>\n<li>17:20 強扭之瓜不甜，強掰之花不香。</li>\n<li>17:37 翹楚：翹，高出仰起。楚，荊木，可做杖。翹楚是高出一般灌木的荊木。喻指厲害、超群。如：你若翹楚，同樣𢭪(kiêh⁸ 拿)出三十兩銀。</li>\n</ol>\n<h3 id=\"上集第二場\"><a href=\"#上集第二場\" class=\"headerlink\" title=\"上集第二場\"></a>上集第二場</h3><p>故事概要：王金龍三萬兩銀錢爲蘇三建了留春院北樓，飲酒作樂過了一年。其父發覺後到留春院將其掠回處置。</p>\n<ol>\n<li>21:14王(hêng⁵)瓊。</li>\n<li>23:09 才華洋溢(iang⁵ êg⁸)。</li>\n<li>25:12 鴛鴦(uang¹ iang¹)。</li>\n<li>27:56 絢(sung¹)麗。</li>\n<li>28:09 秦樓楚館煙(ing¹)花地。</li>\n<li>30:30 銅錢落草草會青，豈容坐食破大家。</li>\n<li>30:42 仔細：客氣。如：免仔細。</li>\n<li>30:43 熟人免行生(cên¹)禮(loi²)。</li>\n<li>32:02 一朝無食夫妻無義。</li>\n<li>33:33 沈溺(dim⁵ nêg⁸)。</li>\n<li>33:33 紈絝(iang⁵ kou³)子弟。</li>\n<li>33:51 戰戰兢兢(kêng¹)。</li>\n<li>35:08 食罪陷百罹(li⁵)。</li>\n<li>38:15 鵬程(pong⁵ têng⁵)。</li>\n<li>38:30 擔承：承擔。</li>\n<li>39:25 畜(têg⁴)生。</li>\n<li>40:00 戲歇棚拆：比喻世態炎涼，人情淡薄，類似的有「人走茶涼」。</li>\n<li>40:13 如其不然。</li>\n</ol>\n<h3 id=\"上集第三場-關王廟♥️\"><a href=\"#上集第三場-關王廟♥️\" class=\"headerlink\" title=\"上集第三場 關王廟♥️\"></a>上集第三場 關王廟♥️</h3><p><img src=\"/2020/10/15/language/min/teochew-opera-ghêgdengcung/2020-10-14-12.41.34.png\" alt><br>故事概要：蘇三以爲王金龍已被其父打死，遂前往關王廟祭奠王金龍。而殊不知王金龍僥倖逃脫，淪落爲乞丐，剛好也在關王廟。蘇三勸王金龍應效仿呂蒙正去考取功名。</p>\n<ol>\n<li>41:40 奇事年年有，無年奇相同。</li>\n<li>42:00 花子(hua¹ ze²)：叫花子。</li>\n<li>42:13 庵寺：尼寺、僧寺的通稱。</li>\n<li>42:24 照書行事。</li>\n<li>44:42 膠漆(ga¹ cag⁴)。如：情如膠漆割捨不能。</li>\n<li>45:16 殷勤(heng¹ keng⁵)。</li>\n<li>46:57 人事不省(sêng³)。</li>\n<li>48:12 五行：面相，處境。</li>\n<li>48:37 忍淚吞聲(sêng¹)。</li>\n<li>49:35 訴(su³)苦。</li>\n<li>49:35 顏(nguang⁵)色。</li>\n<li>50:13 烏雲密佈(bu³)。</li>\n<li>50:24 時運不濟。</li>\n<li>52:21 鶉(sung⁵)衣百結(gag⁴)：鵪鶉小頭禿尾， 羽毛赤褐色，雜有暗黃色斑點和條文，像一件沒有下擺，布滿補丁的衣服。形容衣服破爛不堪。</li>\n<li>53:52 坫(diam³)：躲藏。如：走去坫牀下。</li>\n<li>55:09 祭奠(diang⁶)。</li>\n<li>56:14 齊備(ci⁵ bi⁶)：齊全完備。</li>\n<li>56:21 包山包海：包攬全活。如：爲儉錢銀，一人包山包海。</li>\n<li>1:00:27 愁雲冉冉難見晴空。</li>\n<li>1:00:49 飛禍疊(tah⁸)至慘無窮。</li>\n<li>1:01:13 噩耗(ngag⁸ ho³)。</li>\n<li>1:04:35 衣衫襤褸(nam⁵ nu²)。</li>\n<li>1:05:08 邂逅(hai⁶ hou⁶)。</li>\n<li>1:05:44 一霎(siab⁴)時。</li>\n<li>1:07:09 果(guan²)然。</li>\n<li>1:07:17 妾願隨君陰曹去，從此聚首不分離。</li>\n<li>1:09:23 嗟嘆(za¹ tam³)。</li>\n<li>1:09:55 寂寞(sog⁴ mog⁸)。</li>\n<li>1:10:49 啜(coih⁴)泣。</li>\n<li>1:11:43 甌：大碗。</li>\n<li>1:11:44 箸：筷子。</li>\n<li>1:13:22 朱買臣：字翁子，西漢會稽吳人。家貧好學，以賣薪自給，妻羞之，改適他人，後買臣顯貴，婦慚，自縊而死；買臣官至丞相長史，因與張湯相傾軋，遭誅殺。</li>\n<li>1:13:33 呂蒙正(mong⁵ zêng³)：宋朝人，自幼父母雙亡，因此淪落爲乞丐，但其非常好學，把分來的錢都會拿去買書。因其在尚未發達當官之前，白天乞討，並投靠於佛院，晚上住於破窯。</li>\n<li>1:16:52 鄭元和：元石君寶李亞仙花酒曲江池雜劇中的人物。鄭元和爲洛陽府尹鄭公弼的兒子，因與妓女李亞仙相戀，以致散盡錢財，荒廢學業，淪爲乞丐。歷盡一番滄桑後，終在李亞仙的鼓勵下，專心向學，得以應試高中，返家團圓。</li>\n</ol>\n<h3 id=\"上集第四場\"><a href=\"#上集第四場\" class=\"headerlink\" title=\"上集第四場\"></a>上集第四場</h3><p>故事概要：蘇三被留春院賣給馬販沈洪爲妾。王金龍回鄉備考，途中盤纏被劫。</p>\n<ol>\n<li>1:19:22 未是孥囝砌宮闈，騙汝好怎呢？</li>\n<li>1:19:48 排比：不是指修辭手法，而是安排的意思。《全唐詩．卷七九八．花蕊夫人．宮詞》：「今宵駕幸池頭宿，排比椒房得暖無。」</li>\n<li>1:22:48 主僕(bog⁸)。</li>\n<li>1:22:58 擺踩：調侃、嘲弄、嘲諷、批評。「踩」字存疑。如：奴才，敢掠阿爺來擺踩。</li>\n<li>1:23:15 會哩開嘴，𠀾就放屁，一旁咬蝨(sag⁴)。</li>\n<li>1:26:29 惆悵(tiu⁵ ziang³)。</li>\n<li>1:26:46 贖(sog⁸)身。</li>\n<li>1:26:48 解倒懸(dao² hiang⁵)：倒懸，縛人兩足倒掛。比喻極爲困苦。解倒懸比喻解救人於困苦之境。</li>\n<li>1:30:53 主施：不是施主的意思，而是處理的意思。如：進退兩難怎主施？</li>\n</ol>\n<h3 id=\"上集第五場\"><a href=\"#上集第五場\" class=\"headerlink\" title=\"上集第五場\"></a>上集第五場</h3><p>故事概要：沈洪妻子皮氏下毒麵欲殺蘇三，不料蘇三拒食，湯麵爲沈洪所食，暴斃。</p>\n<ol>\n<li>1:34:11 眼中釘(ding¹/dêng¹)。</li>\n<li>1:40:47 聰穎(kêng²)。</li>\n<li>1:41:22 物輕意重。</li>\n<li>1:42:26 狗母蛇假龍。</li>\n<li>1:42:45 好心分你作歹意。</li>\n<li>1:42:56 皮燈籠，肚內明。</li>\n<li>1:43:45 二山相疊出出出。</li>\n<li>1:48:16 拖三延四。</li>\n<li>1:51:36 糙米錔(tag⁴)空臼(ku⁶)。</li>\n</ol>\n<h3 id=\"上集第六場-縣衙公堂\"><a href=\"#上集第六場-縣衙公堂\" class=\"headerlink\" title=\"上集第六場 縣衙公堂\"></a>上集第六場 縣衙公堂</h3><p>故事概要：皮氏連同情夫趙監生賄賂縣太爺，蘇三遭屈打成招、打入死牢。</p>\n<ol>\n<li>2:01:17 踉蹌(lang⁵ cang¹)。如：步履踉蹌肝腸斷。</li>\n<li>2:01:17 淚涔涔(ngim⁵)。如：百感交集淚涔涔。</li>\n<li>2:02:53 嫩(lung³)。如：鮮花嫩蕊悅死鬼。</li>\n<li>2:04:25 蛇蠍(hiah⁴)心腸(ciang⁵)。</li>\n<li>2:05:40 好貨墊底。</li>\n<li>2:09:42 砒(bi¹)霜。</li>\n<li>2:11:02 舵(dua⁶)。如：轉舵往回走。</li>\n<li>2:14:41 因依：原委、緣由。如：時晴時雨何因依。</li>\n<li>2:15:21 呼嘯(hu¹ sao³)。如：狂風呼嘯心膽寒。</li>\n<li>2:17:32 死牢(lo⁵)。</li>\n</ol>\n<h3 id=\"下集第一場\"><a href=\"#下集第一場\" class=\"headerlink\" title=\"下集第一場\"></a>下集第一場</h3><p>故事概要：王金龍中了進士，封官到太原府任巡按。路過洪洞縣，調查蘇三的冤情並命縣令將蘇三起解太原。</p>\n<ol>\n<li>名譽(u⁶)。</li>\n<li>花腳：比喻閒游浪蕩﹑愛串門子的人。如：一個花腳，一個風流。</li>\n<li>蹺蹊(kiao¹ ki¹)：蹊蹺。</li>\n</ol>\n<h3 id=\"下集第二場-荒野-♥️\"><a href=\"#下集第二場-荒野-♥️\" class=\"headerlink\" title=\"下集第二場 荒野 ♥️\"></a>下集第二場 荒野 ♥️</h3><p><img src=\"/2020/10/15/language/min/teochew-opera-ghêgdengcung/2020-10-15-1.10.20.png\" alt><br>故事概要：蘇三起解太原。解差程公道知道蘇三的冤情後，中途休息時爲其解開枷鎖，並令其將訴狀放到枷鎖中以避免被搜身。蘇三感恩，認程公道爲乾爹。</p>\n<ol>\n<li>2:35:13 蘇三(sam¹)離了洪洞(tong⁵)境，一步一淚暗傷(siang¹)情。</li>\n<li>2:36:54 跋涉(buag⁸ siab⁴)。</li>\n<li>2:37:35 拚駁：盡力辯駁。</li>\n<li>2:41:20 勿許生哩免這生，欲許生哩著這生。</li>\n<li>2:42:18 含冤負屈。</li>\n<li>2:48:07 顧身都唔離(li⁷)：照顧自己都不能全，無法放開手腳去理會他人。離：放開。</li>\n<li>2:49:18 一死如死，現死駁賒死。</li>\n<li>2:50:53 合(hah⁸)卺(geng²)酒：卺，古代結婚時用作酒器的一種瓢。舊時夫妻結婚的一種儀式，把一個匏瓜剖成兩個瓢，新郎新娘各拿一個飲酒。</li>\n<li>2:51:33 契走囝：乾女兒。走，是諸母(za¹ bhou²，泛指婦女)的合音借詞。</li>\n</ol>\n<h3 id=\"下集第三場-太原府公堂-♥️\"><a href=\"#下集第三場-太原府公堂-♥️\" class=\"headerlink\" title=\"下集第三場 太原府公堂 ♥️\"></a>下集第三場 太原府公堂 ♥️</h3><p><img src=\"/2020/10/15/language/min/teochew-opera-ghêgdengcung/2020-10-15-1.11.30.png\" alt><br>故事概要：王巡按金龍，連同按察使何布政使，三司會審蘇三。按察使、布政使戲弄王金龍。</p>\n<ol>\n<li>2:55:28布(bu³)政使(sai³)，官名。</li>\n<li>2:59:24寸步難行(hêng⁵)。</li>\n<li>3:03:13 昏厥(kiag⁴)。</li>\n<li>3:12:26 修葺(cib⁴)。</li>\n<li>3:16:50 梟(hiao¹)情絕義：無情無義。</li>\n<li>3:20:18 吹毛求疵(cuê¹ mo⁵ kiu⁵ ce⁵)。</li>\n</ol>\n<h3 id=\"下集第四場\"><a href=\"#下集第四場\" class=\"headerlink\" title=\"下集第四場\"></a>下集第四場</h3><p>故事概要：皮氏到太原按察使劉秉義府，以金環、金釵賄賂其妻。按察使大公無私，設下凍雪計。</p>\n<ol>\n<li>3:28:46 金釵(toi¹)。</li>\n<li>3:29:16 擺宴(ang³)。</li>\n<li>3:31:55 家無常禮(li²)。</li>\n</ol>\n<h3 id=\"下集第五場♥️-城外五里亭（梅亭）\"><a href=\"#下集第五場♥️-城外五里亭（梅亭）\" class=\"headerlink\" title=\"下集第五場♥️ 城外五里亭（梅亭）\"></a>下集第五場♥️ 城外五里亭（梅亭）</h3><p><img src=\"/2020/10/15/language/min/teochew-opera-ghêgdengcung/2020-10-15-1.12.28.png\" alt><br>故事概要：蘇三被按察使置於梅亭，是夜，大雪紛飛，天寒地凍。王金龙冒雪前往看望。兩人互訴衷情。按察使暗中觀看，察明案情。</p>\n<ol>\n<li>3:37:56 怨疊疊(tah⁸)，恨重重。</li>\n<li>3:41:05 履(li²)薄衣單(dang¹)。</li>\n<li>3:42:05 證(zêng³)龜成(zian⁵)鱉：將烏龜說成甲魚，比喻蓄意歪曲，顛倒是非。同義詞有「指鹿爲馬」。</li>\n<li>3:44:04 坐摩(mua⁵)些。摩，近。</li>\n<li>3:46:11 風呀……風卷松聲魂欲銷，愁人慘境筆墨難描。</li>\n<li>3:55:39 啱(ngam¹)：恰好。</li>\n<li>3.58:33得魚忘筌(cuang⁵)：指捕得到了魚，便忘掉了用來捕魚的筌。比喻悟道者忘其形骸。也比喻人在達到目的以後，就忘記他賴以成功的憑藉。</li>\n<li>4:01:06 假惺惺(sêng¹)。</li>\n<li>4:01:07 寒夜無燈心自明。</li>\n<li>4:08:46 失寵(tong²)。</li>\n<li>4:17:10 珍重(diang¹ dong⁶)。</li>\n<li>4:19:12 草芥(gai⁶)。如：功名利祿如草芥。</li>\n</ol>\n<h3 id=\"下集第六場\"><a href=\"#下集第六場\" class=\"headerlink\" title=\"下集第六場\"></a>下集第六場</h3><p>故事概要：三司再審蘇三案，眾招供，皮巧英被判終生監禁，趙監生被判秋後處斬，洪洞縣縣令被革職查辦，蘇三無罪釋放。沈冤得雪，歌舞收場。</p>\n<ol>\n<li>4:21:35 親幫親，鄰幫鄰，老鼠幫戶蠅。戶蠅，蒼蠅。</li>\n<li>4:27:25 馬入中宮(dong¹ giong¹)，𠀾死必凶。</li>\n<li>4:30:06 助紂(diu⁶)爲虐(ngiag⁸)。</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>潮劇自明朝已然形成，發展到現在有近 500 年的歷史，據統計截止 2007 年 6 月已有超過 5000 個劇目。明朝嘉靖丙寅年（1566年）刊本的《荔鏡記》，是迄今所能見到的最早一個運用「泉潮腔」演唱的演出劇本。它於 2006 年被列入首批國家級非物質文化遺產保護名錄。</p>\n<p>潮劇的語音特點是：最早的潮劇基本上是以潮州府城音爲主要音系來表演的，但迴避了潮州音的最明顯的特徵音韻母——潮州府城話的 iêng/iêg、uêng/uêg、iêm/iêb 等韻母，換成了跟其他方言相同的 iang/iag、uang/uag 和 iam/iab 韻母。然後，還參雜了揭陽話的一些特點。（引自林倫倫《潮劇是用哪個地方的方言來演唱的？》）</p>\n<p>今日要講的是明朝一段跟名妓玉堂春有關的冤案。請看視頻（時長 4:35:52）：</p>\n<iframe width=\"720\" height=\"480\" src=\"https://www.youtube.com/embed/_F8IQgDZjnw\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>","more":"<h2 id=\"故事概要\"><a href=\"#故事概要\" class=\"headerlink\" title=\"故事概要\"></a>故事概要</h2><p>蘇三，花名玉堂春，原名周玉潔，明朝山西大同府周家莊人，因被販賣到燕京的「蘇淮妓院」而改姓蘇，又在妓女中排行第三，是爲蘇三。在馮夢龍版的故事裏，故事的男主角叫王景隆，其父令其到燕京收債，得銀三萬兩，遂到妓院尋歡，傾盡身資，佔有了才貌雙全的蘇三，兩人許下山盟海誓。不到一年，身資喪盡，被鴇婆趕出妓院。蘇三勸王景隆考取功名，王景隆回到金陵，奮發圖強，上京趕考，中了進士，選任真定府理刑判官。後爲父所迫，娶了劉都堂之女爲妻。</p>\n<p>另一方面，蘇三被老鴇以白銀一千兩百兩賣給山西洪洞縣馬販沈洪爲妾，因記與王景隆之山盟，不肯與沈洪同牀。沈洪正室皮氏與趙監生昴有姦情，聯合毒害了沈洪，並栽贓給蘇三，賄賂官府。蘇三遂入獄。</p>\n<p>恰逢王景隆改任山西八府巡按，得知蘇三犯了死罪，感念昔日恩情，微服私訪，探查蘇三冤情，後命縣衙起解蘇三等到太原府三堂會審。後沉冤昭雪，知縣被革職查辦，趙昴、皮氏被正法，蘇三獲釋。</p>\n<p>在各大劇中，王景隆被改爲王金龍，潮劇也不例外。潮劇中故事情節多有改動，但大體如此。本次欣賞的是林初發飾演王金龍、張儀鳳飾演蘇三的版本，唱腔依循黃欽賜，可從梅雪亭中「風啊……，風卷松聲魂欲銷，愁人慘境筆墨難描」唱段看出。</p>\n<p>網絡上蒐集的潮劇《玉堂春》相關歷史脈絡：</p>\n<ul>\n<li>明朝，馮夢龍《警世通言》第24卷《玉堂春落難逢夫》。</li>\n<li>20世紀30年代，<strong>林如烈</strong>編導《王金龍》，即《玉堂春》。</li>\n<li>1962年，潮劇元華潮劇團排演《梅亭雪》。該折子戲以林如烈的《玉堂春》中「雪淚情天」一折爲藍本。劇本整理謝吟、王老漢（王菲）、何苦（吳南生），作曲黃玉鬥、金林表、吳錫有，導演翁炳林。</li>\n<li>1981年，廣東潮劇院整理《梅亭雪》。劇本整理謝吟、王菲、鄭文風，唱腔設計<strong>黃欽賜</strong>，導演吳峰。由姚璇秋、鄭小霞飾蘇三，陳麗華、陳瑜飾王金龍，李有存、鄭蔡岳、林建東飾獄吏，謝素貞、馬嬋如飾獄婆。林如烈的雪淚情天，以「風打松聲儂心焦，愁人慘境筆墨難描」爲開始，是爲「如烈曲」；黃欽賜的梅亭雪，以「風啊……，風卷松聲魂欲銷，愁人慘境筆墨難描」爲開始。</li>\n</ul>\n<h2 id=\"潮劇筆記\"><a href=\"#潮劇筆記\" class=\"headerlink\" title=\"潮劇筆記\"></a>潮劇筆記</h2><h3 id=\"上集第一場\"><a href=\"#上集第一場\" class=\"headerlink\" title=\"上集第一場\"></a>上集第一場</h3><p>故事概要：鴇婆強迫蘇三梳攏接客，蘇三拒絕遭打。王金龍出銀百兩解救蘇三，與蘇三一見鍾情。</p>\n<ol>\n<li>5:01 衋(gêg⁴)心：傷心。</li>\n<li>5:13 煩惱(huang⁵ lo²)：擔心。</li>\n<li>5:22 變(bin³)作寶。</li>\n<li>5:44 相(siên³)輔：幫忙。</li>\n<li>5:58 祭到這老：吃到這麼老。祭，七月半祭孤，餓鬼來享用食物。所以用「祭孤」/「祭」來指人像餓鬼一般狼吞虎嚥或者沒有勞動坐享其成。</li>\n<li>7:24 鴇(bao²)婆。</li>\n<li>9:12 人客：客人。</li>\n<li>10:10 雨來囉：不是說真的雨來了，通常在認爲別人的話語或行爲不合邏輯或不合時宜時會這樣出言制止。</li>\n<li>10:31 梳攏(siu¹ lang⁵)：指妓女首次接客。妓院中處女只梳辮，接客後梳髻，稱「梳攏」。</li>\n<li>10:55 十五貫錢，買作菜脯，儉儉好食一年。</li>\n<li>10:59 鄙相(pi² siên³)：看人低賤，抑是用話來罵人低賤的意思。同義的有「睇相」。</li>\n<li>11:27 個面七個空，怎知汝是乜人。</li>\n<li>11:37 縣衙(guin⁷ ghê⁵)。</li>\n<li>11:41 頭欹欹(ki¹)：歪頭狀。</li>\n<li>11:57 常來常往，若敢胡來，就著知慘。</li>\n<li>12:47 稍(ciao²)候。</li>\n<li>13:10 至切：一定。如：至切勿上錯牀。</li>\n<li>15:04 吃(ngeg⁴)。</li>\n<li>15:48 參詳：商量。如：這事好參詳。</li>\n<li>15:49 偪側(bêg⁴ cêg⁴)：逼迫。</li>\n<li>16:14 娉婷(pêng³ têng⁵)。</li>\n<li>16:53 後生人：年輕人。</li>\n<li>16:54 通朗(tang¹ lang⁵)：洞明事理。如：呾話唔通朗。</li>\n<li>17:03 愈更：更加。如：愈更胡說。</li>\n<li>17:20 強扭之瓜不甜，強掰之花不香。</li>\n<li>17:37 翹楚：翹，高出仰起。楚，荊木，可做杖。翹楚是高出一般灌木的荊木。喻指厲害、超群。如：你若翹楚，同樣𢭪(kiêh⁸ 拿)出三十兩銀。</li>\n</ol>\n<h3 id=\"上集第二場\"><a href=\"#上集第二場\" class=\"headerlink\" title=\"上集第二場\"></a>上集第二場</h3><p>故事概要：王金龍三萬兩銀錢爲蘇三建了留春院北樓，飲酒作樂過了一年。其父發覺後到留春院將其掠回處置。</p>\n<ol>\n<li>21:14王(hêng⁵)瓊。</li>\n<li>23:09 才華洋溢(iang⁵ êg⁸)。</li>\n<li>25:12 鴛鴦(uang¹ iang¹)。</li>\n<li>27:56 絢(sung¹)麗。</li>\n<li>28:09 秦樓楚館煙(ing¹)花地。</li>\n<li>30:30 銅錢落草草會青，豈容坐食破大家。</li>\n<li>30:42 仔細：客氣。如：免仔細。</li>\n<li>30:43 熟人免行生(cên¹)禮(loi²)。</li>\n<li>32:02 一朝無食夫妻無義。</li>\n<li>33:33 沈溺(dim⁵ nêg⁸)。</li>\n<li>33:33 紈絝(iang⁵ kou³)子弟。</li>\n<li>33:51 戰戰兢兢(kêng¹)。</li>\n<li>35:08 食罪陷百罹(li⁵)。</li>\n<li>38:15 鵬程(pong⁵ têng⁵)。</li>\n<li>38:30 擔承：承擔。</li>\n<li>39:25 畜(têg⁴)生。</li>\n<li>40:00 戲歇棚拆：比喻世態炎涼，人情淡薄，類似的有「人走茶涼」。</li>\n<li>40:13 如其不然。</li>\n</ol>\n<h3 id=\"上集第三場-關王廟♥️\"><a href=\"#上集第三場-關王廟♥️\" class=\"headerlink\" title=\"上集第三場 關王廟♥️\"></a>上集第三場 關王廟♥️</h3><p><img src=\"/2020/10/15/language/min/teochew-opera-ghêgdengcung/2020-10-14-12.41.34.png\" alt><br>故事概要：蘇三以爲王金龍已被其父打死，遂前往關王廟祭奠王金龍。而殊不知王金龍僥倖逃脫，淪落爲乞丐，剛好也在關王廟。蘇三勸王金龍應效仿呂蒙正去考取功名。</p>\n<ol>\n<li>41:40 奇事年年有，無年奇相同。</li>\n<li>42:00 花子(hua¹ ze²)：叫花子。</li>\n<li>42:13 庵寺：尼寺、僧寺的通稱。</li>\n<li>42:24 照書行事。</li>\n<li>44:42 膠漆(ga¹ cag⁴)。如：情如膠漆割捨不能。</li>\n<li>45:16 殷勤(heng¹ keng⁵)。</li>\n<li>46:57 人事不省(sêng³)。</li>\n<li>48:12 五行：面相，處境。</li>\n<li>48:37 忍淚吞聲(sêng¹)。</li>\n<li>49:35 訴(su³)苦。</li>\n<li>49:35 顏(nguang⁵)色。</li>\n<li>50:13 烏雲密佈(bu³)。</li>\n<li>50:24 時運不濟。</li>\n<li>52:21 鶉(sung⁵)衣百結(gag⁴)：鵪鶉小頭禿尾， 羽毛赤褐色，雜有暗黃色斑點和條文，像一件沒有下擺，布滿補丁的衣服。形容衣服破爛不堪。</li>\n<li>53:52 坫(diam³)：躲藏。如：走去坫牀下。</li>\n<li>55:09 祭奠(diang⁶)。</li>\n<li>56:14 齊備(ci⁵ bi⁶)：齊全完備。</li>\n<li>56:21 包山包海：包攬全活。如：爲儉錢銀，一人包山包海。</li>\n<li>1:00:27 愁雲冉冉難見晴空。</li>\n<li>1:00:49 飛禍疊(tah⁸)至慘無窮。</li>\n<li>1:01:13 噩耗(ngag⁸ ho³)。</li>\n<li>1:04:35 衣衫襤褸(nam⁵ nu²)。</li>\n<li>1:05:08 邂逅(hai⁶ hou⁶)。</li>\n<li>1:05:44 一霎(siab⁴)時。</li>\n<li>1:07:09 果(guan²)然。</li>\n<li>1:07:17 妾願隨君陰曹去，從此聚首不分離。</li>\n<li>1:09:23 嗟嘆(za¹ tam³)。</li>\n<li>1:09:55 寂寞(sog⁴ mog⁸)。</li>\n<li>1:10:49 啜(coih⁴)泣。</li>\n<li>1:11:43 甌：大碗。</li>\n<li>1:11:44 箸：筷子。</li>\n<li>1:13:22 朱買臣：字翁子，西漢會稽吳人。家貧好學，以賣薪自給，妻羞之，改適他人，後買臣顯貴，婦慚，自縊而死；買臣官至丞相長史，因與張湯相傾軋，遭誅殺。</li>\n<li>1:13:33 呂蒙正(mong⁵ zêng³)：宋朝人，自幼父母雙亡，因此淪落爲乞丐，但其非常好學，把分來的錢都會拿去買書。因其在尚未發達當官之前，白天乞討，並投靠於佛院，晚上住於破窯。</li>\n<li>1:16:52 鄭元和：元石君寶李亞仙花酒曲江池雜劇中的人物。鄭元和爲洛陽府尹鄭公弼的兒子，因與妓女李亞仙相戀，以致散盡錢財，荒廢學業，淪爲乞丐。歷盡一番滄桑後，終在李亞仙的鼓勵下，專心向學，得以應試高中，返家團圓。</li>\n</ol>\n<h3 id=\"上集第四場\"><a href=\"#上集第四場\" class=\"headerlink\" title=\"上集第四場\"></a>上集第四場</h3><p>故事概要：蘇三被留春院賣給馬販沈洪爲妾。王金龍回鄉備考，途中盤纏被劫。</p>\n<ol>\n<li>1:19:22 未是孥囝砌宮闈，騙汝好怎呢？</li>\n<li>1:19:48 排比：不是指修辭手法，而是安排的意思。《全唐詩．卷七九八．花蕊夫人．宮詞》：「今宵駕幸池頭宿，排比椒房得暖無。」</li>\n<li>1:22:48 主僕(bog⁸)。</li>\n<li>1:22:58 擺踩：調侃、嘲弄、嘲諷、批評。「踩」字存疑。如：奴才，敢掠阿爺來擺踩。</li>\n<li>1:23:15 會哩開嘴，𠀾就放屁，一旁咬蝨(sag⁴)。</li>\n<li>1:26:29 惆悵(tiu⁵ ziang³)。</li>\n<li>1:26:46 贖(sog⁸)身。</li>\n<li>1:26:48 解倒懸(dao² hiang⁵)：倒懸，縛人兩足倒掛。比喻極爲困苦。解倒懸比喻解救人於困苦之境。</li>\n<li>1:30:53 主施：不是施主的意思，而是處理的意思。如：進退兩難怎主施？</li>\n</ol>\n<h3 id=\"上集第五場\"><a href=\"#上集第五場\" class=\"headerlink\" title=\"上集第五場\"></a>上集第五場</h3><p>故事概要：沈洪妻子皮氏下毒麵欲殺蘇三，不料蘇三拒食，湯麵爲沈洪所食，暴斃。</p>\n<ol>\n<li>1:34:11 眼中釘(ding¹/dêng¹)。</li>\n<li>1:40:47 聰穎(kêng²)。</li>\n<li>1:41:22 物輕意重。</li>\n<li>1:42:26 狗母蛇假龍。</li>\n<li>1:42:45 好心分你作歹意。</li>\n<li>1:42:56 皮燈籠，肚內明。</li>\n<li>1:43:45 二山相疊出出出。</li>\n<li>1:48:16 拖三延四。</li>\n<li>1:51:36 糙米錔(tag⁴)空臼(ku⁶)。</li>\n</ol>\n<h3 id=\"上集第六場-縣衙公堂\"><a href=\"#上集第六場-縣衙公堂\" class=\"headerlink\" title=\"上集第六場 縣衙公堂\"></a>上集第六場 縣衙公堂</h3><p>故事概要：皮氏連同情夫趙監生賄賂縣太爺，蘇三遭屈打成招、打入死牢。</p>\n<ol>\n<li>2:01:17 踉蹌(lang⁵ cang¹)。如：步履踉蹌肝腸斷。</li>\n<li>2:01:17 淚涔涔(ngim⁵)。如：百感交集淚涔涔。</li>\n<li>2:02:53 嫩(lung³)。如：鮮花嫩蕊悅死鬼。</li>\n<li>2:04:25 蛇蠍(hiah⁴)心腸(ciang⁵)。</li>\n<li>2:05:40 好貨墊底。</li>\n<li>2:09:42 砒(bi¹)霜。</li>\n<li>2:11:02 舵(dua⁶)。如：轉舵往回走。</li>\n<li>2:14:41 因依：原委、緣由。如：時晴時雨何因依。</li>\n<li>2:15:21 呼嘯(hu¹ sao³)。如：狂風呼嘯心膽寒。</li>\n<li>2:17:32 死牢(lo⁵)。</li>\n</ol>\n<h3 id=\"下集第一場\"><a href=\"#下集第一場\" class=\"headerlink\" title=\"下集第一場\"></a>下集第一場</h3><p>故事概要：王金龍中了進士，封官到太原府任巡按。路過洪洞縣，調查蘇三的冤情並命縣令將蘇三起解太原。</p>\n<ol>\n<li>名譽(u⁶)。</li>\n<li>花腳：比喻閒游浪蕩﹑愛串門子的人。如：一個花腳，一個風流。</li>\n<li>蹺蹊(kiao¹ ki¹)：蹊蹺。</li>\n</ol>\n<h3 id=\"下集第二場-荒野-♥️\"><a href=\"#下集第二場-荒野-♥️\" class=\"headerlink\" title=\"下集第二場 荒野 ♥️\"></a>下集第二場 荒野 ♥️</h3><p><img src=\"/2020/10/15/language/min/teochew-opera-ghêgdengcung/2020-10-15-1.10.20.png\" alt><br>故事概要：蘇三起解太原。解差程公道知道蘇三的冤情後，中途休息時爲其解開枷鎖，並令其將訴狀放到枷鎖中以避免被搜身。蘇三感恩，認程公道爲乾爹。</p>\n<ol>\n<li>2:35:13 蘇三(sam¹)離了洪洞(tong⁵)境，一步一淚暗傷(siang¹)情。</li>\n<li>2:36:54 跋涉(buag⁸ siab⁴)。</li>\n<li>2:37:35 拚駁：盡力辯駁。</li>\n<li>2:41:20 勿許生哩免這生，欲許生哩著這生。</li>\n<li>2:42:18 含冤負屈。</li>\n<li>2:48:07 顧身都唔離(li⁷)：照顧自己都不能全，無法放開手腳去理會他人。離：放開。</li>\n<li>2:49:18 一死如死，現死駁賒死。</li>\n<li>2:50:53 合(hah⁸)卺(geng²)酒：卺，古代結婚時用作酒器的一種瓢。舊時夫妻結婚的一種儀式，把一個匏瓜剖成兩個瓢，新郎新娘各拿一個飲酒。</li>\n<li>2:51:33 契走囝：乾女兒。走，是諸母(za¹ bhou²，泛指婦女)的合音借詞。</li>\n</ol>\n<h3 id=\"下集第三場-太原府公堂-♥️\"><a href=\"#下集第三場-太原府公堂-♥️\" class=\"headerlink\" title=\"下集第三場 太原府公堂 ♥️\"></a>下集第三場 太原府公堂 ♥️</h3><p><img src=\"/2020/10/15/language/min/teochew-opera-ghêgdengcung/2020-10-15-1.11.30.png\" alt><br>故事概要：王巡按金龍，連同按察使何布政使，三司會審蘇三。按察使、布政使戲弄王金龍。</p>\n<ol>\n<li>2:55:28布(bu³)政使(sai³)，官名。</li>\n<li>2:59:24寸步難行(hêng⁵)。</li>\n<li>3:03:13 昏厥(kiag⁴)。</li>\n<li>3:12:26 修葺(cib⁴)。</li>\n<li>3:16:50 梟(hiao¹)情絕義：無情無義。</li>\n<li>3:20:18 吹毛求疵(cuê¹ mo⁵ kiu⁵ ce⁵)。</li>\n</ol>\n<h3 id=\"下集第四場\"><a href=\"#下集第四場\" class=\"headerlink\" title=\"下集第四場\"></a>下集第四場</h3><p>故事概要：皮氏到太原按察使劉秉義府，以金環、金釵賄賂其妻。按察使大公無私，設下凍雪計。</p>\n<ol>\n<li>3:28:46 金釵(toi¹)。</li>\n<li>3:29:16 擺宴(ang³)。</li>\n<li>3:31:55 家無常禮(li²)。</li>\n</ol>\n<h3 id=\"下集第五場♥️-城外五里亭（梅亭）\"><a href=\"#下集第五場♥️-城外五里亭（梅亭）\" class=\"headerlink\" title=\"下集第五場♥️ 城外五里亭（梅亭）\"></a>下集第五場♥️ 城外五里亭（梅亭）</h3><p><img src=\"/2020/10/15/language/min/teochew-opera-ghêgdengcung/2020-10-15-1.12.28.png\" alt><br>故事概要：蘇三被按察使置於梅亭，是夜，大雪紛飛，天寒地凍。王金龙冒雪前往看望。兩人互訴衷情。按察使暗中觀看，察明案情。</p>\n<ol>\n<li>3:37:56 怨疊疊(tah⁸)，恨重重。</li>\n<li>3:41:05 履(li²)薄衣單(dang¹)。</li>\n<li>3:42:05 證(zêng³)龜成(zian⁵)鱉：將烏龜說成甲魚，比喻蓄意歪曲，顛倒是非。同義詞有「指鹿爲馬」。</li>\n<li>3:44:04 坐摩(mua⁵)些。摩，近。</li>\n<li>3:46:11 風呀……風卷松聲魂欲銷，愁人慘境筆墨難描。</li>\n<li>3:55:39 啱(ngam¹)：恰好。</li>\n<li>3.58:33得魚忘筌(cuang⁵)：指捕得到了魚，便忘掉了用來捕魚的筌。比喻悟道者忘其形骸。也比喻人在達到目的以後，就忘記他賴以成功的憑藉。</li>\n<li>4:01:06 假惺惺(sêng¹)。</li>\n<li>4:01:07 寒夜無燈心自明。</li>\n<li>4:08:46 失寵(tong²)。</li>\n<li>4:17:10 珍重(diang¹ dong⁶)。</li>\n<li>4:19:12 草芥(gai⁶)。如：功名利祿如草芥。</li>\n</ol>\n<h3 id=\"下集第六場\"><a href=\"#下集第六場\" class=\"headerlink\" title=\"下集第六場\"></a>下集第六場</h3><p>故事概要：三司再審蘇三案，眾招供，皮巧英被判終生監禁，趙監生被判秋後處斬，洪洞縣縣令被革職查辦，蘇三無罪釋放。沈冤得雪，歌舞收場。</p>\n<ol>\n<li>4:21:35 親幫親，鄰幫鄰，老鼠幫戶蠅。戶蠅，蒼蠅。</li>\n<li>4:27:25 馬入中宮(dong¹ giong¹)，𠀾死必凶。</li>\n<li>4:30:06 助紂(diu⁶)爲虐(ngiag⁸)。</li>\n</ol>"},{"title":"Java 集合","p":"it/java/java-collection.md","_content":"\nJava 集合分 List、Set、Map 三大類，其中 List 和 Set 實現了 Collection 接口。List 的特點是數據有序、可重複；Set 的特點是數據無序、不可重複；Map 存儲鍵值映射，Key 不可重複，Value 可重複，且一個 Key 只能對應一個 Value。\n\nList 有一實現 `ArrayList`，其底層實現是對象數組，默認容量是 10，但等到首次添加元素時才分配內存，每次遞增爲上次容量的 1.5 倍。在添加大量元素之前，建議調用 `ensureCapacity` 方法擴容，以減少遞增式再分配內存的次數。\n\nSet 有一實現 `HashSet`，其底層實現是 `HashMap` ，其檢查重複的機制有賴於 `hashCode` 和 `equals` 方法。\n\nMap 有一實現 `HashMap` ，JDK 1.8 之後其底層實現是：**數組 + 鏈表 + 紅黑二叉樹**。紅黑樹是爲了減少搜索時間，默認當鏈表長度大於 8 且當前數組長度大於等於 64 時，鏈表會轉爲紅黑樹。數組默認容量是 16，通過帶參構造方法傳入的容量值如非 2 的幂次會自動向上轉爲 2 的幂次，以便元素散列存儲（元素位置才可通過 `hash & (length-1)` 確定）。添加元素時，若元素數量大於數組長度的 75% 且該元素存在哈希衝突，則觸發擴容機制，數組容量翻倍。\n\n總結下 HashMap 中解決哈希衝突的方式：\n\n1. 使用鏈表 — 拉鍊法；\n2. 使用紅黑二叉樹；\n3. 擴容底層數組；\n4. 強制數組容量爲 2 之幂次；\n5. 將元素的 hash 值的高位分散到低位等等。\n\n`ArrayList`、`HashSet`、`HashMap` 都是線程不安全的。在多線程環境下應使用 J.U.C 包下的對應的並發類 `CopyOnWriteArrayList` 、`ConcurrentHashMap` （`HashSet` 用`ConcurrentHashMap` 的 keySet 可得 Set 視圖）。`CopyOnWriteArrayList` 會在寫時加鎖並複製集合進行操作；`ConcurrentHashMap` 在 JDK 1.7 使用分段鎖，在 JDK 1.8 取消分段鎖採用 CAS（樂觀鎖） 和 synchronized（悲觀鎖） 只對鏈表或紅黑二叉樹的節點加鎖。\n\n<!-- more -->\n\n## 概覽\n\n集合是相對數組來說，更靈活多樣的容器。Java 的集合框架肇始於兩大接口，Collection 和 Map。Collection 下有 List、Queue 和 Set 等等接口，然後衍生出 ArrayList、LinkedList、HashSet、TreeSet、LinkedHashSet 等等實現；Map 下有 HashMap、TreeMap 等重要子類。\n\n![](java-collection/Untitled.png)\n\n### List、Set、Map 三者之區別\n\n1. List：存儲的元素有序、可重複。\n2. Set：存儲的元素無序、不可重複。\n3. Map：使用鍵值對存儲，一鍵一值，Key 無序、不可重複；Value 無序、可重複。\n\n### List、Set、Map 三者之底層數據結構\n\n1. List\n    - ArrayList：Object 數組\n    - Vector：Object 數組\n    - LinkedList：雙向鏈表（JDK 1.6 之前爲循環鏈表）\n2. Set\n    - HashSet（無序、唯一）：基於 HashMap\n    - LinkedHashSet：基於 LinkedHashMap\n    - TreeSet（有序、唯一）：紅黑樹（自平衡的排序二叉樹）\n3. Map\n    - HashMap：數組 + 鏈表 + 紅黑樹（鏈表長於閾值即轉爲紅黑樹以減少搜索時間；閾值默認爲 8；JDK 1.8 之前沒有紅黑樹）\n    - LinkedHashMap：繼承自 HashMap，但多了一條雙向鏈表\n    - Hashtable：數組 + 鏈表\n    - TreeMap：紅黑樹（自平衡的排序二叉樹）\n\n### Iterator 迭代器\n\n迭代器就是 Iterator 接口，它抽象出迭代一個集合需要的方法，`hasNext()` 和 `next()` 方法，以便集合類實現該接口，從而方便對集合的遍歷。有了迭代器就可以在迭代集合元素時更改元素而不拋出 `ConcurrentModificationException` 了。\n\n爲什麼？因爲非採用 Iterator 進行遍歷時更改元素會修改到 `modCount` 變量（用於紀錄集合結構性改變的次數）的值，而沒有修改 `expectedModCount` 的值，基於 fail-fast 機制檢查兩值是否相同時會拋出異常；而使用 Iterator 遍歷時更改元素會同時修改 `modCount` 和 `expectedModCount`，兩者相等，不會拋出異常。\n\n```java\nMap<Integer, String> map = new HashMap();\nmap.put(1, \"Java\");\nmap.put(2, \"Python\");\nmap.put(2, \"Go\");\nIterator<Map.Entry<Integer, String>> iterator = map.entrySet().iterator();\nwhile (iterator.hasNext()) {\n  Map.Entry<Integer, String> entry = iterator.next();\n  System.out.println(entry.getKey() + entry.getValue());\n}\n```\n\n### 有哪些集合是線程不安全的？怎麼解決？\n\n常用的 `ArrayList`、`LinkedList`、`HashMap`、`HashSet`、`TreeSet`、`TreeMap`、`PriorityQueue` 都不是線程安全的。解決方法就是用 `java.util.concurrent` 包提供的線程安全的集合來代替：\n\n1. `ConcurrentHashMap` 代替 `HashMap`；\n2. `CopyOnWriteArrayList` 代替 `ArrayList`；\n3. `ConcurrentLinkedQueue` 代替 `LinkedList` ；\n4. `BlockingQueue` 接口下的 `PriorityBlockingQueue`、`LinkedBlockingQueue` 等阻塞隊列代替 `PriorityQueue`  等；\n5. `ConcurrentSkipListMap`  代替 `TreeMap` ，實現多線程下保證按 Key 的順序存儲元素。\n\n### `length`、`length()`、`size()` 三者用途\n\n1. `length`：用於數組。\n2. `length()`：用於字符串。\n3. `size()`：用於集合。\n\n### Collections 工具類的使用\n\n- 排序\n\n    ```java\n    //反轉\n    void reverse(List list)\n    //隨機排序\n    void shuffle(List list)\n    //按自然排序的升序排序\n    void sort(List list)\n    //定制排序，由Comparator控制排序邏輯\n    void sort(List list, Comparator c)\n    //交換兩個索引位置的元素\n    void swap(List list, int i , int j)\n    //旋轉。當distance為正數時，將list後distance個元素整體移到前面。當distance為負數時，將 list的前distance個元素整體移到後面\n    void rotate(List list, int distance)\n    ```\n\n- 查找替換統計\n\n    ```java\n    //對List進行二分查找，返回索引，注意List必須是有序的\n    int binarySearch(List list, Object key)\n    //根據元素的自然順序，返回最大的元素。 類比int min(Collection coll)\n    int max(Collection coll)\n    //根據定制排序，返回最大元素，排序規則由Comparatator類控制。類比int min(Collection coll, Comparator c)\n    int max(Collection coll, Comparator c)\n    //用指定的元素代替指定list中的所有元素\n    void fill(List list, Object obj)\n    //用新元素替換舊元素\n    boolean replaceAll(List list, Object oldVal, Object newVal) \n    //統計元素出現次數\n    int frequency(Collection c, Object o)\n    //統計target在list中第一次出現的索引，找不到則返回-1，類比int lastIndexOfSubList(List source, list target)\n    int indexOfSubList(List list, List target)\n    ```\n\n## List\n\n### 比較 ArrayList 與 LinkedList\n\n共同點：\n\n1. 都實現了 List 接口；\n2. 都是不同步的，不保證線程安全。\n\n不同點：\n\n1. **底層數據結構不同**。ArrayList 是對象數組；LinkedList 是雙向鏈表（JDK 1.6 之前爲循環列表）。\n2. **插入和刪除的時間複雜度不同**。ArrayList 追加元素的複雜度爲 O(1)，指定位置 i 插入或刪除元素的複雜度爲 O(n-i)；LinkedList 追加元素和刪除末端元素的時間複雜度爲 O(1)，指定位置 i 插入或刪除元素的時間複雜度近似 O(n)。\n3. **對快速隨機訪問的支持不同**。ArrayList 支持快速隨機訪問；LinkedList 不支持。\n4. **對空間的利用不同**。ArrayList 末尾會預留一定的空間以便元素新增；LinkedList 則是會在每個元素多存儲了指針數據。\n- 比較雙向鏈表與雙向循環鏈表\n\n    ![](java-collection/Untitled%201.png)\n\n    ![](java-collection/Untitled%202.png)\n\n### ArrayList 擴容機制\n\nArrayList 底層是對象數組，其容量可以動態增長。在添加大量元素之前，建議調用 `ensureCapacity` 方法擴容，以減少遞增式再分配內存的次數，提升程序效率。\n\n其擴容機制大致是這樣的：ArrayList 提供了默認構造方法，通過默認構造方法構造對象，默認容量值爲 10 ，但此時未分配相應內存空間，而是**等到首次添加元素時才開始初始化**一個空間爲 10 的對象數組。當第 11 個元素加入時會觸發擴容機制，**容量會擴充到原來的 1.5 倍**（`newCapacity = oldCapacity + oldCapacity >> 2`），即變爲 15。如通過指定相應的容量大小的構造方法構造對象且指定的容量值大於 0 ，則一開始就會分配相應的內存空間。\n\n### 快速隨機訪問 RandomAccess\n\nRandomAccess 接口爲空實現，僅僅標識著實現類具備快速隨機訪問的能力。ArrayList 實現了該接口，而 LinkedList 未實現。\n\n```java\npublic interface RandomAccess {\n}\n```\n\n### `System.arraycopy()` 與 `Arrays.copyOf()` 方法\n\n1. `System.arraycopy()` 方法用於源數組到目標數組之間的數據拷貝；\n2. `Arrays.copyOf()` 方法用於給源數組擴容，底層調用`System.arraycopy()` 。\n\n### CopyOnWriteArrayList 的特點\n\n1. 寫時會加鎖並複製整個集合；\n2. 讀時可能讀到舊數據。\n\n### **如何移除列表中的元素**\n\n首先，不能在 foreach 循環中移除元素，根據 fail-fast（快速失敗） 機制，會拋出 `ConcurrentModificationException` （並發修改異常）。\n\n可以採用 `iterator` 或者 `Collection.removeIf()` 方法移除列表元素。\n\n```java\nString[] arrs = {\"a\", \"b\", \"c\"};\nList<String> list = Arrays.stream(arrs).collect(Collectors.toList());\n\n// 採用 iterator\nIterator<String> iterator = list.iterator();\nwhile (iterator.hasNext()) {\n    if (\"a\".equals(iterator.next())) {\n        iterator.remove();\n        break;\n    }\n}\n\n// 採用 removeIf 方法，\"a\"::equals 等價於 x -> \"a\".equals(x)\nlist.removeIf(\"a\"::equals); \n\nSystem.out.println(list);\n```\n\n### **正確使用 Arrays.asList**\n\n如果非要在 `foreach` 循環中刪除元素，還可以使用 `CopyOnWriteArrayList`，此集合是 `fail-safe` 的。`CopyOnWriteArrayList` 修改元素時會 copy 一個新列表進行修改，不會改變迭代中的列表，因此是安全的，但會產生新的列表作爲代價。\n\nArrays 工具類有一個靜態方法 `asList(T... a)`，能將**對象**數組包裝成一個 List，底層數據依然是原數組，原數組改變，List 也隨之改變，但 List 本身的 `add`/`remove`/`clear` 並不可用，調用會拋出 `UnsupportedOperationException`。\n\nArrays 類中關於 `asList` 方法的代碼如下：\n\n```java\npublic static <T> List<T> asList(T... a) {\n\t\t// 這裏的 ArrayList 是 Arrays 類中定義的私有靜態類，不是 java.util.ArrayList\n    return new ArrayList<>(a);\n}\n```\n\n爲什麼 `asList` 方法傳入的必須是對象數組呢？\n\n你看上面的代碼，泛型，沒錯泛型只能是對象啊，基本類型是不行的。\n\n傳入基本類型的數組會怎樣呢？請看下面代碼：\n\n```java\nint[] ints = {1, 3, 4};\n// 此時的泛型是 int[] 對象，而非 int\nList<int[]> list = Arrays.asList(ints);\n// list 的大小爲 1，就是 ints 這個數組對象\nSystem.out.println(list.size());\n```\n\n### **把數組轉爲 `java.util.ArrayList`**\n\n那麼，如何簡便地把一個數組轉爲普遍意義上的 ArrayList 呢？\n\n```java\n// 1) 使用 ArrayList 的帶參構造方法\nList<String> list = new ArrayList<>(Arrays.asList(arrs));\n\n// 2) 使用 Java 8 的 Stream API\nList<String> list = Arrays.stream(arrs).collect(Collectors.toList());\n// boxed 方法可以把基本類型轉成包裝類型\nList<Integer> intList = Arrays.stream(ints).boxed().collect(Collectors.toList());\n\n// 3) 使用 Guava 包的 API\nImmutableList<String[]> list = ImmutableList.of(arrs);\nImmutableList<String> list1 = ImmutableList.copyOf(arrs);\nArrayList<String> list2 = Lists.newArrayList(arrs);\n\n// 4) 使用 Java 9 的 API\nList<String> list = List.of(arrs);\n```\n\n### **將 List 轉爲數組**\n\n使用 List 的 `toArray` 方法可以將 List 轉爲數組，代碼如下：\n\n```java\n// new String[0] 僅僅爲了告知類型返回數組的類型\nString[] strings = list.toArray(new String[0]);\n```\n\n## Set\n\n### 無序性和不可重複性的含義\n\n無序性並不等同於隨機性，而是根據數據的哈希值決定其存儲位置，使用者無法指定其存儲順序。\n\n不可重複性是指添加的元素按 equals 方法判斷結果爲 false。\n\n### 比較 HashSet、LinkedHashSet 和 TreeSet\n\n共同點：\n\n1. 都實現了 Set 接口；\n2. 元素不可重複；\n3. 都是線程不安全的。\n\n不同點：\n\n1. **底層數據接口不同**。HashSet 底層是 HashMap；LinkedHashSet 底層是 LinkedHashMap；TreeSet 底層是紅黑樹。\n2. **有序性不同**。HashSet 無序；LinkedHashSet 和 TreeSet 有序。TreeSet 還可以自定義排序。\n\n### 自定義排序的實現\n\n自定義排序最通用的就是給要排序的類實現一個 Comparable 接口，隨後可以使用 Collection.sort 方法進行排序。又或者不實現 Comparable 接口，而是傳入 Comparator 到 Collection.sort 方法中。\n\n### HashSet 如何檢查重複\n\nHashSet 集合進行元素重複校驗時先比較 hashcode ，當 hashcode 一樣時再調用 equals，提高了校驗效率。因此，如果只重寫 equals 方法而不重寫 hashcode 方法，會出現 equals 返回 true，而 hashcode 不等的情況，這樣如果要求 HashSet 去重就會失敗。\n\n## Map\n\n### 比較 HashMap 與 TreeMap\n\n共同點：\n\n1. 都繼承自 AbstractMap，間接實現了 Map 接口；\n2. 都是線程不安全的。\n\n不同點：\n\n1. **底層數據結構不同**。HashMap 底層是數組 + 鏈表 + 紅黑樹（鏈表長於閾值即轉爲紅黑樹以減少搜索時間；閾值默認爲 8；JDK 1.8 之前沒有紅黑樹）；TreeMap 底層是紅黑樹。\n2. **HashMap 無搜索和排序的能力**。TreeMap 實現了 NavigableMap 接口，使其有對集合內元素搜索的能力；實現了 SortMap 接口，使其有對集合內元素根據鍵排序的能力。\n\n### HashMap 底層實現\n\nJDK 1.7 或之前，HashMap 的底層實現是數組+鏈表。該數組的定義如下：\n\n```java\ntransient Node<K,V>[] table;\n```\n\nNode 存儲了鍵、值、哈希值和下一個節點，是一個鏈表，也就是說 Node 數組就是一個鏈表數組。\n\n![](java-collection/Untitled%203.png)\n\n該數組默認大小是 `1 << 4 = 16` 。調用 put 方法增加元素時，通過散列算法（hash方法，也稱之爲擾動函數）算得元素的 hash 值，然後計算其應插入的桶（數組中的一個位置）。如果該位置已有元素，就會產生哈希衝突（或稱碰撞），此時通過**拉鍊法**解決。當 Map 中包含的元素數量大於等於 `threshold = loadFactor * capacity` （loadFactor 默認爲 0.75f），且新建的元素剛好落在一個非空的桶上時，會觸發擴容機制，將數組容量擴大 2 倍。\n\nJDK 1.8 開始，HashMap 的底層實現是數組+鏈表+紅黑樹，**當鏈表長度大於閾值（默認爲 8），且當前數組長度大於等於 64 時，該鏈表會轉爲紅黑樹，以減少搜索時間。**\n\n![](java-collection/Untitled%204.png)\n\n**（1）散列算法**\n\n首先獲取 key 的 hash 值，然後將高位的 hash 分散到低位，以便減少哈希衝突。\n\n```java\n// JDK 1.7\nstatic int hash(int h) {\n  // This function ensures that hashCodes that differ only by\n  // constant multiples at each bit position have a bounded\n  // number of collisions (approximately 8 at default load factor).\n  h ^= (h >>> 20) ^ (h >>> 12);\n  return h ^ (h >>> 7) ^ (h >>> 4);\n}\n// JDK 1.8\nstatic final int hash(Object key) {\n  int h;\n  return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\n```\n\n**（2）插入算法**\n\n如何根據散列值確定要插入的數組位置呢？因爲保證了數組長度爲 2 之幂次，所以確定插入位置時的取餘算法 `hash % length` 等價於 `h & (length-1)`。簡單起見，假定 hash 爲 0100 1010； length 是 8，其二進制爲 0000 1000，取餘爲 `hash % length` = 0000 0010 = `h & (length-1)`。此處 hash 值的高位 0100 並沒有用到，會造成高位不同而低位相同的 hash 值衝突，這也是散列算法要將高位分散到低位的緣故。\n\n```java\n/**\n* Returns index for hash code h.\n*/\nstatic int indexFor(int h, int length) {\n  return h & (length-1);\n}\n```\n\n**（3）拉鍊法**\n\n將衝突的值加到鏈表中。\n\n**（4）保證數組長度爲 2 之幂次的方法**\n\n- 方法一（JDK 1.8 或以前）：將原數二進制表示的第一個非零位後面的所有零位填滿爲 1，然後再加 1。\n\n    ```java\n    static final int tableSizeFor(int cap) {\n        int n = cap - 1;\n        n |= n >>> 1;\n        n |= n >>> 2;\n        n |= n >>> 4;\n        n |= n >>> 8;\n        n |= n >>> 16;\n        return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\n    }\n    ```\n\n- 方法二（JDK 15）：計算原數二進制表示的第一個非零位前面零的數量 k，然後將 -1 (其二進制形式全是1)無符號右移 k 位再加 1。\n\n    ```java\n    // HashMap.java\n    static final int tableSizeFor(int cap) {\n      int n = -1 >>> Integer.numberOfLeadingZeros(cap - 1);\n      return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\n    }\n\n    // Integer.java\n    // 取得整數二進制表示前面的零位數量\n    public static int numberOfLeadingZeros(int i) {\n      // HD, Count leading 0's\n      if (i <= 0)\n          return i == 0 ? 32 : 0;\n      int n = 31;\n      if (i >= 1 << 16) { n -= 16; i >>>= 16; }\n      if (i >= 1 <<  8) { n -=  8; i >>>=  8; }\n      if (i >= 1 <<  4) { n -=  4; i >>>=  4; }\n      if (i >= 1 <<  2) { n -=  2; i >>>=  2; }\n      return n - (i >>> 1);\n    }\n    ```\n\n- 方法三（不推薦）：將原數以 2 爲底取對數，然後再取其 ceil 值，將其作爲 2 的指數計算即可。\n\n    ```java\n    int n = (int) Math.pow(2, (int) Math.ceil(Math.log(cap) / Math.log(2)));\n    ```\n\n### 遍歷 HashMap 的幾種方式\n\nHashMap 有四大類遍歷方式：iterator、for、lambda 和 stream。性能上 stream 的並行循環最高，其他的差別不大。安全性上在遍歷時應使用 `iterator.remove`方法刪除元素或者用 stream 的 `filter` 過濾不需要的數據再進行循環。參見 [https://mp.weixin.qq.com/s/Zz6mofCtmYpABDL1ap04ow](https://mp.weixin.qq.com/s/Zz6mofCtmYpABDL1ap04ow)\n\n```java\nMap<String, String> map = new HashMap<>();\nmap.put(\"lang\", \"java\");\nmap.put(\"sys\", \"linux\");\n// iterator\nIterator<Map.Entry<String, String>> iterator = map.entrySet().iterator();\nwhile (iterator.hasNext()) {\n  Map.Entry<String, String> entry = iterator.next();\n  System.out.println(entry.getKey() + \":\" + entry.getValue());\n}\n// for，增強 for 循環，使用了迭代器\nfor (Map.Entry<String, String> entry : map.entrySet()) {\n  System.out.println(entry.getKey() + \":\" + entry.getValue());\n}\n// lambda\nmap.forEach((key, value) -> {\n  System.out.println(key + \":\" + value);\n});\n// stream\nmap.entrySet().parallelStream().forEach((entry) -> {\n  System.out.println(entry.getKey() + \":\" + entry.getValue());\n});\n```\n\n### ConcurrentHashMap 線程安全的原因\n\n我們知道 HashMap 是線程不安全的，在多線程環境下需要用 ConcurrentHashMap 代替。那麼，ConcurrentHashMap 是怎麼實現線程安全的呢？\n\nJDK 1.7 時，採用**分段鎖**，主幹是一個 Segment 數組，Segment 裏維護著一個 HashEntry 數組。對同一 Segment 的數據進行操作需要考慮鎖競爭，不同的則不需要。\n\n![](java-collection/Untitled%205.png)\n\nJDK 1.8 開始取消了分段鎖，採用 **CAS（樂觀鎖） 和 synchronized（悲觀鎖）** 來保證並發安全。synchronized 只鎖定當前鏈表或紅黑二叉樹的首節點，這樣只要 hash 不衝突，就不會產生並發。\n\n![](java-collection/Untitled%206.png)","source":"_posts/it/java/java-collection.md","raw":"---\ntitle: Java 集合\np: it/java/java-collection.md\ntags:\n- Java\n---\n\nJava 集合分 List、Set、Map 三大類，其中 List 和 Set 實現了 Collection 接口。List 的特點是數據有序、可重複；Set 的特點是數據無序、不可重複；Map 存儲鍵值映射，Key 不可重複，Value 可重複，且一個 Key 只能對應一個 Value。\n\nList 有一實現 `ArrayList`，其底層實現是對象數組，默認容量是 10，但等到首次添加元素時才分配內存，每次遞增爲上次容量的 1.5 倍。在添加大量元素之前，建議調用 `ensureCapacity` 方法擴容，以減少遞增式再分配內存的次數。\n\nSet 有一實現 `HashSet`，其底層實現是 `HashMap` ，其檢查重複的機制有賴於 `hashCode` 和 `equals` 方法。\n\nMap 有一實現 `HashMap` ，JDK 1.8 之後其底層實現是：**數組 + 鏈表 + 紅黑二叉樹**。紅黑樹是爲了減少搜索時間，默認當鏈表長度大於 8 且當前數組長度大於等於 64 時，鏈表會轉爲紅黑樹。數組默認容量是 16，通過帶參構造方法傳入的容量值如非 2 的幂次會自動向上轉爲 2 的幂次，以便元素散列存儲（元素位置才可通過 `hash & (length-1)` 確定）。添加元素時，若元素數量大於數組長度的 75% 且該元素存在哈希衝突，則觸發擴容機制，數組容量翻倍。\n\n總結下 HashMap 中解決哈希衝突的方式：\n\n1. 使用鏈表 — 拉鍊法；\n2. 使用紅黑二叉樹；\n3. 擴容底層數組；\n4. 強制數組容量爲 2 之幂次；\n5. 將元素的 hash 值的高位分散到低位等等。\n\n`ArrayList`、`HashSet`、`HashMap` 都是線程不安全的。在多線程環境下應使用 J.U.C 包下的對應的並發類 `CopyOnWriteArrayList` 、`ConcurrentHashMap` （`HashSet` 用`ConcurrentHashMap` 的 keySet 可得 Set 視圖）。`CopyOnWriteArrayList` 會在寫時加鎖並複製集合進行操作；`ConcurrentHashMap` 在 JDK 1.7 使用分段鎖，在 JDK 1.8 取消分段鎖採用 CAS（樂觀鎖） 和 synchronized（悲觀鎖） 只對鏈表或紅黑二叉樹的節點加鎖。\n\n<!-- more -->\n\n## 概覽\n\n集合是相對數組來說，更靈活多樣的容器。Java 的集合框架肇始於兩大接口，Collection 和 Map。Collection 下有 List、Queue 和 Set 等等接口，然後衍生出 ArrayList、LinkedList、HashSet、TreeSet、LinkedHashSet 等等實現；Map 下有 HashMap、TreeMap 等重要子類。\n\n![](java-collection/Untitled.png)\n\n### List、Set、Map 三者之區別\n\n1. List：存儲的元素有序、可重複。\n2. Set：存儲的元素無序、不可重複。\n3. Map：使用鍵值對存儲，一鍵一值，Key 無序、不可重複；Value 無序、可重複。\n\n### List、Set、Map 三者之底層數據結構\n\n1. List\n    - ArrayList：Object 數組\n    - Vector：Object 數組\n    - LinkedList：雙向鏈表（JDK 1.6 之前爲循環鏈表）\n2. Set\n    - HashSet（無序、唯一）：基於 HashMap\n    - LinkedHashSet：基於 LinkedHashMap\n    - TreeSet（有序、唯一）：紅黑樹（自平衡的排序二叉樹）\n3. Map\n    - HashMap：數組 + 鏈表 + 紅黑樹（鏈表長於閾值即轉爲紅黑樹以減少搜索時間；閾值默認爲 8；JDK 1.8 之前沒有紅黑樹）\n    - LinkedHashMap：繼承自 HashMap，但多了一條雙向鏈表\n    - Hashtable：數組 + 鏈表\n    - TreeMap：紅黑樹（自平衡的排序二叉樹）\n\n### Iterator 迭代器\n\n迭代器就是 Iterator 接口，它抽象出迭代一個集合需要的方法，`hasNext()` 和 `next()` 方法，以便集合類實現該接口，從而方便對集合的遍歷。有了迭代器就可以在迭代集合元素時更改元素而不拋出 `ConcurrentModificationException` 了。\n\n爲什麼？因爲非採用 Iterator 進行遍歷時更改元素會修改到 `modCount` 變量（用於紀錄集合結構性改變的次數）的值，而沒有修改 `expectedModCount` 的值，基於 fail-fast 機制檢查兩值是否相同時會拋出異常；而使用 Iterator 遍歷時更改元素會同時修改 `modCount` 和 `expectedModCount`，兩者相等，不會拋出異常。\n\n```java\nMap<Integer, String> map = new HashMap();\nmap.put(1, \"Java\");\nmap.put(2, \"Python\");\nmap.put(2, \"Go\");\nIterator<Map.Entry<Integer, String>> iterator = map.entrySet().iterator();\nwhile (iterator.hasNext()) {\n  Map.Entry<Integer, String> entry = iterator.next();\n  System.out.println(entry.getKey() + entry.getValue());\n}\n```\n\n### 有哪些集合是線程不安全的？怎麼解決？\n\n常用的 `ArrayList`、`LinkedList`、`HashMap`、`HashSet`、`TreeSet`、`TreeMap`、`PriorityQueue` 都不是線程安全的。解決方法就是用 `java.util.concurrent` 包提供的線程安全的集合來代替：\n\n1. `ConcurrentHashMap` 代替 `HashMap`；\n2. `CopyOnWriteArrayList` 代替 `ArrayList`；\n3. `ConcurrentLinkedQueue` 代替 `LinkedList` ；\n4. `BlockingQueue` 接口下的 `PriorityBlockingQueue`、`LinkedBlockingQueue` 等阻塞隊列代替 `PriorityQueue`  等；\n5. `ConcurrentSkipListMap`  代替 `TreeMap` ，實現多線程下保證按 Key 的順序存儲元素。\n\n### `length`、`length()`、`size()` 三者用途\n\n1. `length`：用於數組。\n2. `length()`：用於字符串。\n3. `size()`：用於集合。\n\n### Collections 工具類的使用\n\n- 排序\n\n    ```java\n    //反轉\n    void reverse(List list)\n    //隨機排序\n    void shuffle(List list)\n    //按自然排序的升序排序\n    void sort(List list)\n    //定制排序，由Comparator控制排序邏輯\n    void sort(List list, Comparator c)\n    //交換兩個索引位置的元素\n    void swap(List list, int i , int j)\n    //旋轉。當distance為正數時，將list後distance個元素整體移到前面。當distance為負數時，將 list的前distance個元素整體移到後面\n    void rotate(List list, int distance)\n    ```\n\n- 查找替換統計\n\n    ```java\n    //對List進行二分查找，返回索引，注意List必須是有序的\n    int binarySearch(List list, Object key)\n    //根據元素的自然順序，返回最大的元素。 類比int min(Collection coll)\n    int max(Collection coll)\n    //根據定制排序，返回最大元素，排序規則由Comparatator類控制。類比int min(Collection coll, Comparator c)\n    int max(Collection coll, Comparator c)\n    //用指定的元素代替指定list中的所有元素\n    void fill(List list, Object obj)\n    //用新元素替換舊元素\n    boolean replaceAll(List list, Object oldVal, Object newVal) \n    //統計元素出現次數\n    int frequency(Collection c, Object o)\n    //統計target在list中第一次出現的索引，找不到則返回-1，類比int lastIndexOfSubList(List source, list target)\n    int indexOfSubList(List list, List target)\n    ```\n\n## List\n\n### 比較 ArrayList 與 LinkedList\n\n共同點：\n\n1. 都實現了 List 接口；\n2. 都是不同步的，不保證線程安全。\n\n不同點：\n\n1. **底層數據結構不同**。ArrayList 是對象數組；LinkedList 是雙向鏈表（JDK 1.6 之前爲循環列表）。\n2. **插入和刪除的時間複雜度不同**。ArrayList 追加元素的複雜度爲 O(1)，指定位置 i 插入或刪除元素的複雜度爲 O(n-i)；LinkedList 追加元素和刪除末端元素的時間複雜度爲 O(1)，指定位置 i 插入或刪除元素的時間複雜度近似 O(n)。\n3. **對快速隨機訪問的支持不同**。ArrayList 支持快速隨機訪問；LinkedList 不支持。\n4. **對空間的利用不同**。ArrayList 末尾會預留一定的空間以便元素新增；LinkedList 則是會在每個元素多存儲了指針數據。\n- 比較雙向鏈表與雙向循環鏈表\n\n    ![](java-collection/Untitled%201.png)\n\n    ![](java-collection/Untitled%202.png)\n\n### ArrayList 擴容機制\n\nArrayList 底層是對象數組，其容量可以動態增長。在添加大量元素之前，建議調用 `ensureCapacity` 方法擴容，以減少遞增式再分配內存的次數，提升程序效率。\n\n其擴容機制大致是這樣的：ArrayList 提供了默認構造方法，通過默認構造方法構造對象，默認容量值爲 10 ，但此時未分配相應內存空間，而是**等到首次添加元素時才開始初始化**一個空間爲 10 的對象數組。當第 11 個元素加入時會觸發擴容機制，**容量會擴充到原來的 1.5 倍**（`newCapacity = oldCapacity + oldCapacity >> 2`），即變爲 15。如通過指定相應的容量大小的構造方法構造對象且指定的容量值大於 0 ，則一開始就會分配相應的內存空間。\n\n### 快速隨機訪問 RandomAccess\n\nRandomAccess 接口爲空實現，僅僅標識著實現類具備快速隨機訪問的能力。ArrayList 實現了該接口，而 LinkedList 未實現。\n\n```java\npublic interface RandomAccess {\n}\n```\n\n### `System.arraycopy()` 與 `Arrays.copyOf()` 方法\n\n1. `System.arraycopy()` 方法用於源數組到目標數組之間的數據拷貝；\n2. `Arrays.copyOf()` 方法用於給源數組擴容，底層調用`System.arraycopy()` 。\n\n### CopyOnWriteArrayList 的特點\n\n1. 寫時會加鎖並複製整個集合；\n2. 讀時可能讀到舊數據。\n\n### **如何移除列表中的元素**\n\n首先，不能在 foreach 循環中移除元素，根據 fail-fast（快速失敗） 機制，會拋出 `ConcurrentModificationException` （並發修改異常）。\n\n可以採用 `iterator` 或者 `Collection.removeIf()` 方法移除列表元素。\n\n```java\nString[] arrs = {\"a\", \"b\", \"c\"};\nList<String> list = Arrays.stream(arrs).collect(Collectors.toList());\n\n// 採用 iterator\nIterator<String> iterator = list.iterator();\nwhile (iterator.hasNext()) {\n    if (\"a\".equals(iterator.next())) {\n        iterator.remove();\n        break;\n    }\n}\n\n// 採用 removeIf 方法，\"a\"::equals 等價於 x -> \"a\".equals(x)\nlist.removeIf(\"a\"::equals); \n\nSystem.out.println(list);\n```\n\n### **正確使用 Arrays.asList**\n\n如果非要在 `foreach` 循環中刪除元素，還可以使用 `CopyOnWriteArrayList`，此集合是 `fail-safe` 的。`CopyOnWriteArrayList` 修改元素時會 copy 一個新列表進行修改，不會改變迭代中的列表，因此是安全的，但會產生新的列表作爲代價。\n\nArrays 工具類有一個靜態方法 `asList(T... a)`，能將**對象**數組包裝成一個 List，底層數據依然是原數組，原數組改變，List 也隨之改變，但 List 本身的 `add`/`remove`/`clear` 並不可用，調用會拋出 `UnsupportedOperationException`。\n\nArrays 類中關於 `asList` 方法的代碼如下：\n\n```java\npublic static <T> List<T> asList(T... a) {\n\t\t// 這裏的 ArrayList 是 Arrays 類中定義的私有靜態類，不是 java.util.ArrayList\n    return new ArrayList<>(a);\n}\n```\n\n爲什麼 `asList` 方法傳入的必須是對象數組呢？\n\n你看上面的代碼，泛型，沒錯泛型只能是對象啊，基本類型是不行的。\n\n傳入基本類型的數組會怎樣呢？請看下面代碼：\n\n```java\nint[] ints = {1, 3, 4};\n// 此時的泛型是 int[] 對象，而非 int\nList<int[]> list = Arrays.asList(ints);\n// list 的大小爲 1，就是 ints 這個數組對象\nSystem.out.println(list.size());\n```\n\n### **把數組轉爲 `java.util.ArrayList`**\n\n那麼，如何簡便地把一個數組轉爲普遍意義上的 ArrayList 呢？\n\n```java\n// 1) 使用 ArrayList 的帶參構造方法\nList<String> list = new ArrayList<>(Arrays.asList(arrs));\n\n// 2) 使用 Java 8 的 Stream API\nList<String> list = Arrays.stream(arrs).collect(Collectors.toList());\n// boxed 方法可以把基本類型轉成包裝類型\nList<Integer> intList = Arrays.stream(ints).boxed().collect(Collectors.toList());\n\n// 3) 使用 Guava 包的 API\nImmutableList<String[]> list = ImmutableList.of(arrs);\nImmutableList<String> list1 = ImmutableList.copyOf(arrs);\nArrayList<String> list2 = Lists.newArrayList(arrs);\n\n// 4) 使用 Java 9 的 API\nList<String> list = List.of(arrs);\n```\n\n### **將 List 轉爲數組**\n\n使用 List 的 `toArray` 方法可以將 List 轉爲數組，代碼如下：\n\n```java\n// new String[0] 僅僅爲了告知類型返回數組的類型\nString[] strings = list.toArray(new String[0]);\n```\n\n## Set\n\n### 無序性和不可重複性的含義\n\n無序性並不等同於隨機性，而是根據數據的哈希值決定其存儲位置，使用者無法指定其存儲順序。\n\n不可重複性是指添加的元素按 equals 方法判斷結果爲 false。\n\n### 比較 HashSet、LinkedHashSet 和 TreeSet\n\n共同點：\n\n1. 都實現了 Set 接口；\n2. 元素不可重複；\n3. 都是線程不安全的。\n\n不同點：\n\n1. **底層數據接口不同**。HashSet 底層是 HashMap；LinkedHashSet 底層是 LinkedHashMap；TreeSet 底層是紅黑樹。\n2. **有序性不同**。HashSet 無序；LinkedHashSet 和 TreeSet 有序。TreeSet 還可以自定義排序。\n\n### 自定義排序的實現\n\n自定義排序最通用的就是給要排序的類實現一個 Comparable 接口，隨後可以使用 Collection.sort 方法進行排序。又或者不實現 Comparable 接口，而是傳入 Comparator 到 Collection.sort 方法中。\n\n### HashSet 如何檢查重複\n\nHashSet 集合進行元素重複校驗時先比較 hashcode ，當 hashcode 一樣時再調用 equals，提高了校驗效率。因此，如果只重寫 equals 方法而不重寫 hashcode 方法，會出現 equals 返回 true，而 hashcode 不等的情況，這樣如果要求 HashSet 去重就會失敗。\n\n## Map\n\n### 比較 HashMap 與 TreeMap\n\n共同點：\n\n1. 都繼承自 AbstractMap，間接實現了 Map 接口；\n2. 都是線程不安全的。\n\n不同點：\n\n1. **底層數據結構不同**。HashMap 底層是數組 + 鏈表 + 紅黑樹（鏈表長於閾值即轉爲紅黑樹以減少搜索時間；閾值默認爲 8；JDK 1.8 之前沒有紅黑樹）；TreeMap 底層是紅黑樹。\n2. **HashMap 無搜索和排序的能力**。TreeMap 實現了 NavigableMap 接口，使其有對集合內元素搜索的能力；實現了 SortMap 接口，使其有對集合內元素根據鍵排序的能力。\n\n### HashMap 底層實現\n\nJDK 1.7 或之前，HashMap 的底層實現是數組+鏈表。該數組的定義如下：\n\n```java\ntransient Node<K,V>[] table;\n```\n\nNode 存儲了鍵、值、哈希值和下一個節點，是一個鏈表，也就是說 Node 數組就是一個鏈表數組。\n\n![](java-collection/Untitled%203.png)\n\n該數組默認大小是 `1 << 4 = 16` 。調用 put 方法增加元素時，通過散列算法（hash方法，也稱之爲擾動函數）算得元素的 hash 值，然後計算其應插入的桶（數組中的一個位置）。如果該位置已有元素，就會產生哈希衝突（或稱碰撞），此時通過**拉鍊法**解決。當 Map 中包含的元素數量大於等於 `threshold = loadFactor * capacity` （loadFactor 默認爲 0.75f），且新建的元素剛好落在一個非空的桶上時，會觸發擴容機制，將數組容量擴大 2 倍。\n\nJDK 1.8 開始，HashMap 的底層實現是數組+鏈表+紅黑樹，**當鏈表長度大於閾值（默認爲 8），且當前數組長度大於等於 64 時，該鏈表會轉爲紅黑樹，以減少搜索時間。**\n\n![](java-collection/Untitled%204.png)\n\n**（1）散列算法**\n\n首先獲取 key 的 hash 值，然後將高位的 hash 分散到低位，以便減少哈希衝突。\n\n```java\n// JDK 1.7\nstatic int hash(int h) {\n  // This function ensures that hashCodes that differ only by\n  // constant multiples at each bit position have a bounded\n  // number of collisions (approximately 8 at default load factor).\n  h ^= (h >>> 20) ^ (h >>> 12);\n  return h ^ (h >>> 7) ^ (h >>> 4);\n}\n// JDK 1.8\nstatic final int hash(Object key) {\n  int h;\n  return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\n```\n\n**（2）插入算法**\n\n如何根據散列值確定要插入的數組位置呢？因爲保證了數組長度爲 2 之幂次，所以確定插入位置時的取餘算法 `hash % length` 等價於 `h & (length-1)`。簡單起見，假定 hash 爲 0100 1010； length 是 8，其二進制爲 0000 1000，取餘爲 `hash % length` = 0000 0010 = `h & (length-1)`。此處 hash 值的高位 0100 並沒有用到，會造成高位不同而低位相同的 hash 值衝突，這也是散列算法要將高位分散到低位的緣故。\n\n```java\n/**\n* Returns index for hash code h.\n*/\nstatic int indexFor(int h, int length) {\n  return h & (length-1);\n}\n```\n\n**（3）拉鍊法**\n\n將衝突的值加到鏈表中。\n\n**（4）保證數組長度爲 2 之幂次的方法**\n\n- 方法一（JDK 1.8 或以前）：將原數二進制表示的第一個非零位後面的所有零位填滿爲 1，然後再加 1。\n\n    ```java\n    static final int tableSizeFor(int cap) {\n        int n = cap - 1;\n        n |= n >>> 1;\n        n |= n >>> 2;\n        n |= n >>> 4;\n        n |= n >>> 8;\n        n |= n >>> 16;\n        return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\n    }\n    ```\n\n- 方法二（JDK 15）：計算原數二進制表示的第一個非零位前面零的數量 k，然後將 -1 (其二進制形式全是1)無符號右移 k 位再加 1。\n\n    ```java\n    // HashMap.java\n    static final int tableSizeFor(int cap) {\n      int n = -1 >>> Integer.numberOfLeadingZeros(cap - 1);\n      return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\n    }\n\n    // Integer.java\n    // 取得整數二進制表示前面的零位數量\n    public static int numberOfLeadingZeros(int i) {\n      // HD, Count leading 0's\n      if (i <= 0)\n          return i == 0 ? 32 : 0;\n      int n = 31;\n      if (i >= 1 << 16) { n -= 16; i >>>= 16; }\n      if (i >= 1 <<  8) { n -=  8; i >>>=  8; }\n      if (i >= 1 <<  4) { n -=  4; i >>>=  4; }\n      if (i >= 1 <<  2) { n -=  2; i >>>=  2; }\n      return n - (i >>> 1);\n    }\n    ```\n\n- 方法三（不推薦）：將原數以 2 爲底取對數，然後再取其 ceil 值，將其作爲 2 的指數計算即可。\n\n    ```java\n    int n = (int) Math.pow(2, (int) Math.ceil(Math.log(cap) / Math.log(2)));\n    ```\n\n### 遍歷 HashMap 的幾種方式\n\nHashMap 有四大類遍歷方式：iterator、for、lambda 和 stream。性能上 stream 的並行循環最高，其他的差別不大。安全性上在遍歷時應使用 `iterator.remove`方法刪除元素或者用 stream 的 `filter` 過濾不需要的數據再進行循環。參見 [https://mp.weixin.qq.com/s/Zz6mofCtmYpABDL1ap04ow](https://mp.weixin.qq.com/s/Zz6mofCtmYpABDL1ap04ow)\n\n```java\nMap<String, String> map = new HashMap<>();\nmap.put(\"lang\", \"java\");\nmap.put(\"sys\", \"linux\");\n// iterator\nIterator<Map.Entry<String, String>> iterator = map.entrySet().iterator();\nwhile (iterator.hasNext()) {\n  Map.Entry<String, String> entry = iterator.next();\n  System.out.println(entry.getKey() + \":\" + entry.getValue());\n}\n// for，增強 for 循環，使用了迭代器\nfor (Map.Entry<String, String> entry : map.entrySet()) {\n  System.out.println(entry.getKey() + \":\" + entry.getValue());\n}\n// lambda\nmap.forEach((key, value) -> {\n  System.out.println(key + \":\" + value);\n});\n// stream\nmap.entrySet().parallelStream().forEach((entry) -> {\n  System.out.println(entry.getKey() + \":\" + entry.getValue());\n});\n```\n\n### ConcurrentHashMap 線程安全的原因\n\n我們知道 HashMap 是線程不安全的，在多線程環境下需要用 ConcurrentHashMap 代替。那麼，ConcurrentHashMap 是怎麼實現線程安全的呢？\n\nJDK 1.7 時，採用**分段鎖**，主幹是一個 Segment 數組，Segment 裏維護著一個 HashEntry 數組。對同一 Segment 的數據進行操作需要考慮鎖競爭，不同的則不需要。\n\n![](java-collection/Untitled%205.png)\n\nJDK 1.8 開始取消了分段鎖，採用 **CAS（樂觀鎖） 和 synchronized（悲觀鎖）** 來保證並發安全。synchronized 只鎖定當前鏈表或紅黑二叉樹的首節點，這樣只要 hash 不衝突，就不會產生並發。\n\n![](java-collection/Untitled%206.png)","slug":"it/java/java-collection","published":1,"date":"2020-12-01T22:56:04.000Z","updated":"2020-12-02T07:03:36.480Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cki72psxk000eslw803sk63bx","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css\"><p>Java 集合分 List、Set、Map 三大類，其中 List 和 Set 實現了 Collection 接口。List 的特點是數據有序、可重複；Set 的特點是數據無序、不可重複；Map 存儲鍵值映射，Key 不可重複，Value 可重複，且一個 Key 只能對應一個 Value。</p>\n<p>List 有一實現 <code>ArrayList</code>，其底層實現是對象數組，默認容量是 10，但等到首次添加元素時才分配內存，每次遞增爲上次容量的 1.5 倍。在添加大量元素之前，建議調用 <code>ensureCapacity</code> 方法擴容，以減少遞增式再分配內存的次數。</p>\n<p>Set 有一實現 <code>HashSet</code>，其底層實現是 <code>HashMap</code> ，其檢查重複的機制有賴於 <code>hashCode</code> 和 <code>equals</code> 方法。</p>\n<p>Map 有一實現 <code>HashMap</code> ，JDK 1.8 之後其底層實現是：<strong>數組 + 鏈表 + 紅黑二叉樹</strong>。紅黑樹是爲了減少搜索時間，默認當鏈表長度大於 8 且當前數組長度大於等於 64 時，鏈表會轉爲紅黑樹。數組默認容量是 16，通過帶參構造方法傳入的容量值如非 2 的幂次會自動向上轉爲 2 的幂次，以便元素散列存儲（元素位置才可通過 <code>hash &amp; (length-1)</code> 確定）。添加元素時，若元素數量大於數組長度的 75% 且該元素存在哈希衝突，則觸發擴容機制，數組容量翻倍。</p>\n<p>總結下 HashMap 中解決哈希衝突的方式：</p>\n<ol>\n<li>使用鏈表 — 拉鍊法；</li>\n<li>使用紅黑二叉樹；</li>\n<li>擴容底層數組；</li>\n<li>強制數組容量爲 2 之幂次；</li>\n<li>將元素的 hash 值的高位分散到低位等等。</li>\n</ol>\n<p><code>ArrayList</code>、<code>HashSet</code>、<code>HashMap</code> 都是線程不安全的。在多線程環境下應使用 J.U.C 包下的對應的並發類 <code>CopyOnWriteArrayList</code> 、<code>ConcurrentHashMap</code> （<code>HashSet</code> 用<code>ConcurrentHashMap</code> 的 keySet 可得 Set 視圖）。<code>CopyOnWriteArrayList</code> 會在寫時加鎖並複製集合進行操作；<code>ConcurrentHashMap</code> 在 JDK 1.7 使用分段鎖，在 JDK 1.8 取消分段鎖採用 CAS（樂觀鎖） 和 synchronized（悲觀鎖） 只對鏈表或紅黑二叉樹的節點加鎖。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"概覽\"><a href=\"#概覽\" class=\"headerlink\" title=\"概覽\"></a>概覽</h2><p>集合是相對數組來說，更靈活多樣的容器。Java 的集合框架肇始於兩大接口，Collection 和 Map。Collection 下有 List、Queue 和 Set 等等接口，然後衍生出 ArrayList、LinkedList、HashSet、TreeSet、LinkedHashSet 等等實現；Map 下有 HashMap、TreeMap 等重要子類。</p>\n<p><img src=\"/2020/12/02/it/java/java-collection/Untitled.png\" alt></p>\n<h3 id=\"List、Set、Map-三者之區別\"><a href=\"#List、Set、Map-三者之區別\" class=\"headerlink\" title=\"List、Set、Map 三者之區別\"></a>List、Set、Map 三者之區別</h3><ol>\n<li>List：存儲的元素有序、可重複。</li>\n<li>Set：存儲的元素無序、不可重複。</li>\n<li>Map：使用鍵值對存儲，一鍵一值，Key 無序、不可重複；Value 無序、可重複。</li>\n</ol>\n<h3 id=\"List、Set、Map-三者之底層數據結構\"><a href=\"#List、Set、Map-三者之底層數據結構\" class=\"headerlink\" title=\"List、Set、Map 三者之底層數據結構\"></a>List、Set、Map 三者之底層數據結構</h3><ol>\n<li>List<ul>\n<li>ArrayList：Object 數組</li>\n<li>Vector：Object 數組</li>\n<li>LinkedList：雙向鏈表（JDK 1.6 之前爲循環鏈表）</li>\n</ul>\n</li>\n<li>Set<ul>\n<li>HashSet（無序、唯一）：基於 HashMap</li>\n<li>LinkedHashSet：基於 LinkedHashMap</li>\n<li>TreeSet（有序、唯一）：紅黑樹（自平衡的排序二叉樹）</li>\n</ul>\n</li>\n<li>Map<ul>\n<li>HashMap：數組 + 鏈表 + 紅黑樹（鏈表長於閾值即轉爲紅黑樹以減少搜索時間；閾值默認爲 8；JDK 1.8 之前沒有紅黑樹）</li>\n<li>LinkedHashMap：繼承自 HashMap，但多了一條雙向鏈表</li>\n<li>Hashtable：數組 + 鏈表</li>\n<li>TreeMap：紅黑樹（自平衡的排序二叉樹）</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"Iterator-迭代器\"><a href=\"#Iterator-迭代器\" class=\"headerlink\" title=\"Iterator 迭代器\"></a>Iterator 迭代器</h3><p>迭代器就是 Iterator 接口，它抽象出迭代一個集合需要的方法，<code>hasNext()</code> 和 <code>next()</code> 方法，以便集合類實現該接口，從而方便對集合的遍歷。有了迭代器就可以在迭代集合元素時更改元素而不拋出 <code>ConcurrentModificationException</code> 了。</p>\n<p>爲什麼？因爲非採用 Iterator 進行遍歷時更改元素會修改到 <code>modCount</code> 變量（用於紀錄集合結構性改變的次數）的值，而沒有修改 <code>expectedModCount</code> 的值，基於 fail-fast 機制檢查兩值是否相同時會拋出異常；而使用 Iterator 遍歷時更改元素會同時修改 <code>modCount</code> 和 <code>expectedModCount</code>，兩者相等，不會拋出異常。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Map&lt;Integer, String&gt; map = <span class=\"keyword\">new</span> HashMap();</span><br><span class=\"line\">map.put(<span class=\"number\">1</span>, <span class=\"string\">\"Java\"</span>);</span><br><span class=\"line\">map.put(<span class=\"number\">2</span>, <span class=\"string\">\"Python\"</span>);</span><br><span class=\"line\">map.put(<span class=\"number\">2</span>, <span class=\"string\">\"Go\"</span>);</span><br><span class=\"line\">Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span> (iterator.hasNext()) &#123;</span><br><span class=\"line\">  Map.Entry&lt;Integer, String&gt; entry = iterator.next();</span><br><span class=\"line\">  System.out.println(entry.getKey() + entry.getValue());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"有哪些集合是線程不安全的？怎麼解決？\"><a href=\"#有哪些集合是線程不安全的？怎麼解決？\" class=\"headerlink\" title=\"有哪些集合是線程不安全的？怎麼解決？\"></a>有哪些集合是線程不安全的？怎麼解決？</h3><p>常用的 <code>ArrayList</code>、<code>LinkedList</code>、<code>HashMap</code>、<code>HashSet</code>、<code>TreeSet</code>、<code>TreeMap</code>、<code>PriorityQueue</code> 都不是線程安全的。解決方法就是用 <code>java.util.concurrent</code> 包提供的線程安全的集合來代替：</p>\n<ol>\n<li><code>ConcurrentHashMap</code> 代替 <code>HashMap</code>；</li>\n<li><code>CopyOnWriteArrayList</code> 代替 <code>ArrayList</code>；</li>\n<li><code>ConcurrentLinkedQueue</code> 代替 <code>LinkedList</code> ；</li>\n<li><code>BlockingQueue</code> 接口下的 <code>PriorityBlockingQueue</code>、<code>LinkedBlockingQueue</code> 等阻塞隊列代替 <code>PriorityQueue</code>  等；</li>\n<li><code>ConcurrentSkipListMap</code>  代替 <code>TreeMap</code> ，實現多線程下保證按 Key 的順序存儲元素。</li>\n</ol>\n<h3 id=\"length、length-、size-三者用途\"><a href=\"#length、length-、size-三者用途\" class=\"headerlink\" title=\"length、length()、size() 三者用途\"></a><code>length</code>、<code>length()</code>、<code>size()</code> 三者用途</h3><ol>\n<li><code>length</code>：用於數組。</li>\n<li><code>length()</code>：用於字符串。</li>\n<li><code>size()</code>：用於集合。</li>\n</ol>\n<h3 id=\"Collections-工具類的使用\"><a href=\"#Collections-工具類的使用\" class=\"headerlink\" title=\"Collections 工具類的使用\"></a>Collections 工具類的使用</h3><ul>\n<li><p>排序</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//反轉</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">reverse</span><span class=\"params\">(List list)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//隨機排序</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">shuffle</span><span class=\"params\">(List list)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//按自然排序的升序排序</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(List list)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//定制排序，由Comparator控制排序邏輯</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(List list, Comparator c)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//交換兩個索引位置的元素</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(List list, <span class=\"keyword\">int</span> i , <span class=\"keyword\">int</span> j)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//旋轉。當distance為正數時，將list後distance個元素整體移到前面。當distance為負數時，將 list的前distance個元素整體移到後面</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">rotate</span><span class=\"params\">(List list, <span class=\"keyword\">int</span> distance)</span></span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>查找替換統計</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//對List進行二分查找，返回索引，注意List必須是有序的</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">binarySearch</span><span class=\"params\">(List list, Object key)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//根據元素的自然順序，返回最大的元素。 類比int min(Collection coll)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">max</span><span class=\"params\">(Collection coll)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//根據定制排序，返回最大元素，排序規則由Comparatator類控制。類比int min(Collection coll, Comparator c)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">max</span><span class=\"params\">(Collection coll, Comparator c)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//用指定的元素代替指定list中的所有元素</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fill</span><span class=\"params\">(List list, Object obj)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//用新元素替換舊元素</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">replaceAll</span><span class=\"params\">(List list, Object oldVal, Object newVal)</span> </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//統計元素出現次數</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">frequency</span><span class=\"params\">(Collection c, Object o)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//統計target在list中第一次出現的索引，找不到則返回-1，類比int lastIndexOfSubList(List source, list target)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">indexOfSubList</span><span class=\"params\">(List list, List target)</span></span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h2 id=\"List\"><a href=\"#List\" class=\"headerlink\" title=\"List\"></a>List</h2><h3 id=\"比較-ArrayList-與-LinkedList\"><a href=\"#比較-ArrayList-與-LinkedList\" class=\"headerlink\" title=\"比較 ArrayList 與 LinkedList\"></a>比較 ArrayList 與 LinkedList</h3><p>共同點：</p>\n<ol>\n<li>都實現了 List 接口；</li>\n<li>都是不同步的，不保證線程安全。</li>\n</ol>\n<p>不同點：</p>\n<ol>\n<li><strong>底層數據結構不同</strong>。ArrayList 是對象數組；LinkedList 是雙向鏈表（JDK 1.6 之前爲循環列表）。</li>\n<li><strong>插入和刪除的時間複雜度不同</strong>。ArrayList 追加元素的複雜度爲 O(1)，指定位置 i 插入或刪除元素的複雜度爲 O(n-i)；LinkedList 追加元素和刪除末端元素的時間複雜度爲 O(1)，指定位置 i 插入或刪除元素的時間複雜度近似 O(n)。</li>\n<li><strong>對快速隨機訪問的支持不同</strong>。ArrayList 支持快速隨機訪問；LinkedList 不支持。</li>\n<li><strong>對空間的利用不同</strong>。ArrayList 末尾會預留一定的空間以便元素新增；LinkedList 則是會在每個元素多存儲了指針數據。</li>\n</ol>\n<ul>\n<li><p>比較雙向鏈表與雙向循環鏈表</p>\n<p>  <img src=\"/2020/12/02/it/java/java-collection/Untitled%201.png\" alt></p>\n<p>  <img src=\"/2020/12/02/it/java/java-collection/Untitled%202.png\" alt></p>\n</li>\n</ul>\n<h3 id=\"ArrayList-擴容機制\"><a href=\"#ArrayList-擴容機制\" class=\"headerlink\" title=\"ArrayList 擴容機制\"></a>ArrayList 擴容機制</h3><p>ArrayList 底層是對象數組，其容量可以動態增長。在添加大量元素之前，建議調用 <code>ensureCapacity</code> 方法擴容，以減少遞增式再分配內存的次數，提升程序效率。</p>\n<p>其擴容機制大致是這樣的：ArrayList 提供了默認構造方法，通過默認構造方法構造對象，默認容量值爲 10 ，但此時未分配相應內存空間，而是<strong>等到首次添加元素時才開始初始化</strong>一個空間爲 10 的對象數組。當第 11 個元素加入時會觸發擴容機制，<strong>容量會擴充到原來的 1.5 倍</strong>（<code>newCapacity = oldCapacity + oldCapacity &gt;&gt; 2</code>），即變爲 15。如通過指定相應的容量大小的構造方法構造對象且指定的容量值大於 0 ，則一開始就會分配相應的內存空間。</p>\n<h3 id=\"快速隨機訪問-RandomAccess\"><a href=\"#快速隨機訪問-RandomAccess\" class=\"headerlink\" title=\"快速隨機訪問 RandomAccess\"></a>快速隨機訪問 RandomAccess</h3><p>RandomAccess 接口爲空實現，僅僅標識著實現類具備快速隨機訪問的能力。ArrayList 實現了該接口，而 LinkedList 未實現。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">RandomAccess</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"System-arraycopy-與-Arrays-copyOf-方法\"><a href=\"#System-arraycopy-與-Arrays-copyOf-方法\" class=\"headerlink\" title=\"System.arraycopy() 與 Arrays.copyOf() 方法\"></a><code>System.arraycopy()</code> 與 <code>Arrays.copyOf()</code> 方法</h3><ol>\n<li><code>System.arraycopy()</code> 方法用於源數組到目標數組之間的數據拷貝；</li>\n<li><code>Arrays.copyOf()</code> 方法用於給源數組擴容，底層調用<code>System.arraycopy()</code> 。</li>\n</ol>\n<h3 id=\"CopyOnWriteArrayList-的特點\"><a href=\"#CopyOnWriteArrayList-的特點\" class=\"headerlink\" title=\"CopyOnWriteArrayList 的特點\"></a>CopyOnWriteArrayList 的特點</h3><ol>\n<li>寫時會加鎖並複製整個集合；</li>\n<li>讀時可能讀到舊數據。</li>\n</ol>\n<h3 id=\"如何移除列表中的元素\"><a href=\"#如何移除列表中的元素\" class=\"headerlink\" title=\"如何移除列表中的元素\"></a><strong>如何移除列表中的元素</strong></h3><p>首先，不能在 foreach 循環中移除元素，根據 fail-fast（快速失敗） 機制，會拋出 <code>ConcurrentModificationException</code> （並發修改異常）。</p>\n<p>可以採用 <code>iterator</code> 或者 <code>Collection.removeIf()</code> 方法移除列表元素。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">String[] arrs = &#123;<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>&#125;;</span><br><span class=\"line\">List&lt;String&gt; list = Arrays.stream(arrs).collect(Collectors.toList());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 採用 iterator</span></span><br><span class=\"line\">Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span> (iterator.hasNext()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"string\">\"a\"</span>.equals(iterator.next())) &#123;</span><br><span class=\"line\">        iterator.remove();</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 採用 removeIf 方法，\"a\"::equals 等價於 x -&gt; \"a\".equals(x)</span></span><br><span class=\"line\">list.removeIf(<span class=\"string\">\"a\"</span>::equals); </span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(list);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"正確使用-Arrays-asList\"><a href=\"#正確使用-Arrays-asList\" class=\"headerlink\" title=\"正確使用 Arrays.asList\"></a><strong>正確使用 Arrays.asList</strong></h3><p>如果非要在 <code>foreach</code> 循環中刪除元素，還可以使用 <code>CopyOnWriteArrayList</code>，此集合是 <code>fail-safe</code> 的。<code>CopyOnWriteArrayList</code> 修改元素時會 copy 一個新列表進行修改，不會改變迭代中的列表，因此是安全的，但會產生新的列表作爲代價。</p>\n<p>Arrays 工具類有一個靜態方法 <code>asList(T... a)</code>，能將<strong>對象</strong>數組包裝成一個 List，底層數據依然是原數組，原數組改變，List 也隨之改變，但 List 本身的 <code>add</code>/<code>remove</code>/<code>clear</code> 並不可用，調用會拋出 <code>UnsupportedOperationException</code>。</p>\n<p>Arrays 類中關於 <code>asList</code> 方法的代碼如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">List&lt;T&gt; <span class=\"title\">asList</span><span class=\"params\">(T... a)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 這裏的 ArrayList 是 Arrays 類中定義的私有靜態類，不是 java.util.ArrayList</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ArrayList&lt;&gt;(a);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>爲什麼 <code>asList</code> 方法傳入的必須是對象數組呢？</p>\n<p>你看上面的代碼，泛型，沒錯泛型只能是對象啊，基本類型是不行的。</p>\n<p>傳入基本類型的數組會怎樣呢？請看下面代碼：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span>[] ints = &#123;<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 此時的泛型是 int[] 對象，而非 int</span></span><br><span class=\"line\">List&lt;<span class=\"keyword\">int</span>[]&gt; list = Arrays.asList(ints);</span><br><span class=\"line\"><span class=\"comment\">// list 的大小爲 1，就是 ints 這個數組對象</span></span><br><span class=\"line\">System.out.println(list.size());</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"把數組轉爲-java-util-ArrayList\"><a href=\"#把數組轉爲-java-util-ArrayList\" class=\"headerlink\" title=\"把數組轉爲 java.util.ArrayList\"></a><strong>把數組轉爲 <code>java.util.ArrayList</code></strong></h3><p>那麼，如何簡便地把一個數組轉爲普遍意義上的 ArrayList 呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1) 使用 ArrayList 的帶參構造方法</span></span><br><span class=\"line\">List&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(Arrays.asList(arrs));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2) 使用 Java 8 的 Stream API</span></span><br><span class=\"line\">List&lt;String&gt; list = Arrays.stream(arrs).collect(Collectors.toList());</span><br><span class=\"line\"><span class=\"comment\">// boxed 方法可以把基本類型轉成包裝類型</span></span><br><span class=\"line\">List&lt;Integer&gt; intList = Arrays.stream(ints).boxed().collect(Collectors.toList());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3) 使用 Guava 包的 API</span></span><br><span class=\"line\">ImmutableList&lt;String[]&gt; list = ImmutableList.of(arrs);</span><br><span class=\"line\">ImmutableList&lt;String&gt; list1 = ImmutableList.copyOf(arrs);</span><br><span class=\"line\">ArrayList&lt;String&gt; list2 = Lists.newArrayList(arrs);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 4) 使用 Java 9 的 API</span></span><br><span class=\"line\">List&lt;String&gt; list = List.of(arrs);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"將-List-轉爲數組\"><a href=\"#將-List-轉爲數組\" class=\"headerlink\" title=\"將 List 轉爲數組\"></a><strong>將 List 轉爲數組</strong></h3><p>使用 List 的 <code>toArray</code> 方法可以將 List 轉爲數組，代碼如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// new String[0] 僅僅爲了告知類型返回數組的類型</span></span><br><span class=\"line\">String[] strings = list.toArray(<span class=\"keyword\">new</span> String[<span class=\"number\">0</span>]);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h2><h3 id=\"無序性和不可重複性的含義\"><a href=\"#無序性和不可重複性的含義\" class=\"headerlink\" title=\"無序性和不可重複性的含義\"></a>無序性和不可重複性的含義</h3><p>無序性並不等同於隨機性，而是根據數據的哈希值決定其存儲位置，使用者無法指定其存儲順序。</p>\n<p>不可重複性是指添加的元素按 equals 方法判斷結果爲 false。</p>\n<h3 id=\"比較-HashSet、LinkedHashSet-和-TreeSet\"><a href=\"#比較-HashSet、LinkedHashSet-和-TreeSet\" class=\"headerlink\" title=\"比較 HashSet、LinkedHashSet 和 TreeSet\"></a>比較 HashSet、LinkedHashSet 和 TreeSet</h3><p>共同點：</p>\n<ol>\n<li>都實現了 Set 接口；</li>\n<li>元素不可重複；</li>\n<li>都是線程不安全的。</li>\n</ol>\n<p>不同點：</p>\n<ol>\n<li><strong>底層數據接口不同</strong>。HashSet 底層是 HashMap；LinkedHashSet 底層是 LinkedHashMap；TreeSet 底層是紅黑樹。</li>\n<li><strong>有序性不同</strong>。HashSet 無序；LinkedHashSet 和 TreeSet 有序。TreeSet 還可以自定義排序。</li>\n</ol>\n<h3 id=\"自定義排序的實現\"><a href=\"#自定義排序的實現\" class=\"headerlink\" title=\"自定義排序的實現\"></a>自定義排序的實現</h3><p>自定義排序最通用的就是給要排序的類實現一個 Comparable 接口，隨後可以使用 Collection.sort 方法進行排序。又或者不實現 Comparable 接口，而是傳入 Comparator 到 Collection.sort 方法中。</p>\n<h3 id=\"HashSet-如何檢查重複\"><a href=\"#HashSet-如何檢查重複\" class=\"headerlink\" title=\"HashSet 如何檢查重複\"></a>HashSet 如何檢查重複</h3><p>HashSet 集合進行元素重複校驗時先比較 hashcode ，當 hashcode 一樣時再調用 equals，提高了校驗效率。因此，如果只重寫 equals 方法而不重寫 hashcode 方法，會出現 equals 返回 true，而 hashcode 不等的情況，這樣如果要求 HashSet 去重就會失敗。</p>\n<h2 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h2><h3 id=\"比較-HashMap-與-TreeMap\"><a href=\"#比較-HashMap-與-TreeMap\" class=\"headerlink\" title=\"比較 HashMap 與 TreeMap\"></a>比較 HashMap 與 TreeMap</h3><p>共同點：</p>\n<ol>\n<li>都繼承自 AbstractMap，間接實現了 Map 接口；</li>\n<li>都是線程不安全的。</li>\n</ol>\n<p>不同點：</p>\n<ol>\n<li><strong>底層數據結構不同</strong>。HashMap 底層是數組 + 鏈表 + 紅黑樹（鏈表長於閾值即轉爲紅黑樹以減少搜索時間；閾值默認爲 8；JDK 1.8 之前沒有紅黑樹）；TreeMap 底層是紅黑樹。</li>\n<li><strong>HashMap 無搜索和排序的能力</strong>。TreeMap 實現了 NavigableMap 接口，使其有對集合內元素搜索的能力；實現了 SortMap 接口，使其有對集合內元素根據鍵排序的能力。</li>\n</ol>\n<h3 id=\"HashMap-底層實現\"><a href=\"#HashMap-底層實現\" class=\"headerlink\" title=\"HashMap 底層實現\"></a>HashMap 底層實現</h3><p>JDK 1.7 或之前，HashMap 的底層實現是數組+鏈表。該數組的定義如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">transient</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure>\n\n<p>Node 存儲了鍵、值、哈希值和下一個節點，是一個鏈表，也就是說 Node 數組就是一個鏈表數組。</p>\n<p><img src=\"/2020/12/02/it/java/java-collection/Untitled%203.png\" alt></p>\n<p>該數組默認大小是 <code>1 &lt;&lt; 4 = 16</code> 。調用 put 方法增加元素時，通過散列算法（hash方法，也稱之爲擾動函數）算得元素的 hash 值，然後計算其應插入的桶（數組中的一個位置）。如果該位置已有元素，就會產生哈希衝突（或稱碰撞），此時通過<strong>拉鍊法</strong>解決。當 Map 中包含的元素數量大於等於 <code>threshold = loadFactor * capacity</code> （loadFactor 默認爲 0.75f），且新建的元素剛好落在一個非空的桶上時，會觸發擴容機制，將數組容量擴大 2 倍。</p>\n<p>JDK 1.8 開始，HashMap 的底層實現是數組+鏈表+紅黑樹，<strong>當鏈表長度大於閾值（默認爲 8），且當前數組長度大於等於 64 時，該鏈表會轉爲紅黑樹，以減少搜索時間。</strong></p>\n<p><img src=\"/2020/12/02/it/java/java-collection/Untitled%204.png\" alt></p>\n<p><strong>（1）散列算法</strong></p>\n<p>首先獲取 key 的 hash 值，然後將高位的 hash 分散到低位，以便減少哈希衝突。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// JDK 1.7</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(<span class=\"keyword\">int</span> h)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// This function ensures that hashCodes that differ only by</span></span><br><span class=\"line\">  <span class=\"comment\">// constant multiples at each bit position have a bounded</span></span><br><span class=\"line\">  <span class=\"comment\">// number of collisions (approximately 8 at default load factor).</span></span><br><span class=\"line\">  h ^= (h &gt;&gt;&gt; <span class=\"number\">20</span>) ^ (h &gt;&gt;&gt; <span class=\"number\">12</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> h ^ (h &gt;&gt;&gt; <span class=\"number\">7</span>) ^ (h &gt;&gt;&gt; <span class=\"number\">4</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// JDK 1.8</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> h;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (key == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class=\"number\">16</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>（2）插入算法</strong></p>\n<p>如何根據散列值確定要插入的數組位置呢？因爲保證了數組長度爲 2 之幂次，所以確定插入位置時的取餘算法 <code>hash % length</code> 等價於 <code>h &amp; (length-1)</code>。簡單起見，假定 hash 爲 0100 1010； length 是 8，其二進制爲 0000 1000，取餘爲 <code>hash % length</code> = 0000 0010 = <code>h &amp; (length-1)</code>。此處 hash 值的高位 0100 並沒有用到，會造成高位不同而低位相同的 hash 值衝突，這也是散列算法要將高位分散到低位的緣故。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* Returns index for hash code h.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">indexFor</span><span class=\"params\">(<span class=\"keyword\">int</span> h, <span class=\"keyword\">int</span> length)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> h &amp; (length-<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>（3）拉鍊法</strong></p>\n<p>將衝突的值加到鏈表中。</p>\n<p><strong>（4）保證數組長度爲 2 之幂次的方法</strong></p>\n<ul>\n<li><p>方法一（JDK 1.8 或以前）：將原數二進制表示的第一個非零位後面的所有零位填滿爲 1，然後再加 1。</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">tableSizeFor</span><span class=\"params\">(<span class=\"keyword\">int</span> cap)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = cap - <span class=\"number\">1</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">2</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">4</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">8</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">16</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (n &lt; <span class=\"number\">0</span>) ? <span class=\"number\">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>方法二（JDK 15）：計算原數二進制表示的第一個非零位前面零的數量 k，然後將 -1 (其二進制形式全是1)無符號右移 k 位再加 1。</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// HashMap.java</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">tableSizeFor</span><span class=\"params\">(<span class=\"keyword\">int</span> cap)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> n = -<span class=\"number\">1</span> &gt;&gt;&gt; Integer.numberOfLeadingZeros(cap - <span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (n &lt; <span class=\"number\">0</span>) ? <span class=\"number\">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Integer.java</span></span><br><span class=\"line\"><span class=\"comment\">// 取得整數二進制表示前面的零位數量</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">numberOfLeadingZeros</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// HD, Count leading 0's</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (i &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> i == <span class=\"number\">0</span> ? <span class=\"number\">32</span> : <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> n = <span class=\"number\">31</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (i &gt;= <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">16</span>) &#123; n -= <span class=\"number\">16</span>; i &gt;&gt;&gt;= <span class=\"number\">16</span>; &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (i &gt;= <span class=\"number\">1</span> &lt;&lt;  <span class=\"number\">8</span>) &#123; n -=  <span class=\"number\">8</span>; i &gt;&gt;&gt;=  <span class=\"number\">8</span>; &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (i &gt;= <span class=\"number\">1</span> &lt;&lt;  <span class=\"number\">4</span>) &#123; n -=  <span class=\"number\">4</span>; i &gt;&gt;&gt;=  <span class=\"number\">4</span>; &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (i &gt;= <span class=\"number\">1</span> &lt;&lt;  <span class=\"number\">2</span>) &#123; n -=  <span class=\"number\">2</span>; i &gt;&gt;&gt;=  <span class=\"number\">2</span>; &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> n - (i &gt;&gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>方法三（不推薦）：將原數以 2 爲底取對數，然後再取其 ceil 值，將其作爲 2 的指數計算即可。</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> n = (<span class=\"keyword\">int</span>) Math.pow(<span class=\"number\">2</span>, (<span class=\"keyword\">int</span>) Math.ceil(Math.log(cap) / Math.log(<span class=\"number\">2</span>)));</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"遍歷-HashMap-的幾種方式\"><a href=\"#遍歷-HashMap-的幾種方式\" class=\"headerlink\" title=\"遍歷 HashMap 的幾種方式\"></a>遍歷 HashMap 的幾種方式</h3><p>HashMap 有四大類遍歷方式：iterator、for、lambda 和 stream。性能上 stream 的並行循環最高，其他的差別不大。安全性上在遍歷時應使用 <code>iterator.remove</code>方法刪除元素或者用 stream 的 <code>filter</code> 過濾不需要的數據再進行循環。參見 <a href=\"https://mp.weixin.qq.com/s/Zz6mofCtmYpABDL1ap04ow\" target=\"_blank\" rel=\"noopener\">https://mp.weixin.qq.com/s/Zz6mofCtmYpABDL1ap04ow</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Map&lt;String, String&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">map.put(<span class=\"string\">\"lang\"</span>, <span class=\"string\">\"java\"</span>);</span><br><span class=\"line\">map.put(<span class=\"string\">\"sys\"</span>, <span class=\"string\">\"linux\"</span>);</span><br><span class=\"line\"><span class=\"comment\">// iterator</span></span><br><span class=\"line\">Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span> (iterator.hasNext()) &#123;</span><br><span class=\"line\">  Map.Entry&lt;String, String&gt; entry = iterator.next();</span><br><span class=\"line\">  System.out.println(entry.getKey() + <span class=\"string\">\":\"</span> + entry.getValue());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// for，增強 for 循環，使用了迭代器</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class=\"line\">  System.out.println(entry.getKey() + <span class=\"string\">\":\"</span> + entry.getValue());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// lambda</span></span><br><span class=\"line\">map.forEach((key, value) -&gt; &#123;</span><br><span class=\"line\">  System.out.println(key + <span class=\"string\">\":\"</span> + value);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// stream</span></span><br><span class=\"line\">map.entrySet().parallelStream().forEach((entry) -&gt; &#123;</span><br><span class=\"line\">  System.out.println(entry.getKey() + <span class=\"string\">\":\"</span> + entry.getValue());</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"ConcurrentHashMap-線程安全的原因\"><a href=\"#ConcurrentHashMap-線程安全的原因\" class=\"headerlink\" title=\"ConcurrentHashMap 線程安全的原因\"></a>ConcurrentHashMap 線程安全的原因</h3><p>我們知道 HashMap 是線程不安全的，在多線程環境下需要用 ConcurrentHashMap 代替。那麼，ConcurrentHashMap 是怎麼實現線程安全的呢？</p>\n<p>JDK 1.7 時，採用<strong>分段鎖</strong>，主幹是一個 Segment 數組，Segment 裏維護著一個 HashEntry 數組。對同一 Segment 的數據進行操作需要考慮鎖競爭，不同的則不需要。</p>\n<p><img src=\"/2020/12/02/it/java/java-collection/Untitled%205.png\" alt></p>\n<p>JDK 1.8 開始取消了分段鎖，採用 <strong>CAS（樂觀鎖） 和 synchronized（悲觀鎖）</strong> 來保證並發安全。synchronized 只鎖定當前鏈表或紅黑二叉樹的首節點，這樣只要 hash 不衝突，就不會產生並發。</p>\n<p><img src=\"/2020/12/02/it/java/java-collection/Untitled%206.png\" alt></p>\n","site":{"data":{}},"excerpt":"<p>Java 集合分 List、Set、Map 三大類，其中 List 和 Set 實現了 Collection 接口。List 的特點是數據有序、可重複；Set 的特點是數據無序、不可重複；Map 存儲鍵值映射，Key 不可重複，Value 可重複，且一個 Key 只能對應一個 Value。</p>\n<p>List 有一實現 <code>ArrayList</code>，其底層實現是對象數組，默認容量是 10，但等到首次添加元素時才分配內存，每次遞增爲上次容量的 1.5 倍。在添加大量元素之前，建議調用 <code>ensureCapacity</code> 方法擴容，以減少遞增式再分配內存的次數。</p>\n<p>Set 有一實現 <code>HashSet</code>，其底層實現是 <code>HashMap</code> ，其檢查重複的機制有賴於 <code>hashCode</code> 和 <code>equals</code> 方法。</p>\n<p>Map 有一實現 <code>HashMap</code> ，JDK 1.8 之後其底層實現是：<strong>數組 + 鏈表 + 紅黑二叉樹</strong>。紅黑樹是爲了減少搜索時間，默認當鏈表長度大於 8 且當前數組長度大於等於 64 時，鏈表會轉爲紅黑樹。數組默認容量是 16，通過帶參構造方法傳入的容量值如非 2 的幂次會自動向上轉爲 2 的幂次，以便元素散列存儲（元素位置才可通過 <code>hash &amp; (length-1)</code> 確定）。添加元素時，若元素數量大於數組長度的 75% 且該元素存在哈希衝突，則觸發擴容機制，數組容量翻倍。</p>\n<p>總結下 HashMap 中解決哈希衝突的方式：</p>\n<ol>\n<li>使用鏈表 — 拉鍊法；</li>\n<li>使用紅黑二叉樹；</li>\n<li>擴容底層數組；</li>\n<li>強制數組容量爲 2 之幂次；</li>\n<li>將元素的 hash 值的高位分散到低位等等。</li>\n</ol>\n<p><code>ArrayList</code>、<code>HashSet</code>、<code>HashMap</code> 都是線程不安全的。在多線程環境下應使用 J.U.C 包下的對應的並發類 <code>CopyOnWriteArrayList</code> 、<code>ConcurrentHashMap</code> （<code>HashSet</code> 用<code>ConcurrentHashMap</code> 的 keySet 可得 Set 視圖）。<code>CopyOnWriteArrayList</code> 會在寫時加鎖並複製集合進行操作；<code>ConcurrentHashMap</code> 在 JDK 1.7 使用分段鎖，在 JDK 1.8 取消分段鎖採用 CAS（樂觀鎖） 和 synchronized（悲觀鎖） 只對鏈表或紅黑二叉樹的節點加鎖。</p>","more":"<h2 id=\"概覽\"><a href=\"#概覽\" class=\"headerlink\" title=\"概覽\"></a>概覽</h2><p>集合是相對數組來說，更靈活多樣的容器。Java 的集合框架肇始於兩大接口，Collection 和 Map。Collection 下有 List、Queue 和 Set 等等接口，然後衍生出 ArrayList、LinkedList、HashSet、TreeSet、LinkedHashSet 等等實現；Map 下有 HashMap、TreeMap 等重要子類。</p>\n<p><img src=\"/2020/12/02/it/java/java-collection/Untitled.png\" alt></p>\n<h3 id=\"List、Set、Map-三者之區別\"><a href=\"#List、Set、Map-三者之區別\" class=\"headerlink\" title=\"List、Set、Map 三者之區別\"></a>List、Set、Map 三者之區別</h3><ol>\n<li>List：存儲的元素有序、可重複。</li>\n<li>Set：存儲的元素無序、不可重複。</li>\n<li>Map：使用鍵值對存儲，一鍵一值，Key 無序、不可重複；Value 無序、可重複。</li>\n</ol>\n<h3 id=\"List、Set、Map-三者之底層數據結構\"><a href=\"#List、Set、Map-三者之底層數據結構\" class=\"headerlink\" title=\"List、Set、Map 三者之底層數據結構\"></a>List、Set、Map 三者之底層數據結構</h3><ol>\n<li>List<ul>\n<li>ArrayList：Object 數組</li>\n<li>Vector：Object 數組</li>\n<li>LinkedList：雙向鏈表（JDK 1.6 之前爲循環鏈表）</li>\n</ul>\n</li>\n<li>Set<ul>\n<li>HashSet（無序、唯一）：基於 HashMap</li>\n<li>LinkedHashSet：基於 LinkedHashMap</li>\n<li>TreeSet（有序、唯一）：紅黑樹（自平衡的排序二叉樹）</li>\n</ul>\n</li>\n<li>Map<ul>\n<li>HashMap：數組 + 鏈表 + 紅黑樹（鏈表長於閾值即轉爲紅黑樹以減少搜索時間；閾值默認爲 8；JDK 1.8 之前沒有紅黑樹）</li>\n<li>LinkedHashMap：繼承自 HashMap，但多了一條雙向鏈表</li>\n<li>Hashtable：數組 + 鏈表</li>\n<li>TreeMap：紅黑樹（自平衡的排序二叉樹）</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"Iterator-迭代器\"><a href=\"#Iterator-迭代器\" class=\"headerlink\" title=\"Iterator 迭代器\"></a>Iterator 迭代器</h3><p>迭代器就是 Iterator 接口，它抽象出迭代一個集合需要的方法，<code>hasNext()</code> 和 <code>next()</code> 方法，以便集合類實現該接口，從而方便對集合的遍歷。有了迭代器就可以在迭代集合元素時更改元素而不拋出 <code>ConcurrentModificationException</code> 了。</p>\n<p>爲什麼？因爲非採用 Iterator 進行遍歷時更改元素會修改到 <code>modCount</code> 變量（用於紀錄集合結構性改變的次數）的值，而沒有修改 <code>expectedModCount</code> 的值，基於 fail-fast 機制檢查兩值是否相同時會拋出異常；而使用 Iterator 遍歷時更改元素會同時修改 <code>modCount</code> 和 <code>expectedModCount</code>，兩者相等，不會拋出異常。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Map&lt;Integer, String&gt; map = <span class=\"keyword\">new</span> HashMap();</span><br><span class=\"line\">map.put(<span class=\"number\">1</span>, <span class=\"string\">\"Java\"</span>);</span><br><span class=\"line\">map.put(<span class=\"number\">2</span>, <span class=\"string\">\"Python\"</span>);</span><br><span class=\"line\">map.put(<span class=\"number\">2</span>, <span class=\"string\">\"Go\"</span>);</span><br><span class=\"line\">Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span> (iterator.hasNext()) &#123;</span><br><span class=\"line\">  Map.Entry&lt;Integer, String&gt; entry = iterator.next();</span><br><span class=\"line\">  System.out.println(entry.getKey() + entry.getValue());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"有哪些集合是線程不安全的？怎麼解決？\"><a href=\"#有哪些集合是線程不安全的？怎麼解決？\" class=\"headerlink\" title=\"有哪些集合是線程不安全的？怎麼解決？\"></a>有哪些集合是線程不安全的？怎麼解決？</h3><p>常用的 <code>ArrayList</code>、<code>LinkedList</code>、<code>HashMap</code>、<code>HashSet</code>、<code>TreeSet</code>、<code>TreeMap</code>、<code>PriorityQueue</code> 都不是線程安全的。解決方法就是用 <code>java.util.concurrent</code> 包提供的線程安全的集合來代替：</p>\n<ol>\n<li><code>ConcurrentHashMap</code> 代替 <code>HashMap</code>；</li>\n<li><code>CopyOnWriteArrayList</code> 代替 <code>ArrayList</code>；</li>\n<li><code>ConcurrentLinkedQueue</code> 代替 <code>LinkedList</code> ；</li>\n<li><code>BlockingQueue</code> 接口下的 <code>PriorityBlockingQueue</code>、<code>LinkedBlockingQueue</code> 等阻塞隊列代替 <code>PriorityQueue</code>  等；</li>\n<li><code>ConcurrentSkipListMap</code>  代替 <code>TreeMap</code> ，實現多線程下保證按 Key 的順序存儲元素。</li>\n</ol>\n<h3 id=\"length、length-、size-三者用途\"><a href=\"#length、length-、size-三者用途\" class=\"headerlink\" title=\"length、length()、size() 三者用途\"></a><code>length</code>、<code>length()</code>、<code>size()</code> 三者用途</h3><ol>\n<li><code>length</code>：用於數組。</li>\n<li><code>length()</code>：用於字符串。</li>\n<li><code>size()</code>：用於集合。</li>\n</ol>\n<h3 id=\"Collections-工具類的使用\"><a href=\"#Collections-工具類的使用\" class=\"headerlink\" title=\"Collections 工具類的使用\"></a>Collections 工具類的使用</h3><ul>\n<li><p>排序</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//反轉</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">reverse</span><span class=\"params\">(List list)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//隨機排序</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">shuffle</span><span class=\"params\">(List list)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//按自然排序的升序排序</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(List list)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//定制排序，由Comparator控制排序邏輯</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(List list, Comparator c)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//交換兩個索引位置的元素</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(List list, <span class=\"keyword\">int</span> i , <span class=\"keyword\">int</span> j)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//旋轉。當distance為正數時，將list後distance個元素整體移到前面。當distance為負數時，將 list的前distance個元素整體移到後面</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">rotate</span><span class=\"params\">(List list, <span class=\"keyword\">int</span> distance)</span></span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>查找替換統計</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//對List進行二分查找，返回索引，注意List必須是有序的</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">binarySearch</span><span class=\"params\">(List list, Object key)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//根據元素的自然順序，返回最大的元素。 類比int min(Collection coll)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">max</span><span class=\"params\">(Collection coll)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//根據定制排序，返回最大元素，排序規則由Comparatator類控制。類比int min(Collection coll, Comparator c)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">max</span><span class=\"params\">(Collection coll, Comparator c)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//用指定的元素代替指定list中的所有元素</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fill</span><span class=\"params\">(List list, Object obj)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//用新元素替換舊元素</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">replaceAll</span><span class=\"params\">(List list, Object oldVal, Object newVal)</span> </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//統計元素出現次數</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">frequency</span><span class=\"params\">(Collection c, Object o)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//統計target在list中第一次出現的索引，找不到則返回-1，類比int lastIndexOfSubList(List source, list target)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">indexOfSubList</span><span class=\"params\">(List list, List target)</span></span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h2 id=\"List\"><a href=\"#List\" class=\"headerlink\" title=\"List\"></a>List</h2><h3 id=\"比較-ArrayList-與-LinkedList\"><a href=\"#比較-ArrayList-與-LinkedList\" class=\"headerlink\" title=\"比較 ArrayList 與 LinkedList\"></a>比較 ArrayList 與 LinkedList</h3><p>共同點：</p>\n<ol>\n<li>都實現了 List 接口；</li>\n<li>都是不同步的，不保證線程安全。</li>\n</ol>\n<p>不同點：</p>\n<ol>\n<li><strong>底層數據結構不同</strong>。ArrayList 是對象數組；LinkedList 是雙向鏈表（JDK 1.6 之前爲循環列表）。</li>\n<li><strong>插入和刪除的時間複雜度不同</strong>。ArrayList 追加元素的複雜度爲 O(1)，指定位置 i 插入或刪除元素的複雜度爲 O(n-i)；LinkedList 追加元素和刪除末端元素的時間複雜度爲 O(1)，指定位置 i 插入或刪除元素的時間複雜度近似 O(n)。</li>\n<li><strong>對快速隨機訪問的支持不同</strong>。ArrayList 支持快速隨機訪問；LinkedList 不支持。</li>\n<li><strong>對空間的利用不同</strong>。ArrayList 末尾會預留一定的空間以便元素新增；LinkedList 則是會在每個元素多存儲了指針數據。</li>\n</ol>\n<ul>\n<li><p>比較雙向鏈表與雙向循環鏈表</p>\n<p>  <img src=\"/2020/12/02/it/java/java-collection/Untitled%201.png\" alt></p>\n<p>  <img src=\"/2020/12/02/it/java/java-collection/Untitled%202.png\" alt></p>\n</li>\n</ul>\n<h3 id=\"ArrayList-擴容機制\"><a href=\"#ArrayList-擴容機制\" class=\"headerlink\" title=\"ArrayList 擴容機制\"></a>ArrayList 擴容機制</h3><p>ArrayList 底層是對象數組，其容量可以動態增長。在添加大量元素之前，建議調用 <code>ensureCapacity</code> 方法擴容，以減少遞增式再分配內存的次數，提升程序效率。</p>\n<p>其擴容機制大致是這樣的：ArrayList 提供了默認構造方法，通過默認構造方法構造對象，默認容量值爲 10 ，但此時未分配相應內存空間，而是<strong>等到首次添加元素時才開始初始化</strong>一個空間爲 10 的對象數組。當第 11 個元素加入時會觸發擴容機制，<strong>容量會擴充到原來的 1.5 倍</strong>（<code>newCapacity = oldCapacity + oldCapacity &gt;&gt; 2</code>），即變爲 15。如通過指定相應的容量大小的構造方法構造對象且指定的容量值大於 0 ，則一開始就會分配相應的內存空間。</p>\n<h3 id=\"快速隨機訪問-RandomAccess\"><a href=\"#快速隨機訪問-RandomAccess\" class=\"headerlink\" title=\"快速隨機訪問 RandomAccess\"></a>快速隨機訪問 RandomAccess</h3><p>RandomAccess 接口爲空實現，僅僅標識著實現類具備快速隨機訪問的能力。ArrayList 實現了該接口，而 LinkedList 未實現。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">RandomAccess</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"System-arraycopy-與-Arrays-copyOf-方法\"><a href=\"#System-arraycopy-與-Arrays-copyOf-方法\" class=\"headerlink\" title=\"System.arraycopy() 與 Arrays.copyOf() 方法\"></a><code>System.arraycopy()</code> 與 <code>Arrays.copyOf()</code> 方法</h3><ol>\n<li><code>System.arraycopy()</code> 方法用於源數組到目標數組之間的數據拷貝；</li>\n<li><code>Arrays.copyOf()</code> 方法用於給源數組擴容，底層調用<code>System.arraycopy()</code> 。</li>\n</ol>\n<h3 id=\"CopyOnWriteArrayList-的特點\"><a href=\"#CopyOnWriteArrayList-的特點\" class=\"headerlink\" title=\"CopyOnWriteArrayList 的特點\"></a>CopyOnWriteArrayList 的特點</h3><ol>\n<li>寫時會加鎖並複製整個集合；</li>\n<li>讀時可能讀到舊數據。</li>\n</ol>\n<h3 id=\"如何移除列表中的元素\"><a href=\"#如何移除列表中的元素\" class=\"headerlink\" title=\"如何移除列表中的元素\"></a><strong>如何移除列表中的元素</strong></h3><p>首先，不能在 foreach 循環中移除元素，根據 fail-fast（快速失敗） 機制，會拋出 <code>ConcurrentModificationException</code> （並發修改異常）。</p>\n<p>可以採用 <code>iterator</code> 或者 <code>Collection.removeIf()</code> 方法移除列表元素。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">String[] arrs = &#123;<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>&#125;;</span><br><span class=\"line\">List&lt;String&gt; list = Arrays.stream(arrs).collect(Collectors.toList());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 採用 iterator</span></span><br><span class=\"line\">Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span> (iterator.hasNext()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"string\">\"a\"</span>.equals(iterator.next())) &#123;</span><br><span class=\"line\">        iterator.remove();</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 採用 removeIf 方法，\"a\"::equals 等價於 x -&gt; \"a\".equals(x)</span></span><br><span class=\"line\">list.removeIf(<span class=\"string\">\"a\"</span>::equals); </span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(list);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"正確使用-Arrays-asList\"><a href=\"#正確使用-Arrays-asList\" class=\"headerlink\" title=\"正確使用 Arrays.asList\"></a><strong>正確使用 Arrays.asList</strong></h3><p>如果非要在 <code>foreach</code> 循環中刪除元素，還可以使用 <code>CopyOnWriteArrayList</code>，此集合是 <code>fail-safe</code> 的。<code>CopyOnWriteArrayList</code> 修改元素時會 copy 一個新列表進行修改，不會改變迭代中的列表，因此是安全的，但會產生新的列表作爲代價。</p>\n<p>Arrays 工具類有一個靜態方法 <code>asList(T... a)</code>，能將<strong>對象</strong>數組包裝成一個 List，底層數據依然是原數組，原數組改變，List 也隨之改變，但 List 本身的 <code>add</code>/<code>remove</code>/<code>clear</code> 並不可用，調用會拋出 <code>UnsupportedOperationException</code>。</p>\n<p>Arrays 類中關於 <code>asList</code> 方法的代碼如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">List&lt;T&gt; <span class=\"title\">asList</span><span class=\"params\">(T... a)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 這裏的 ArrayList 是 Arrays 類中定義的私有靜態類，不是 java.util.ArrayList</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ArrayList&lt;&gt;(a);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>爲什麼 <code>asList</code> 方法傳入的必須是對象數組呢？</p>\n<p>你看上面的代碼，泛型，沒錯泛型只能是對象啊，基本類型是不行的。</p>\n<p>傳入基本類型的數組會怎樣呢？請看下面代碼：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span>[] ints = &#123;<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 此時的泛型是 int[] 對象，而非 int</span></span><br><span class=\"line\">List&lt;<span class=\"keyword\">int</span>[]&gt; list = Arrays.asList(ints);</span><br><span class=\"line\"><span class=\"comment\">// list 的大小爲 1，就是 ints 這個數組對象</span></span><br><span class=\"line\">System.out.println(list.size());</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"把數組轉爲-java-util-ArrayList\"><a href=\"#把數組轉爲-java-util-ArrayList\" class=\"headerlink\" title=\"把數組轉爲 java.util.ArrayList\"></a><strong>把數組轉爲 <code>java.util.ArrayList</code></strong></h3><p>那麼，如何簡便地把一個數組轉爲普遍意義上的 ArrayList 呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1) 使用 ArrayList 的帶參構造方法</span></span><br><span class=\"line\">List&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(Arrays.asList(arrs));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2) 使用 Java 8 的 Stream API</span></span><br><span class=\"line\">List&lt;String&gt; list = Arrays.stream(arrs).collect(Collectors.toList());</span><br><span class=\"line\"><span class=\"comment\">// boxed 方法可以把基本類型轉成包裝類型</span></span><br><span class=\"line\">List&lt;Integer&gt; intList = Arrays.stream(ints).boxed().collect(Collectors.toList());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3) 使用 Guava 包的 API</span></span><br><span class=\"line\">ImmutableList&lt;String[]&gt; list = ImmutableList.of(arrs);</span><br><span class=\"line\">ImmutableList&lt;String&gt; list1 = ImmutableList.copyOf(arrs);</span><br><span class=\"line\">ArrayList&lt;String&gt; list2 = Lists.newArrayList(arrs);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 4) 使用 Java 9 的 API</span></span><br><span class=\"line\">List&lt;String&gt; list = List.of(arrs);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"將-List-轉爲數組\"><a href=\"#將-List-轉爲數組\" class=\"headerlink\" title=\"將 List 轉爲數組\"></a><strong>將 List 轉爲數組</strong></h3><p>使用 List 的 <code>toArray</code> 方法可以將 List 轉爲數組，代碼如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// new String[0] 僅僅爲了告知類型返回數組的類型</span></span><br><span class=\"line\">String[] strings = list.toArray(<span class=\"keyword\">new</span> String[<span class=\"number\">0</span>]);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h2><h3 id=\"無序性和不可重複性的含義\"><a href=\"#無序性和不可重複性的含義\" class=\"headerlink\" title=\"無序性和不可重複性的含義\"></a>無序性和不可重複性的含義</h3><p>無序性並不等同於隨機性，而是根據數據的哈希值決定其存儲位置，使用者無法指定其存儲順序。</p>\n<p>不可重複性是指添加的元素按 equals 方法判斷結果爲 false。</p>\n<h3 id=\"比較-HashSet、LinkedHashSet-和-TreeSet\"><a href=\"#比較-HashSet、LinkedHashSet-和-TreeSet\" class=\"headerlink\" title=\"比較 HashSet、LinkedHashSet 和 TreeSet\"></a>比較 HashSet、LinkedHashSet 和 TreeSet</h3><p>共同點：</p>\n<ol>\n<li>都實現了 Set 接口；</li>\n<li>元素不可重複；</li>\n<li>都是線程不安全的。</li>\n</ol>\n<p>不同點：</p>\n<ol>\n<li><strong>底層數據接口不同</strong>。HashSet 底層是 HashMap；LinkedHashSet 底層是 LinkedHashMap；TreeSet 底層是紅黑樹。</li>\n<li><strong>有序性不同</strong>。HashSet 無序；LinkedHashSet 和 TreeSet 有序。TreeSet 還可以自定義排序。</li>\n</ol>\n<h3 id=\"自定義排序的實現\"><a href=\"#自定義排序的實現\" class=\"headerlink\" title=\"自定義排序的實現\"></a>自定義排序的實現</h3><p>自定義排序最通用的就是給要排序的類實現一個 Comparable 接口，隨後可以使用 Collection.sort 方法進行排序。又或者不實現 Comparable 接口，而是傳入 Comparator 到 Collection.sort 方法中。</p>\n<h3 id=\"HashSet-如何檢查重複\"><a href=\"#HashSet-如何檢查重複\" class=\"headerlink\" title=\"HashSet 如何檢查重複\"></a>HashSet 如何檢查重複</h3><p>HashSet 集合進行元素重複校驗時先比較 hashcode ，當 hashcode 一樣時再調用 equals，提高了校驗效率。因此，如果只重寫 equals 方法而不重寫 hashcode 方法，會出現 equals 返回 true，而 hashcode 不等的情況，這樣如果要求 HashSet 去重就會失敗。</p>\n<h2 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h2><h3 id=\"比較-HashMap-與-TreeMap\"><a href=\"#比較-HashMap-與-TreeMap\" class=\"headerlink\" title=\"比較 HashMap 與 TreeMap\"></a>比較 HashMap 與 TreeMap</h3><p>共同點：</p>\n<ol>\n<li>都繼承自 AbstractMap，間接實現了 Map 接口；</li>\n<li>都是線程不安全的。</li>\n</ol>\n<p>不同點：</p>\n<ol>\n<li><strong>底層數據結構不同</strong>。HashMap 底層是數組 + 鏈表 + 紅黑樹（鏈表長於閾值即轉爲紅黑樹以減少搜索時間；閾值默認爲 8；JDK 1.8 之前沒有紅黑樹）；TreeMap 底層是紅黑樹。</li>\n<li><strong>HashMap 無搜索和排序的能力</strong>。TreeMap 實現了 NavigableMap 接口，使其有對集合內元素搜索的能力；實現了 SortMap 接口，使其有對集合內元素根據鍵排序的能力。</li>\n</ol>\n<h3 id=\"HashMap-底層實現\"><a href=\"#HashMap-底層實現\" class=\"headerlink\" title=\"HashMap 底層實現\"></a>HashMap 底層實現</h3><p>JDK 1.7 或之前，HashMap 的底層實現是數組+鏈表。該數組的定義如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">transient</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure>\n\n<p>Node 存儲了鍵、值、哈希值和下一個節點，是一個鏈表，也就是說 Node 數組就是一個鏈表數組。</p>\n<p><img src=\"/2020/12/02/it/java/java-collection/Untitled%203.png\" alt></p>\n<p>該數組默認大小是 <code>1 &lt;&lt; 4 = 16</code> 。調用 put 方法增加元素時，通過散列算法（hash方法，也稱之爲擾動函數）算得元素的 hash 值，然後計算其應插入的桶（數組中的一個位置）。如果該位置已有元素，就會產生哈希衝突（或稱碰撞），此時通過<strong>拉鍊法</strong>解決。當 Map 中包含的元素數量大於等於 <code>threshold = loadFactor * capacity</code> （loadFactor 默認爲 0.75f），且新建的元素剛好落在一個非空的桶上時，會觸發擴容機制，將數組容量擴大 2 倍。</p>\n<p>JDK 1.8 開始，HashMap 的底層實現是數組+鏈表+紅黑樹，<strong>當鏈表長度大於閾值（默認爲 8），且當前數組長度大於等於 64 時，該鏈表會轉爲紅黑樹，以減少搜索時間。</strong></p>\n<p><img src=\"/2020/12/02/it/java/java-collection/Untitled%204.png\" alt></p>\n<p><strong>（1）散列算法</strong></p>\n<p>首先獲取 key 的 hash 值，然後將高位的 hash 分散到低位，以便減少哈希衝突。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// JDK 1.7</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(<span class=\"keyword\">int</span> h)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// This function ensures that hashCodes that differ only by</span></span><br><span class=\"line\">  <span class=\"comment\">// constant multiples at each bit position have a bounded</span></span><br><span class=\"line\">  <span class=\"comment\">// number of collisions (approximately 8 at default load factor).</span></span><br><span class=\"line\">  h ^= (h &gt;&gt;&gt; <span class=\"number\">20</span>) ^ (h &gt;&gt;&gt; <span class=\"number\">12</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> h ^ (h &gt;&gt;&gt; <span class=\"number\">7</span>) ^ (h &gt;&gt;&gt; <span class=\"number\">4</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// JDK 1.8</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> h;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (key == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class=\"number\">16</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>（2）插入算法</strong></p>\n<p>如何根據散列值確定要插入的數組位置呢？因爲保證了數組長度爲 2 之幂次，所以確定插入位置時的取餘算法 <code>hash % length</code> 等價於 <code>h &amp; (length-1)</code>。簡單起見，假定 hash 爲 0100 1010； length 是 8，其二進制爲 0000 1000，取餘爲 <code>hash % length</code> = 0000 0010 = <code>h &amp; (length-1)</code>。此處 hash 值的高位 0100 並沒有用到，會造成高位不同而低位相同的 hash 值衝突，這也是散列算法要將高位分散到低位的緣故。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* Returns index for hash code h.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">indexFor</span><span class=\"params\">(<span class=\"keyword\">int</span> h, <span class=\"keyword\">int</span> length)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> h &amp; (length-<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>（3）拉鍊法</strong></p>\n<p>將衝突的值加到鏈表中。</p>\n<p><strong>（4）保證數組長度爲 2 之幂次的方法</strong></p>\n<ul>\n<li><p>方法一（JDK 1.8 或以前）：將原數二進制表示的第一個非零位後面的所有零位填滿爲 1，然後再加 1。</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">tableSizeFor</span><span class=\"params\">(<span class=\"keyword\">int</span> cap)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = cap - <span class=\"number\">1</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">2</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">4</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">8</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">16</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (n &lt; <span class=\"number\">0</span>) ? <span class=\"number\">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>方法二（JDK 15）：計算原數二進制表示的第一個非零位前面零的數量 k，然後將 -1 (其二進制形式全是1)無符號右移 k 位再加 1。</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// HashMap.java</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">tableSizeFor</span><span class=\"params\">(<span class=\"keyword\">int</span> cap)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> n = -<span class=\"number\">1</span> &gt;&gt;&gt; Integer.numberOfLeadingZeros(cap - <span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (n &lt; <span class=\"number\">0</span>) ? <span class=\"number\">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Integer.java</span></span><br><span class=\"line\"><span class=\"comment\">// 取得整數二進制表示前面的零位數量</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">numberOfLeadingZeros</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// HD, Count leading 0's</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (i &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> i == <span class=\"number\">0</span> ? <span class=\"number\">32</span> : <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> n = <span class=\"number\">31</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (i &gt;= <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">16</span>) &#123; n -= <span class=\"number\">16</span>; i &gt;&gt;&gt;= <span class=\"number\">16</span>; &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (i &gt;= <span class=\"number\">1</span> &lt;&lt;  <span class=\"number\">8</span>) &#123; n -=  <span class=\"number\">8</span>; i &gt;&gt;&gt;=  <span class=\"number\">8</span>; &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (i &gt;= <span class=\"number\">1</span> &lt;&lt;  <span class=\"number\">4</span>) &#123; n -=  <span class=\"number\">4</span>; i &gt;&gt;&gt;=  <span class=\"number\">4</span>; &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (i &gt;= <span class=\"number\">1</span> &lt;&lt;  <span class=\"number\">2</span>) &#123; n -=  <span class=\"number\">2</span>; i &gt;&gt;&gt;=  <span class=\"number\">2</span>; &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> n - (i &gt;&gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>方法三（不推薦）：將原數以 2 爲底取對數，然後再取其 ceil 值，將其作爲 2 的指數計算即可。</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> n = (<span class=\"keyword\">int</span>) Math.pow(<span class=\"number\">2</span>, (<span class=\"keyword\">int</span>) Math.ceil(Math.log(cap) / Math.log(<span class=\"number\">2</span>)));</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"遍歷-HashMap-的幾種方式\"><a href=\"#遍歷-HashMap-的幾種方式\" class=\"headerlink\" title=\"遍歷 HashMap 的幾種方式\"></a>遍歷 HashMap 的幾種方式</h3><p>HashMap 有四大類遍歷方式：iterator、for、lambda 和 stream。性能上 stream 的並行循環最高，其他的差別不大。安全性上在遍歷時應使用 <code>iterator.remove</code>方法刪除元素或者用 stream 的 <code>filter</code> 過濾不需要的數據再進行循環。參見 <a href=\"https://mp.weixin.qq.com/s/Zz6mofCtmYpABDL1ap04ow\" target=\"_blank\" rel=\"noopener\">https://mp.weixin.qq.com/s/Zz6mofCtmYpABDL1ap04ow</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Map&lt;String, String&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">map.put(<span class=\"string\">\"lang\"</span>, <span class=\"string\">\"java\"</span>);</span><br><span class=\"line\">map.put(<span class=\"string\">\"sys\"</span>, <span class=\"string\">\"linux\"</span>);</span><br><span class=\"line\"><span class=\"comment\">// iterator</span></span><br><span class=\"line\">Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span> (iterator.hasNext()) &#123;</span><br><span class=\"line\">  Map.Entry&lt;String, String&gt; entry = iterator.next();</span><br><span class=\"line\">  System.out.println(entry.getKey() + <span class=\"string\">\":\"</span> + entry.getValue());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// for，增強 for 循環，使用了迭代器</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class=\"line\">  System.out.println(entry.getKey() + <span class=\"string\">\":\"</span> + entry.getValue());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// lambda</span></span><br><span class=\"line\">map.forEach((key, value) -&gt; &#123;</span><br><span class=\"line\">  System.out.println(key + <span class=\"string\">\":\"</span> + value);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// stream</span></span><br><span class=\"line\">map.entrySet().parallelStream().forEach((entry) -&gt; &#123;</span><br><span class=\"line\">  System.out.println(entry.getKey() + <span class=\"string\">\":\"</span> + entry.getValue());</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"ConcurrentHashMap-線程安全的原因\"><a href=\"#ConcurrentHashMap-線程安全的原因\" class=\"headerlink\" title=\"ConcurrentHashMap 線程安全的原因\"></a>ConcurrentHashMap 線程安全的原因</h3><p>我們知道 HashMap 是線程不安全的，在多線程環境下需要用 ConcurrentHashMap 代替。那麼，ConcurrentHashMap 是怎麼實現線程安全的呢？</p>\n<p>JDK 1.7 時，採用<strong>分段鎖</strong>，主幹是一個 Segment 數組，Segment 裏維護著一個 HashEntry 數組。對同一 Segment 的數據進行操作需要考慮鎖競爭，不同的則不需要。</p>\n<p><img src=\"/2020/12/02/it/java/java-collection/Untitled%205.png\" alt></p>\n<p>JDK 1.8 開始取消了分段鎖，採用 <strong>CAS（樂觀鎖） 和 synchronized（悲觀鎖）</strong> 來保證並發安全。synchronized 只鎖定當前鏈表或紅黑二叉樹的首節點，這樣只要 hash 不衝突，就不會產生並發。</p>\n<p><img src=\"/2020/12/02/it/java/java-collection/Untitled%206.png\" alt></p>"},{"title":"工作邮件中的中文敬语","p":"language/han/writing/chinese-honorific-for-work-mail","_content":"\n《论语·学而》讲到「有子曰：礼之用，和为贵。」，大意是说礼的运用贵在使人际关系和谐。如今我提倡善用敬语，其原因就在于此。我希望能通过敬语的推广减少如今社会的戾气，营造相互尊重相互关怀的社会风气。\n\n<!--more-->\n\n## 东西方邮件比照\n\n在开始讲述我们的主题之前，先来看看我从网络上寻到的几份邮件/信件。\n\n第一份是日文的，是一份公司内部部门名称变更的通知，[原文](https://business-mail.jp/example/753)如下：\n\n```\n営業部の皆様、お疲れ様です。\n総務部の◎◎太郎です。\n\n2011年6月1日（水）より、社内組織の名称を変更いたします。\n\n■変更前：顧客管理部\n\n■変更後：お客様相談センター\n\n■変更実施日：2011年6月1日（水）9:00より\n\nHP、会社案内、配布資料などについては、\n5月30日（月）までに新しいものを各部署に配布いたします。\n古い案内や資料は破棄しますので、各部署でまとめて、\n管理部までお持ちください。\n\n以上、よろしくお願いいたします。\n```\n\n拙译如下：\n\n```\n各位营业部同仁，辛苦您们了。\n我是总务部的◎◎太郎。\n\n2011 年 6 月 1 日（星期三）起，公司内部组织名称有所变更。\n\n变更前：顾客管理部\n变更后：客户咨询中心\n变更实施日：2011 年 6 月 1 日（星期三）9:00 起\n\n至于公司主页、介绍册和散发的资料等，5 月 30 日（星期一）前会发送新的到各职守。\n旧的介绍册及资料要废弃了，请各职守汇总到管理部。\n\n谨此，顺颂商祺。\n```\n\n第二份是英文的，是公司对外婉言谢绝合作的复信，[原文](http://www.blairenglish.com/exercises/emails/exercises/business-email-examples/business-email-examples.html)如下：\n```\nDear Mr Boxall,\n\nThank you for your enquiry about supplying our company with new photocopying equipment.\n\nUnfortunately, we are currently not in need of replacing our existing photocopiers. We recently entered a new 2 year contract with our existing photocopier provider.\n\nYou would be more than welcome to contact us again when our current contract is up for renewal.\n\nYours sincerely,\n\n\nJeff Thompson\nOffice Manager\n```\n\n草译如下：\n\n```\n尊敬的 Boxal 先生：\n\n感谢您上次有关本公司新复印机采购的垂询。\n不巧的是，我们当前没有替换现有复印机的需求。不过不久我们将与现有供应商签订新的为期两年的合同。\n非常欢迎您在我们当前合同续订时再次来询。\n\n敬复。\n\n\n杰夫·汤普森\n办公室主管\n```\n\n第三份是中文繁体的，是一份银行追讨用户欠款的通知，[原文](http://www.cuhk.edu.hk/ics/clrc/crcl_74/wong.pdf)如下（格式上依电子邮件特点略有改动）。\n\n```\nX 先生：\n\n根據本行記錄，貴戶 X 月份信用咭賬項，至 X 月 X 日為止，尚未清繳信用咭使用條款規定的最低還款款額港幣 XXXX 元正。閣下如因私務繁忙，未有按時繳款，敬希於此信發出日期起 X 天內清繳上述欠款，以免妨礙本行繼續為閣下提供信用咭服務。\n如有任何查詢，請致電 XXXXXXXX 與本行職員聯絡。閣下如已清繳上述欠款，請毋須理會此信。\n\nXX 銀行謹啟。\nXXXX 年 X 月 X 日\n```\n\n按大陆习惯转成简体字如下：\n\n```\nX 先生：\n\n根据本行记录，贵户 X 月份信用卡账项，至 X 月 X 日为止，尚未清缴信用卡使用条款规定的最低还款款额港币 XXXX 元整。阁下如因私务繁忙，未有按时缴款，敬希于此信发出日期起 X 天内清缴上述欠款，以免妨碍本行继续为阁下提供信用卡服务。\n如有任何查询，请致电 XXXXXXXX 与本行职员联络。阁下如已清缴上述欠款，请毋须理会此信。\n\nXX 银行谨启。\nXXXX 年 X 月 X 日\n```\n\n最后一份是东晋书法家王羲之写给友人的一封书信，后人称之为《快雪时晴帖》，为台北故宫博物院「三希」之首，[原帖](https://baike.baidu.com/item/%E5%BF%AB%E9%9B%AA%E6%97%B6%E6%99%B4%E5%B8%96/1247442)如下：\n\n![快雪时晴帖](chinese-honorific-for-work-mail/快雪時晴帖.jpg)\n\n取其中一种断句如下：\n\n```\n羲之頓首/快雪時晴/佳/想安善/未果為結/力不次/王羲之頓首/山陰張侯\n```\n\n用白话文可以略译如下：\n\n```\n羲之顿首。下了一场雪，很舒爽，停得也是时候，很不错。想来你应该都平安健康。没能照心意把信写完，体力不继，表达难以得体，就此停笔。王羲之顿首。\n```\n\n（注：译文参考[*《為王羲之快雪時晴帖解碼 -- Mandulover 的部落格》*](http://blog.udn.com/Mandulover/5585178)。此外，「山阴张侯」应该是写在信封上的收件人，因此不写入书信内容）\n\n## 中文电子邮件敬语分析\n\n中文邮件分公函和私函两大类，公函结构简单不累赘，私函有应酬语体现书写者的情真意切。香港有个站点甚佳，叫 [*中小學中文實用寫作學習軟件（測試版）*](http://203.198.171.19/teaching/program/tongqingdayi/index.htm)，在[*書信*](http://203.198.171.19/teaching/program/tongqingdayi/letter/letter-format02a.htm) 栏目，可以看到有两种公函格式。这两种都是正式的写法，不过公函一应用较广。现根据电子邮件特点稍改格式如下：\n\n![现代电子邮件公函格式](chinese-honorific-for-work-mail/现代电子邮件公函格式.jpg)\n\n这么改有什么案例可以支撑吗？有，请看下文。\n\n第一封邮件是 Apple 发送的安全提醒：\n\n```\n◎◎，您好：\n\n您的 Apple ID **@**.com 刚刚在一台以前未与此 Apple ID 相关联的电脑或设备上从 Mac App Store 下载了 QQ。如果您自上次购买后重设过您的密码，您可能也会收到此邮件。\n\n如果是您本人启始了此项下载，请忽略此邮件。发送此邮件只是为了提醒您注意，以防此下载非您本人所为。\n\n如果此下载不是由您启始的，我们建议你前往 iforgot.apple.com 更改您的密码，然后查看 Apple ID：安全性和 Apple ID获取更多帮助。\n\n谨上\nApple\n```\n第二封是 Google 发送的账户验证：\n```\n尊敬的◎◎，您好！\n\n我们收到了一项要求将 **@**.com 添加到您的 Google 帐户的请求。请点击下面的链接验证此请求。\n\nhttps://accounts.google.com/VA?c=****=zh-CN\n\n如果点击以上链接无法访问相关内容，请将该网址复制并粘贴至新的浏览器窗口中。\n\n您不该收到这封电子邮件？\n请忽略这封邮件，并且不要点击上方的链接。可能是有人输错了电子邮件地址，并无意中试图添加您的电子邮件地址。如果您没有点击上方的链接，您的电子邮件地址就不会被添加到其他帐户。\n\n此致\nGoogle 帐户小组敬上\n```\n\n第三封是七牛云的账户绑定安全提醒：\n\n```\n尊敬的◎◎：\n\n您的账号 **@**.com 于 2017-04-03 17:24:26 成功绑定了 Github 账号 **@**.com (登录IP：*.*.*.*)。若非您本人操作，请尽快 解绑此账号 ，同时 修改您的密码 或 联系我们。\n\n此致\n七牛云团队\n```\n\n### 称谓语分析\n\n### 敬启语分析\n\n### 祝颂语分析\n\n![中文祝颂词分析](chinese-honorific-for-work-mail/中文祝颂词分析.jpg)\n\n","source":"_drafts/language/han/writing/chinese-honorific-for-work-mail.md","raw":"---\ntitle: 工作邮件中的中文敬语\np: language/han/writing/chinese-honorific-for-work-mail\ntags:\n- Chinese\n- Hhonorific\n- Mail\n- 中文\n- 敬语\n- 邮件\n---\n\n《论语·学而》讲到「有子曰：礼之用，和为贵。」，大意是说礼的运用贵在使人际关系和谐。如今我提倡善用敬语，其原因就在于此。我希望能通过敬语的推广减少如今社会的戾气，营造相互尊重相互关怀的社会风气。\n\n<!--more-->\n\n## 东西方邮件比照\n\n在开始讲述我们的主题之前，先来看看我从网络上寻到的几份邮件/信件。\n\n第一份是日文的，是一份公司内部部门名称变更的通知，[原文](https://business-mail.jp/example/753)如下：\n\n```\n営業部の皆様、お疲れ様です。\n総務部の◎◎太郎です。\n\n2011年6月1日（水）より、社内組織の名称を変更いたします。\n\n■変更前：顧客管理部\n\n■変更後：お客様相談センター\n\n■変更実施日：2011年6月1日（水）9:00より\n\nHP、会社案内、配布資料などについては、\n5月30日（月）までに新しいものを各部署に配布いたします。\n古い案内や資料は破棄しますので、各部署でまとめて、\n管理部までお持ちください。\n\n以上、よろしくお願いいたします。\n```\n\n拙译如下：\n\n```\n各位营业部同仁，辛苦您们了。\n我是总务部的◎◎太郎。\n\n2011 年 6 月 1 日（星期三）起，公司内部组织名称有所变更。\n\n变更前：顾客管理部\n变更后：客户咨询中心\n变更实施日：2011 年 6 月 1 日（星期三）9:00 起\n\n至于公司主页、介绍册和散发的资料等，5 月 30 日（星期一）前会发送新的到各职守。\n旧的介绍册及资料要废弃了，请各职守汇总到管理部。\n\n谨此，顺颂商祺。\n```\n\n第二份是英文的，是公司对外婉言谢绝合作的复信，[原文](http://www.blairenglish.com/exercises/emails/exercises/business-email-examples/business-email-examples.html)如下：\n```\nDear Mr Boxall,\n\nThank you for your enquiry about supplying our company with new photocopying equipment.\n\nUnfortunately, we are currently not in need of replacing our existing photocopiers. We recently entered a new 2 year contract with our existing photocopier provider.\n\nYou would be more than welcome to contact us again when our current contract is up for renewal.\n\nYours sincerely,\n\n\nJeff Thompson\nOffice Manager\n```\n\n草译如下：\n\n```\n尊敬的 Boxal 先生：\n\n感谢您上次有关本公司新复印机采购的垂询。\n不巧的是，我们当前没有替换现有复印机的需求。不过不久我们将与现有供应商签订新的为期两年的合同。\n非常欢迎您在我们当前合同续订时再次来询。\n\n敬复。\n\n\n杰夫·汤普森\n办公室主管\n```\n\n第三份是中文繁体的，是一份银行追讨用户欠款的通知，[原文](http://www.cuhk.edu.hk/ics/clrc/crcl_74/wong.pdf)如下（格式上依电子邮件特点略有改动）。\n\n```\nX 先生：\n\n根據本行記錄，貴戶 X 月份信用咭賬項，至 X 月 X 日為止，尚未清繳信用咭使用條款規定的最低還款款額港幣 XXXX 元正。閣下如因私務繁忙，未有按時繳款，敬希於此信發出日期起 X 天內清繳上述欠款，以免妨礙本行繼續為閣下提供信用咭服務。\n如有任何查詢，請致電 XXXXXXXX 與本行職員聯絡。閣下如已清繳上述欠款，請毋須理會此信。\n\nXX 銀行謹啟。\nXXXX 年 X 月 X 日\n```\n\n按大陆习惯转成简体字如下：\n\n```\nX 先生：\n\n根据本行记录，贵户 X 月份信用卡账项，至 X 月 X 日为止，尚未清缴信用卡使用条款规定的最低还款款额港币 XXXX 元整。阁下如因私务繁忙，未有按时缴款，敬希于此信发出日期起 X 天内清缴上述欠款，以免妨碍本行继续为阁下提供信用卡服务。\n如有任何查询，请致电 XXXXXXXX 与本行职员联络。阁下如已清缴上述欠款，请毋须理会此信。\n\nXX 银行谨启。\nXXXX 年 X 月 X 日\n```\n\n最后一份是东晋书法家王羲之写给友人的一封书信，后人称之为《快雪时晴帖》，为台北故宫博物院「三希」之首，[原帖](https://baike.baidu.com/item/%E5%BF%AB%E9%9B%AA%E6%97%B6%E6%99%B4%E5%B8%96/1247442)如下：\n\n![快雪时晴帖](chinese-honorific-for-work-mail/快雪時晴帖.jpg)\n\n取其中一种断句如下：\n\n```\n羲之頓首/快雪時晴/佳/想安善/未果為結/力不次/王羲之頓首/山陰張侯\n```\n\n用白话文可以略译如下：\n\n```\n羲之顿首。下了一场雪，很舒爽，停得也是时候，很不错。想来你应该都平安健康。没能照心意把信写完，体力不继，表达难以得体，就此停笔。王羲之顿首。\n```\n\n（注：译文参考[*《為王羲之快雪時晴帖解碼 -- Mandulover 的部落格》*](http://blog.udn.com/Mandulover/5585178)。此外，「山阴张侯」应该是写在信封上的收件人，因此不写入书信内容）\n\n## 中文电子邮件敬语分析\n\n中文邮件分公函和私函两大类，公函结构简单不累赘，私函有应酬语体现书写者的情真意切。香港有个站点甚佳，叫 [*中小學中文實用寫作學習軟件（測試版）*](http://203.198.171.19/teaching/program/tongqingdayi/index.htm)，在[*書信*](http://203.198.171.19/teaching/program/tongqingdayi/letter/letter-format02a.htm) 栏目，可以看到有两种公函格式。这两种都是正式的写法，不过公函一应用较广。现根据电子邮件特点稍改格式如下：\n\n![现代电子邮件公函格式](chinese-honorific-for-work-mail/现代电子邮件公函格式.jpg)\n\n这么改有什么案例可以支撑吗？有，请看下文。\n\n第一封邮件是 Apple 发送的安全提醒：\n\n```\n◎◎，您好：\n\n您的 Apple ID **@**.com 刚刚在一台以前未与此 Apple ID 相关联的电脑或设备上从 Mac App Store 下载了 QQ。如果您自上次购买后重设过您的密码，您可能也会收到此邮件。\n\n如果是您本人启始了此项下载，请忽略此邮件。发送此邮件只是为了提醒您注意，以防此下载非您本人所为。\n\n如果此下载不是由您启始的，我们建议你前往 iforgot.apple.com 更改您的密码，然后查看 Apple ID：安全性和 Apple ID获取更多帮助。\n\n谨上\nApple\n```\n第二封是 Google 发送的账户验证：\n```\n尊敬的◎◎，您好！\n\n我们收到了一项要求将 **@**.com 添加到您的 Google 帐户的请求。请点击下面的链接验证此请求。\n\nhttps://accounts.google.com/VA?c=****=zh-CN\n\n如果点击以上链接无法访问相关内容，请将该网址复制并粘贴至新的浏览器窗口中。\n\n您不该收到这封电子邮件？\n请忽略这封邮件，并且不要点击上方的链接。可能是有人输错了电子邮件地址，并无意中试图添加您的电子邮件地址。如果您没有点击上方的链接，您的电子邮件地址就不会被添加到其他帐户。\n\n此致\nGoogle 帐户小组敬上\n```\n\n第三封是七牛云的账户绑定安全提醒：\n\n```\n尊敬的◎◎：\n\n您的账号 **@**.com 于 2017-04-03 17:24:26 成功绑定了 Github 账号 **@**.com (登录IP：*.*.*.*)。若非您本人操作，请尽快 解绑此账号 ，同时 修改您的密码 或 联系我们。\n\n此致\n七牛云团队\n```\n\n### 称谓语分析\n\n### 敬启语分析\n\n### 祝颂语分析\n\n![中文祝颂词分析](chinese-honorific-for-work-mail/中文祝颂词分析.jpg)\n\n","slug":"language/han/writing/chinese-honorific-for-work-mail","published":0,"date":"2020-10-04T07:48:34.818Z","updated":"2020-10-04T07:48:34.818Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cki72psyf000zslw8s0rq4wss","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css\"><p>《论语·学而》讲到「有子曰：礼之用，和为贵。」，大意是说礼的运用贵在使人际关系和谐。如今我提倡善用敬语，其原因就在于此。我希望能通过敬语的推广减少如今社会的戾气，营造相互尊重相互关怀的社会风气。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"东西方邮件比照\"><a href=\"#东西方邮件比照\" class=\"headerlink\" title=\"东西方邮件比照\"></a>东西方邮件比照</h2><p>在开始讲述我们的主题之前，先来看看我从网络上寻到的几份邮件/信件。</p>\n<p>第一份是日文的，是一份公司内部部门名称变更的通知，<a href=\"https://business-mail.jp/example/753\" target=\"_blank\" rel=\"noopener\">原文</a>如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">営業部の皆様、お疲れ様です。</span><br><span class=\"line\">総務部の◎◎太郎です。</span><br><span class=\"line\"></span><br><span class=\"line\">2011年6月1日（水）より、社内組織の名称を変更いたします。</span><br><span class=\"line\"></span><br><span class=\"line\">■変更前：顧客管理部</span><br><span class=\"line\"></span><br><span class=\"line\">■変更後：お客様相談センター</span><br><span class=\"line\"></span><br><span class=\"line\">■変更実施日：2011年6月1日（水）9:00より</span><br><span class=\"line\"></span><br><span class=\"line\">HP、会社案内、配布資料などについては、</span><br><span class=\"line\">5月30日（月）までに新しいものを各部署に配布いたします。</span><br><span class=\"line\">古い案内や資料は破棄しますので、各部署でまとめて、</span><br><span class=\"line\">管理部までお持ちください。</span><br><span class=\"line\"></span><br><span class=\"line\">以上、よろしくお願いいたします。</span><br></pre></td></tr></table></figure>\n\n<p>拙译如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">各位营业部同仁，辛苦您们了。</span><br><span class=\"line\">我是总务部的◎◎太郎。</span><br><span class=\"line\"></span><br><span class=\"line\">2011 年 6 月 1 日（星期三）起，公司内部组织名称有所变更。</span><br><span class=\"line\"></span><br><span class=\"line\">变更前：顾客管理部</span><br><span class=\"line\">变更后：客户咨询中心</span><br><span class=\"line\">变更实施日：2011 年 6 月 1 日（星期三）9:00 起</span><br><span class=\"line\"></span><br><span class=\"line\">至于公司主页、介绍册和散发的资料等，5 月 30 日（星期一）前会发送新的到各职守。</span><br><span class=\"line\">旧的介绍册及资料要废弃了，请各职守汇总到管理部。</span><br><span class=\"line\"></span><br><span class=\"line\">谨此，顺颂商祺。</span><br></pre></td></tr></table></figure>\n\n<p>第二份是英文的，是公司对外婉言谢绝合作的复信，<a href=\"http://www.blairenglish.com/exercises/emails/exercises/business-email-examples/business-email-examples.html\" target=\"_blank\" rel=\"noopener\">原文</a>如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Dear Mr Boxall,</span><br><span class=\"line\"></span><br><span class=\"line\">Thank you for your enquiry about supplying our company with new photocopying equipment.</span><br><span class=\"line\"></span><br><span class=\"line\">Unfortunately, we are currently not in need of replacing our existing photocopiers. We recently entered a new 2 year contract with our existing photocopier provider.</span><br><span class=\"line\"></span><br><span class=\"line\">You would be more than welcome to contact us again when our current contract is up for renewal.</span><br><span class=\"line\"></span><br><span class=\"line\">Yours sincerely,</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Jeff Thompson</span><br><span class=\"line\">Office Manager</span><br></pre></td></tr></table></figure>\n\n<p>草译如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">尊敬的 Boxal 先生：</span><br><span class=\"line\"></span><br><span class=\"line\">感谢您上次有关本公司新复印机采购的垂询。</span><br><span class=\"line\">不巧的是，我们当前没有替换现有复印机的需求。不过不久我们将与现有供应商签订新的为期两年的合同。</span><br><span class=\"line\">非常欢迎您在我们当前合同续订时再次来询。</span><br><span class=\"line\"></span><br><span class=\"line\">敬复。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">杰夫·汤普森</span><br><span class=\"line\">办公室主管</span><br></pre></td></tr></table></figure>\n\n<p>第三份是中文繁体的，是一份银行追讨用户欠款的通知，<a href=\"http://www.cuhk.edu.hk/ics/clrc/crcl_74/wong.pdf\" target=\"_blank\" rel=\"noopener\">原文</a>如下（格式上依电子邮件特点略有改动）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">X 先生：</span><br><span class=\"line\"></span><br><span class=\"line\">根據本行記錄，貴戶 X 月份信用咭賬項，至 X 月 X 日為止，尚未清繳信用咭使用條款規定的最低還款款額港幣 XXXX 元正。閣下如因私務繁忙，未有按時繳款，敬希於此信發出日期起 X 天內清繳上述欠款，以免妨礙本行繼續為閣下提供信用咭服務。</span><br><span class=\"line\">如有任何查詢，請致電 XXXXXXXX 與本行職員聯絡。閣下如已清繳上述欠款，請毋須理會此信。</span><br><span class=\"line\"></span><br><span class=\"line\">XX 銀行謹啟。</span><br><span class=\"line\">XXXX 年 X 月 X 日</span><br></pre></td></tr></table></figure>\n\n<p>按大陆习惯转成简体字如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">X 先生：</span><br><span class=\"line\"></span><br><span class=\"line\">根据本行记录，贵户 X 月份信用卡账项，至 X 月 X 日为止，尚未清缴信用卡使用条款规定的最低还款款额港币 XXXX 元整。阁下如因私务繁忙，未有按时缴款，敬希于此信发出日期起 X 天内清缴上述欠款，以免妨碍本行继续为阁下提供信用卡服务。</span><br><span class=\"line\">如有任何查询，请致电 XXXXXXXX 与本行职员联络。阁下如已清缴上述欠款，请毋须理会此信。</span><br><span class=\"line\"></span><br><span class=\"line\">XX 银行谨启。</span><br><span class=\"line\">XXXX 年 X 月 X 日</span><br></pre></td></tr></table></figure>\n\n<p>最后一份是东晋书法家王羲之写给友人的一封书信，后人称之为《快雪时晴帖》，为台北故宫博物院「三希」之首，<a href=\"https://baike.baidu.com/item/%E5%BF%AB%E9%9B%AA%E6%97%B6%E6%99%B4%E5%B8%96/1247442\" target=\"_blank\" rel=\"noopener\">原帖</a>如下：</p>\n<p><img src=\"/2020/10/04/language/han/writing/chinese-honorific-for-work-mail/%E5%BF%AB%E9%9B%AA%E6%99%82%E6%99%B4%E5%B8%96.jpg\" alt=\"快雪时晴帖\"></p>\n<p>取其中一种断句如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">羲之頓首/快雪時晴/佳/想安善/未果為結/力不次/王羲之頓首/山陰張侯</span><br></pre></td></tr></table></figure>\n\n<p>用白话文可以略译如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">羲之顿首。下了一场雪，很舒爽，停得也是时候，很不错。想来你应该都平安健康。没能照心意把信写完，体力不继，表达难以得体，就此停笔。王羲之顿首。</span><br></pre></td></tr></table></figure>\n\n<p>（注：译文参考<a href=\"http://blog.udn.com/Mandulover/5585178\" target=\"_blank\" rel=\"noopener\"><em>《為王羲之快雪時晴帖解碼 – Mandulover 的部落格》</em></a>。此外，「山阴张侯」应该是写在信封上的收件人，因此不写入书信内容）</p>\n<h2 id=\"中文电子邮件敬语分析\"><a href=\"#中文电子邮件敬语分析\" class=\"headerlink\" title=\"中文电子邮件敬语分析\"></a>中文电子邮件敬语分析</h2><p>中文邮件分公函和私函两大类，公函结构简单不累赘，私函有应酬语体现书写者的情真意切。香港有个站点甚佳，叫 <a href=\"http://203.198.171.19/teaching/program/tongqingdayi/index.htm\" target=\"_blank\" rel=\"noopener\"><em>中小學中文實用寫作學習軟件（測試版）</em></a>，在<a href=\"http://203.198.171.19/teaching/program/tongqingdayi/letter/letter-format02a.htm\" target=\"_blank\" rel=\"noopener\"><em>書信</em></a> 栏目，可以看到有两种公函格式。这两种都是正式的写法，不过公函一应用较广。现根据电子邮件特点稍改格式如下：</p>\n<p><img src=\"/2020/10/04/language/han/writing/chinese-honorific-for-work-mail/%E7%8E%B0%E4%BB%A3%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E5%85%AC%E5%87%BD%E6%A0%BC%E5%BC%8F.jpg\" alt=\"现代电子邮件公函格式\"></p>\n<p>这么改有什么案例可以支撑吗？有，请看下文。</p>\n<p>第一封邮件是 Apple 发送的安全提醒：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">◎◎，您好：</span><br><span class=\"line\"></span><br><span class=\"line\">您的 Apple ID **@**.com 刚刚在一台以前未与此 Apple ID 相关联的电脑或设备上从 Mac App Store 下载了 QQ。如果您自上次购买后重设过您的密码，您可能也会收到此邮件。</span><br><span class=\"line\"></span><br><span class=\"line\">如果是您本人启始了此项下载，请忽略此邮件。发送此邮件只是为了提醒您注意，以防此下载非您本人所为。</span><br><span class=\"line\"></span><br><span class=\"line\">如果此下载不是由您启始的，我们建议你前往 iforgot.apple.com 更改您的密码，然后查看 Apple ID：安全性和 Apple ID获取更多帮助。</span><br><span class=\"line\"></span><br><span class=\"line\">谨上</span><br><span class=\"line\">Apple</span><br></pre></td></tr></table></figure>\n\n<p>第二封是 Google 发送的账户验证：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">尊敬的◎◎，您好！</span><br><span class=\"line\"></span><br><span class=\"line\">我们收到了一项要求将 **@**.com 添加到您的 Google 帐户的请求。请点击下面的链接验证此请求。</span><br><span class=\"line\"></span><br><span class=\"line\">https://accounts.google.com/VA?c=****=zh-CN</span><br><span class=\"line\"></span><br><span class=\"line\">如果点击以上链接无法访问相关内容，请将该网址复制并粘贴至新的浏览器窗口中。</span><br><span class=\"line\"></span><br><span class=\"line\">您不该收到这封电子邮件？</span><br><span class=\"line\">请忽略这封邮件，并且不要点击上方的链接。可能是有人输错了电子邮件地址，并无意中试图添加您的电子邮件地址。如果您没有点击上方的链接，您的电子邮件地址就不会被添加到其他帐户。</span><br><span class=\"line\"></span><br><span class=\"line\">此致</span><br><span class=\"line\">Google 帐户小组敬上</span><br></pre></td></tr></table></figure>\n\n<p>第三封是七牛云的账户绑定安全提醒：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">尊敬的◎◎：</span><br><span class=\"line\"></span><br><span class=\"line\">您的账号 **@**.com 于 2017-04-03 17:24:26 成功绑定了 Github 账号 **@**.com (登录IP：*.*.*.*)。若非您本人操作，请尽快 解绑此账号 ，同时 修改您的密码 或 联系我们。</span><br><span class=\"line\"></span><br><span class=\"line\">此致</span><br><span class=\"line\">七牛云团队</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"称谓语分析\"><a href=\"#称谓语分析\" class=\"headerlink\" title=\"称谓语分析\"></a>称谓语分析</h3><h3 id=\"敬启语分析\"><a href=\"#敬启语分析\" class=\"headerlink\" title=\"敬启语分析\"></a>敬启语分析</h3><h3 id=\"祝颂语分析\"><a href=\"#祝颂语分析\" class=\"headerlink\" title=\"祝颂语分析\"></a>祝颂语分析</h3><p><img src=\"/2020/10/04/language/han/writing/chinese-honorific-for-work-mail/%E4%B8%AD%E6%96%87%E7%A5%9D%E9%A2%82%E8%AF%8D%E5%88%86%E6%9E%90.jpg\" alt=\"中文祝颂词分析\"></p>\n","site":{"data":{}},"excerpt":"<p>《论语·学而》讲到「有子曰：礼之用，和为贵。」，大意是说礼的运用贵在使人际关系和谐。如今我提倡善用敬语，其原因就在于此。我希望能通过敬语的推广减少如今社会的戾气，营造相互尊重相互关怀的社会风气。</p>","more":"<h2 id=\"东西方邮件比照\"><a href=\"#东西方邮件比照\" class=\"headerlink\" title=\"东西方邮件比照\"></a>东西方邮件比照</h2><p>在开始讲述我们的主题之前，先来看看我从网络上寻到的几份邮件/信件。</p>\n<p>第一份是日文的，是一份公司内部部门名称变更的通知，<a href=\"https://business-mail.jp/example/753\" target=\"_blank\" rel=\"noopener\">原文</a>如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">営業部の皆様、お疲れ様です。</span><br><span class=\"line\">総務部の◎◎太郎です。</span><br><span class=\"line\"></span><br><span class=\"line\">2011年6月1日（水）より、社内組織の名称を変更いたします。</span><br><span class=\"line\"></span><br><span class=\"line\">■変更前：顧客管理部</span><br><span class=\"line\"></span><br><span class=\"line\">■変更後：お客様相談センター</span><br><span class=\"line\"></span><br><span class=\"line\">■変更実施日：2011年6月1日（水）9:00より</span><br><span class=\"line\"></span><br><span class=\"line\">HP、会社案内、配布資料などについては、</span><br><span class=\"line\">5月30日（月）までに新しいものを各部署に配布いたします。</span><br><span class=\"line\">古い案内や資料は破棄しますので、各部署でまとめて、</span><br><span class=\"line\">管理部までお持ちください。</span><br><span class=\"line\"></span><br><span class=\"line\">以上、よろしくお願いいたします。</span><br></pre></td></tr></table></figure>\n\n<p>拙译如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">各位营业部同仁，辛苦您们了。</span><br><span class=\"line\">我是总务部的◎◎太郎。</span><br><span class=\"line\"></span><br><span class=\"line\">2011 年 6 月 1 日（星期三）起，公司内部组织名称有所变更。</span><br><span class=\"line\"></span><br><span class=\"line\">变更前：顾客管理部</span><br><span class=\"line\">变更后：客户咨询中心</span><br><span class=\"line\">变更实施日：2011 年 6 月 1 日（星期三）9:00 起</span><br><span class=\"line\"></span><br><span class=\"line\">至于公司主页、介绍册和散发的资料等，5 月 30 日（星期一）前会发送新的到各职守。</span><br><span class=\"line\">旧的介绍册及资料要废弃了，请各职守汇总到管理部。</span><br><span class=\"line\"></span><br><span class=\"line\">谨此，顺颂商祺。</span><br></pre></td></tr></table></figure>\n\n<p>第二份是英文的，是公司对外婉言谢绝合作的复信，<a href=\"http://www.blairenglish.com/exercises/emails/exercises/business-email-examples/business-email-examples.html\" target=\"_blank\" rel=\"noopener\">原文</a>如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Dear Mr Boxall,</span><br><span class=\"line\"></span><br><span class=\"line\">Thank you for your enquiry about supplying our company with new photocopying equipment.</span><br><span class=\"line\"></span><br><span class=\"line\">Unfortunately, we are currently not in need of replacing our existing photocopiers. We recently entered a new 2 year contract with our existing photocopier provider.</span><br><span class=\"line\"></span><br><span class=\"line\">You would be more than welcome to contact us again when our current contract is up for renewal.</span><br><span class=\"line\"></span><br><span class=\"line\">Yours sincerely,</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Jeff Thompson</span><br><span class=\"line\">Office Manager</span><br></pre></td></tr></table></figure>\n\n<p>草译如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">尊敬的 Boxal 先生：</span><br><span class=\"line\"></span><br><span class=\"line\">感谢您上次有关本公司新复印机采购的垂询。</span><br><span class=\"line\">不巧的是，我们当前没有替换现有复印机的需求。不过不久我们将与现有供应商签订新的为期两年的合同。</span><br><span class=\"line\">非常欢迎您在我们当前合同续订时再次来询。</span><br><span class=\"line\"></span><br><span class=\"line\">敬复。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">杰夫·汤普森</span><br><span class=\"line\">办公室主管</span><br></pre></td></tr></table></figure>\n\n<p>第三份是中文繁体的，是一份银行追讨用户欠款的通知，<a href=\"http://www.cuhk.edu.hk/ics/clrc/crcl_74/wong.pdf\" target=\"_blank\" rel=\"noopener\">原文</a>如下（格式上依电子邮件特点略有改动）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">X 先生：</span><br><span class=\"line\"></span><br><span class=\"line\">根據本行記錄，貴戶 X 月份信用咭賬項，至 X 月 X 日為止，尚未清繳信用咭使用條款規定的最低還款款額港幣 XXXX 元正。閣下如因私務繁忙，未有按時繳款，敬希於此信發出日期起 X 天內清繳上述欠款，以免妨礙本行繼續為閣下提供信用咭服務。</span><br><span class=\"line\">如有任何查詢，請致電 XXXXXXXX 與本行職員聯絡。閣下如已清繳上述欠款，請毋須理會此信。</span><br><span class=\"line\"></span><br><span class=\"line\">XX 銀行謹啟。</span><br><span class=\"line\">XXXX 年 X 月 X 日</span><br></pre></td></tr></table></figure>\n\n<p>按大陆习惯转成简体字如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">X 先生：</span><br><span class=\"line\"></span><br><span class=\"line\">根据本行记录，贵户 X 月份信用卡账项，至 X 月 X 日为止，尚未清缴信用卡使用条款规定的最低还款款额港币 XXXX 元整。阁下如因私务繁忙，未有按时缴款，敬希于此信发出日期起 X 天内清缴上述欠款，以免妨碍本行继续为阁下提供信用卡服务。</span><br><span class=\"line\">如有任何查询，请致电 XXXXXXXX 与本行职员联络。阁下如已清缴上述欠款，请毋须理会此信。</span><br><span class=\"line\"></span><br><span class=\"line\">XX 银行谨启。</span><br><span class=\"line\">XXXX 年 X 月 X 日</span><br></pre></td></tr></table></figure>\n\n<p>最后一份是东晋书法家王羲之写给友人的一封书信，后人称之为《快雪时晴帖》，为台北故宫博物院「三希」之首，<a href=\"https://baike.baidu.com/item/%E5%BF%AB%E9%9B%AA%E6%97%B6%E6%99%B4%E5%B8%96/1247442\" target=\"_blank\" rel=\"noopener\">原帖</a>如下：</p>\n<p><img src=\"/2020/10/04/language/han/writing/chinese-honorific-for-work-mail/%E5%BF%AB%E9%9B%AA%E6%99%82%E6%99%B4%E5%B8%96.jpg\" alt=\"快雪时晴帖\"></p>\n<p>取其中一种断句如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">羲之頓首/快雪時晴/佳/想安善/未果為結/力不次/王羲之頓首/山陰張侯</span><br></pre></td></tr></table></figure>\n\n<p>用白话文可以略译如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">羲之顿首。下了一场雪，很舒爽，停得也是时候，很不错。想来你应该都平安健康。没能照心意把信写完，体力不继，表达难以得体，就此停笔。王羲之顿首。</span><br></pre></td></tr></table></figure>\n\n<p>（注：译文参考<a href=\"http://blog.udn.com/Mandulover/5585178\" target=\"_blank\" rel=\"noopener\"><em>《為王羲之快雪時晴帖解碼 – Mandulover 的部落格》</em></a>。此外，「山阴张侯」应该是写在信封上的收件人，因此不写入书信内容）</p>\n<h2 id=\"中文电子邮件敬语分析\"><a href=\"#中文电子邮件敬语分析\" class=\"headerlink\" title=\"中文电子邮件敬语分析\"></a>中文电子邮件敬语分析</h2><p>中文邮件分公函和私函两大类，公函结构简单不累赘，私函有应酬语体现书写者的情真意切。香港有个站点甚佳，叫 <a href=\"http://203.198.171.19/teaching/program/tongqingdayi/index.htm\" target=\"_blank\" rel=\"noopener\"><em>中小學中文實用寫作學習軟件（測試版）</em></a>，在<a href=\"http://203.198.171.19/teaching/program/tongqingdayi/letter/letter-format02a.htm\" target=\"_blank\" rel=\"noopener\"><em>書信</em></a> 栏目，可以看到有两种公函格式。这两种都是正式的写法，不过公函一应用较广。现根据电子邮件特点稍改格式如下：</p>\n<p><img src=\"/2020/10/04/language/han/writing/chinese-honorific-for-work-mail/%E7%8E%B0%E4%BB%A3%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E5%85%AC%E5%87%BD%E6%A0%BC%E5%BC%8F.jpg\" alt=\"现代电子邮件公函格式\"></p>\n<p>这么改有什么案例可以支撑吗？有，请看下文。</p>\n<p>第一封邮件是 Apple 发送的安全提醒：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">◎◎，您好：</span><br><span class=\"line\"></span><br><span class=\"line\">您的 Apple ID **@**.com 刚刚在一台以前未与此 Apple ID 相关联的电脑或设备上从 Mac App Store 下载了 QQ。如果您自上次购买后重设过您的密码，您可能也会收到此邮件。</span><br><span class=\"line\"></span><br><span class=\"line\">如果是您本人启始了此项下载，请忽略此邮件。发送此邮件只是为了提醒您注意，以防此下载非您本人所为。</span><br><span class=\"line\"></span><br><span class=\"line\">如果此下载不是由您启始的，我们建议你前往 iforgot.apple.com 更改您的密码，然后查看 Apple ID：安全性和 Apple ID获取更多帮助。</span><br><span class=\"line\"></span><br><span class=\"line\">谨上</span><br><span class=\"line\">Apple</span><br></pre></td></tr></table></figure>\n\n<p>第二封是 Google 发送的账户验证：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">尊敬的◎◎，您好！</span><br><span class=\"line\"></span><br><span class=\"line\">我们收到了一项要求将 **@**.com 添加到您的 Google 帐户的请求。请点击下面的链接验证此请求。</span><br><span class=\"line\"></span><br><span class=\"line\">https://accounts.google.com/VA?c=****=zh-CN</span><br><span class=\"line\"></span><br><span class=\"line\">如果点击以上链接无法访问相关内容，请将该网址复制并粘贴至新的浏览器窗口中。</span><br><span class=\"line\"></span><br><span class=\"line\">您不该收到这封电子邮件？</span><br><span class=\"line\">请忽略这封邮件，并且不要点击上方的链接。可能是有人输错了电子邮件地址，并无意中试图添加您的电子邮件地址。如果您没有点击上方的链接，您的电子邮件地址就不会被添加到其他帐户。</span><br><span class=\"line\"></span><br><span class=\"line\">此致</span><br><span class=\"line\">Google 帐户小组敬上</span><br></pre></td></tr></table></figure>\n\n<p>第三封是七牛云的账户绑定安全提醒：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">尊敬的◎◎：</span><br><span class=\"line\"></span><br><span class=\"line\">您的账号 **@**.com 于 2017-04-03 17:24:26 成功绑定了 Github 账号 **@**.com (登录IP：*.*.*.*)。若非您本人操作，请尽快 解绑此账号 ，同时 修改您的密码 或 联系我们。</span><br><span class=\"line\"></span><br><span class=\"line\">此致</span><br><span class=\"line\">七牛云团队</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"称谓语分析\"><a href=\"#称谓语分析\" class=\"headerlink\" title=\"称谓语分析\"></a>称谓语分析</h3><h3 id=\"敬启语分析\"><a href=\"#敬启语分析\" class=\"headerlink\" title=\"敬启语分析\"></a>敬启语分析</h3><h3 id=\"祝颂语分析\"><a href=\"#祝颂语分析\" class=\"headerlink\" title=\"祝颂语分析\"></a>祝颂语分析</h3><p><img src=\"/2020/10/04/language/han/writing/chinese-honorific-for-work-mail/%E4%B8%AD%E6%96%87%E7%A5%9D%E9%A2%82%E8%AF%8D%E5%88%86%E6%9E%90.jpg\" alt=\"中文祝颂词分析\"></p>"},{"title":"JS 入门","p":"dev/lang/js/js-startup","_content":"\nJS (JavaScript) 是一门解释型或者即时编译型 (JIT, Just-In-Time) 编程语言，创造者为 Netscape 公司。它的标准由 Ecma International  发布，称之为 ECMAScript，早期采用小数进行发布版本，ECMAScript 6.0 (ES6, ES2015) 开始使用年份发布版本，目前 ECMAScript 2020 正处于草案阶段。\n\n<!--more-->\n\n> 注：\n>\n>  [Ecma International](https://en.wikipedia.org/wiki/Ecma_International) 保留了早期的名称 European Computer Manufacturers Association，欧洲计算机厂商协会。其口号是 “**European association for standardizing information and communication systems**”（专注于标准化信息和通信系统的欧洲协会）。该组织的普通会员（具有投票权）有 Google、PayPal、IBM、Intel、Microsoft 等等。其产生的标准不限于 ECMAScript，还有 Dart 语言规范、C# 语言规范，还有不限于编程语言的规范，详细的规范列表可以参阅[这里](https://www.ecma-international.org/publications/standards/Stnindex.htm)。\n\nJS 是 ECMAScript 标准的一种实现，其它实现还有 JScript、ActionScript。JScript 是微软开发用于 IE 浏览器内核的 ECMAScript 方言，而 ActionScript 是 Macromedia 公司开发用于 Flash 动画，后被 Adobe 收购。\n\n或者你还耳闻过 TypeScript，它跟 JS 是什么关系呢？是不是也是同父异母的兄弟呢？\n\n \n\nJS 的常见运行环境有两个：\n\n1. 浏览器环境；\n2. Node.js 环境。\n\n## 参考\n\n1. [JavaScript - MDN web docs](https://developer.mozilla.org/en-US/docs/Web/JavaScript)\n2. [ECMAScript 6 入门 - ruanyifeng.com](https://es6.ruanyifeng.com/)\n3. [nodejs docs - nodejs.org](https://nodejs.org/en/docs/)\n\n","source":"_drafts/program/dev/lang/js/js-startup.md","raw":"---\ntitle: JS 入门\np: dev/lang/js/js-startup\ntags:\n- JS\n---\n\nJS (JavaScript) 是一门解释型或者即时编译型 (JIT, Just-In-Time) 编程语言，创造者为 Netscape 公司。它的标准由 Ecma International  发布，称之为 ECMAScript，早期采用小数进行发布版本，ECMAScript 6.0 (ES6, ES2015) 开始使用年份发布版本，目前 ECMAScript 2020 正处于草案阶段。\n\n<!--more-->\n\n> 注：\n>\n>  [Ecma International](https://en.wikipedia.org/wiki/Ecma_International) 保留了早期的名称 European Computer Manufacturers Association，欧洲计算机厂商协会。其口号是 “**European association for standardizing information and communication systems**”（专注于标准化信息和通信系统的欧洲协会）。该组织的普通会员（具有投票权）有 Google、PayPal、IBM、Intel、Microsoft 等等。其产生的标准不限于 ECMAScript，还有 Dart 语言规范、C# 语言规范，还有不限于编程语言的规范，详细的规范列表可以参阅[这里](https://www.ecma-international.org/publications/standards/Stnindex.htm)。\n\nJS 是 ECMAScript 标准的一种实现，其它实现还有 JScript、ActionScript。JScript 是微软开发用于 IE 浏览器内核的 ECMAScript 方言，而 ActionScript 是 Macromedia 公司开发用于 Flash 动画，后被 Adobe 收购。\n\n或者你还耳闻过 TypeScript，它跟 JS 是什么关系呢？是不是也是同父异母的兄弟呢？\n\n \n\nJS 的常见运行环境有两个：\n\n1. 浏览器环境；\n2. Node.js 环境。\n\n## 参考\n\n1. [JavaScript - MDN web docs](https://developer.mozilla.org/en-US/docs/Web/JavaScript)\n2. [ECMAScript 6 入门 - ruanyifeng.com](https://es6.ruanyifeng.com/)\n3. [nodejs docs - nodejs.org](https://nodejs.org/en/docs/)\n\n","slug":"program/dev/lang/js/js-startup","published":0,"date":"2020-10-04T07:48:34.828Z","updated":"2020-10-04T07:48:34.828Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cki72psyw001cslw85ewll4rv","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css\"><p>JS (JavaScript) 是一门解释型或者即时编译型 (JIT, Just-In-Time) 编程语言，创造者为 Netscape 公司。它的标准由 Ecma International  发布，称之为 ECMAScript，早期采用小数进行发布版本，ECMAScript 6.0 (ES6, ES2015) 开始使用年份发布版本，目前 ECMAScript 2020 正处于草案阶段。</p>\n<a id=\"more\"></a>\n\n<blockquote>\n<p>注：</p>\n<p> <a href=\"https://en.wikipedia.org/wiki/Ecma_International\" target=\"_blank\" rel=\"noopener\">Ecma International</a> 保留了早期的名称 European Computer Manufacturers Association，欧洲计算机厂商协会。其口号是 “<strong>European association for standardizing information and communication systems</strong>”（专注于标准化信息和通信系统的欧洲协会）。该组织的普通会员（具有投票权）有 Google、PayPal、IBM、Intel、Microsoft 等等。其产生的标准不限于 ECMAScript，还有 Dart 语言规范、C# 语言规范，还有不限于编程语言的规范，详细的规范列表可以参阅<a href=\"https://www.ecma-international.org/publications/standards/Stnindex.htm\" target=\"_blank\" rel=\"noopener\">这里</a>。</p>\n</blockquote>\n<p>JS 是 ECMAScript 标准的一种实现，其它实现还有 JScript、ActionScript。JScript 是微软开发用于 IE 浏览器内核的 ECMAScript 方言，而 ActionScript 是 Macromedia 公司开发用于 Flash 动画，后被 Adobe 收购。</p>\n<p>或者你还耳闻过 TypeScript，它跟 JS 是什么关系呢？是不是也是同父异母的兄弟呢？</p>\n<p>JS 的常见运行环境有两个：</p>\n<ol>\n<li>浏览器环境；</li>\n<li>Node.js 环境。</li>\n</ol>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ol>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript\" target=\"_blank\" rel=\"noopener\">JavaScript - MDN web docs</a></li>\n<li><a href=\"https://es6.ruanyifeng.com/\" target=\"_blank\" rel=\"noopener\">ECMAScript 6 入门 - ruanyifeng.com</a></li>\n<li><a href=\"https://nodejs.org/en/docs/\" target=\"_blank\" rel=\"noopener\">nodejs docs - nodejs.org</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>JS (JavaScript) 是一门解释型或者即时编译型 (JIT, Just-In-Time) 编程语言，创造者为 Netscape 公司。它的标准由 Ecma International  发布，称之为 ECMAScript，早期采用小数进行发布版本，ECMAScript 6.0 (ES6, ES2015) 开始使用年份发布版本，目前 ECMAScript 2020 正处于草案阶段。</p>","more":"<blockquote>\n<p>注：</p>\n<p> <a href=\"https://en.wikipedia.org/wiki/Ecma_International\" target=\"_blank\" rel=\"noopener\">Ecma International</a> 保留了早期的名称 European Computer Manufacturers Association，欧洲计算机厂商协会。其口号是 “<strong>European association for standardizing information and communication systems</strong>”（专注于标准化信息和通信系统的欧洲协会）。该组织的普通会员（具有投票权）有 Google、PayPal、IBM、Intel、Microsoft 等等。其产生的标准不限于 ECMAScript，还有 Dart 语言规范、C# 语言规范，还有不限于编程语言的规范，详细的规范列表可以参阅<a href=\"https://www.ecma-international.org/publications/standards/Stnindex.htm\" target=\"_blank\" rel=\"noopener\">这里</a>。</p>\n</blockquote>\n<p>JS 是 ECMAScript 标准的一种实现，其它实现还有 JScript、ActionScript。JScript 是微软开发用于 IE 浏览器内核的 ECMAScript 方言，而 ActionScript 是 Macromedia 公司开发用于 Flash 动画，后被 Adobe 收购。</p>\n<p>或者你还耳闻过 TypeScript，它跟 JS 是什么关系呢？是不是也是同父异母的兄弟呢？</p>\n<p>JS 的常见运行环境有两个：</p>\n<ol>\n<li>浏览器环境；</li>\n<li>Node.js 环境。</li>\n</ol>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ol>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript\" target=\"_blank\" rel=\"noopener\">JavaScript - MDN web docs</a></li>\n<li><a href=\"https://es6.ruanyifeng.com/\" target=\"_blank\" rel=\"noopener\">ECMAScript 6 入门 - ruanyifeng.com</a></li>\n<li><a href=\"https://nodejs.org/en/docs/\" target=\"_blank\" rel=\"noopener\">nodejs docs - nodejs.org</a></li>\n</ol>"}],"PostAsset":[{"_id":"source/_posts/it/java/java-basic/Untitled 1.png","slug":"Untitled 1.png","post":"cki72psxd0006slw80vj4wgnh","modified":0,"renderable":0},{"_id":"source/_posts/it/java/java-basic/20201202_24328.png","slug":"20201202_24328.png","post":"cki72psxd0006slw80vj4wgnh","modified":0,"renderable":0},{"_id":"source/_posts/music/listen-chopin-raindrop/cdefgab.jpg","slug":"cdefgab.jpg","post":"cki72pswu0003slw8s5csnat6","modified":0,"renderable":0},{"_id":"source/_posts/music/listen-chopin-raindrop/piano-keys.gif","slug":"piano-keys.gif","post":"cki72pswu0003slw8s5csnat6","modified":0,"renderable":0},{"_id":"source/_posts/it/java/java-collection/Untitled 4.png","slug":"Untitled 4.png","post":"cki72psxk000eslw803sk63bx","modified":0,"renderable":0},{"_id":"source/_posts/language/min/sigêng-giamgia/蒹葭.m4a","slug":"蒹葭.m4a","post":"cki72psxe0007slw84lp27w41","modified":0,"renderable":0},{"_id":"source/_posts/it/java/java-collection/Untitled 5.png","slug":"Untitled 5.png","post":"cki72psxk000eslw803sk63bx","modified":0,"renderable":0},{"_id":"source/_posts/it/java/java-basic/Untitled 4.png","slug":"Untitled 4.png","post":"cki72psxd0006slw80vj4wgnh","modified":0,"renderable":0},{"_id":"source/_posts/language/min/teochew-kahtsi-vowel/202010042112.png","slug":"202010042112.png","post":"cki72psxg000aslw8ooxp6kf5","modified":0,"renderable":0},{"_id":"source/_posts/language/min/sigêng-giamgia/202010060948.jpg","slug":"202010060948.jpg","post":"cki72psxe0007slw84lp27w41","modified":0,"renderable":0},{"_id":"source/_posts/language/min/teochew-opera-ghêgdengcung/2020-10-14-12.41.34.png","slug":"2020-10-14-12.41.34.png","post":"cki72psxj000bslw86owdexyz","modified":0,"renderable":0},{"_id":"source/_posts/language/min/teochew-opera-ghêgdengcung/2020-10-15-1.10.20.png","slug":"2020-10-15-1.10.20.png","post":"cki72psxj000bslw86owdexyz","modified":0,"renderable":0},{"_id":"source/_posts/language/min/teochew-opera-ghêgdengcung/2020-10-15-1.11.30.png","slug":"2020-10-15-1.11.30.png","post":"cki72psxj000bslw86owdexyz","modified":0,"renderable":0},{"_id":"source/_posts/language/min/teochew-opera-ghêgdengcung/2020-10-15-1.12.28.png","slug":"2020-10-15-1.12.28.png","post":"cki72psxj000bslw86owdexyz","modified":0,"renderable":0},{"_id":"source/_posts/it/java/java-basic/20201114_101407.png","slug":"20201114_101407.png","post":"cki72psxd0006slw80vj4wgnh","modified":0,"renderable":0},{"_id":"source/_posts/it/java/java-basic/Untitled 2.png","slug":"Untitled 2.png","post":"cki72psxd0006slw80vj4wgnh","modified":0,"renderable":0},{"_id":"source/_posts/it/java/java-basic/Untitled 3.png","slug":"Untitled 3.png","post":"cki72psxd0006slw80vj4wgnh","modified":0,"renderable":0},{"_id":"source/_posts/it/java/java-basic/Untitled.png","slug":"Untitled.png","post":"cki72psxd0006slw80vj4wgnh","modified":0,"renderable":0},{"_id":"source/_posts/it/java/java-collection/Untitled 1.png","slug":"Untitled 1.png","post":"cki72psxk000eslw803sk63bx","modified":0,"renderable":0},{"_id":"source/_posts/it/java/java-collection/Untitled 2.png","slug":"Untitled 2.png","post":"cki72psxk000eslw803sk63bx","modified":0,"renderable":0},{"_id":"source/_posts/it/java/java-collection/Untitled 3.png","slug":"Untitled 3.png","post":"cki72psxk000eslw803sk63bx","modified":0,"renderable":0},{"_id":"source/_posts/it/java/java-collection/Untitled 6.png","slug":"Untitled 6.png","post":"cki72psxk000eslw803sk63bx","modified":0,"renderable":0},{"_id":"source/_posts/it/java/java-collection/Untitled.png","slug":"Untitled.png","post":"cki72psxk000eslw803sk63bx","modified":0,"renderable":0},{"_id":"source/_drafts/language/han/writing/chinese-honorific-for-work-mail/中文祝颂词分析.jpg","slug":"中文祝颂词分析.jpg","post":"cki72psyf000zslw8s0rq4wss","modified":0,"renderable":0},{"_id":"source/_drafts/language/han/writing/chinese-honorific-for-work-mail/陈寅恪致函傅斯年.jpg","slug":"陈寅恪致函傅斯年.jpg","post":"cki72psyf000zslw8s0rq4wss","modified":0,"renderable":0},{"_id":"source/_drafts/language/han/writing/chinese-honorific-for-work-mail/english-mail-example.jpg","slug":"english-mail-example.jpg","post":"cki72psyf000zslw8s0rq4wss","modified":0,"renderable":0},{"_id":"source/_drafts/language/han/writing/chinese-honorific-for-work-mail/jp-mail-example.jpg","slug":"jp-mail-example.jpg","post":"cki72psyf000zslw8s0rq4wss","modified":0,"renderable":0},{"_id":"source/_drafts/language/han/writing/chinese-honorific-for-work-mail/公函一.jpg","slug":"公函一.jpg","post":"cki72psyf000zslw8s0rq4wss","modified":0,"renderable":0},{"_id":"source/_drafts/language/han/writing/chinese-honorific-for-work-mail/公函二.jpg","slug":"公函二.jpg","post":"cki72psyf000zslw8s0rq4wss","modified":0,"renderable":0},{"_id":"source/_drafts/language/han/writing/chinese-honorific-for-work-mail/快雪時晴帖.jpg","slug":"快雪時晴帖.jpg","post":"cki72psyf000zslw8s0rq4wss","modified":0,"renderable":0},{"_id":"source/_drafts/language/han/writing/chinese-honorific-for-work-mail/现代电子邮件公函格式.jpg","slug":"现代电子邮件公函格式.jpg","post":"cki72psyf000zslw8s0rq4wss","modified":0,"renderable":0}],"PostCategory":[],"PostTag":[{"post_id":"cki72psvt0000slw873g9t3yu","tag_id":"cki72psvz0001slw8ai9n2v37","_id":"cki72psw20002slw8wgscts24"},{"post_id":"cki72pswu0003slw8s5csnat6","tag_id":"cki72pswv0004slw8lvraiwo4","_id":"cki72pswx0005slw82eojesdx"},{"post_id":"cki72psxd0006slw80vj4wgnh","tag_id":"cki72psxf0008slw810u03398","_id":"cki72psxk000dslw8ig6wj4ra"},{"post_id":"cki72psxk000eslw803sk63bx","tag_id":"cki72psxf0008slw810u03398","_id":"cki72psxs000gslw82hm65jm7"},{"post_id":"cki72psxe0007slw84lp27w41","tag_id":"cki72psxk000cslw8k1iyox15","_id":"cki72psxt000jslw8a2anznhg"},{"post_id":"cki72psxe0007slw84lp27w41","tag_id":"cki72psxq000fslw85p0sy8g8","_id":"cki72psxt000kslw8kq2vm79c"},{"post_id":"cki72psxe0007slw84lp27w41","tag_id":"cki72psxt000hslw8d513rwdg","_id":"cki72psxu000mslw8q8oop3ja"},{"post_id":"cki72psxf0009slw8o509sqts","tag_id":"cki72psxt000islw8qy180xe5","_id":"cki72psxu000nslw89auq018f"},{"post_id":"cki72psxg000aslw8ooxp6kf5","tag_id":"cki72psxt000hslw8d513rwdg","_id":"cki72psxv000rslw8ogrv021u"},{"post_id":"cki72psxg000aslw8ooxp6kf5","tag_id":"cki72psxu000oslw8nba94w91","_id":"cki72psxw000sslw83c2f346f"},{"post_id":"cki72psxg000aslw8ooxp6kf5","tag_id":"cki72psxq000fslw85p0sy8g8","_id":"cki72psxw000uslw8mw4tvfot"},{"post_id":"cki72psxj000bslw86owdexyz","tag_id":"cki72psxv000qslw8skdfznrk","_id":"cki72psxw000wslw8a3wwrjdp"},{"post_id":"cki72psxj000bslw86owdexyz","tag_id":"cki72psxu000oslw8nba94w91","_id":"cki72psxx000xslw89bizntzb"},{"post_id":"cki72psxj000bslw86owdexyz","tag_id":"cki72psxt000hslw8d513rwdg","_id":"cki72psxx000yslw8rsmxewh6"},{"post_id":"cki72psyf000zslw8s0rq4wss","tag_id":"cki72psyg0010slw8r3xhr4yn","_id":"cki72psyk0016slw817k3efir"},{"post_id":"cki72psyf000zslw8s0rq4wss","tag_id":"cki72psyi0011slw8sit80w7s","_id":"cki72psyk0017slw82bmw44rp"},{"post_id":"cki72psyf000zslw8s0rq4wss","tag_id":"cki72psyj0012slw8vbrkpzdx","_id":"cki72psyk0018slw8zazonqs5"},{"post_id":"cki72psyf000zslw8s0rq4wss","tag_id":"cki72psyj0013slw8hsqurfj3","_id":"cki72psyk0019slw8dsnnmeps"},{"post_id":"cki72psyf000zslw8s0rq4wss","tag_id":"cki72psyj0014slw81vagz216","_id":"cki72psyk001aslw8l5myufy0"},{"post_id":"cki72psyf000zslw8s0rq4wss","tag_id":"cki72psyj0015slw8zwad6hrk","_id":"cki72psyk001bslw8nym77fwz"},{"post_id":"cki72psyw001cslw85ewll4rv","tag_id":"cki72psyx001dslw8nmilqibu","_id":"cki72psz7001eslw8zazx5dkb"}],"Tag":[{"name":"Hello","_id":"cki72psvz0001slw8ai9n2v37"},{"name":"聆聽音樂","_id":"cki72pswv0004slw8lvraiwo4"},{"name":"Java","_id":"cki72psxf0008slw810u03398"},{"name":"詩經","_id":"cki72psxk000cslw8k1iyox15"},{"name":"甲子話","_id":"cki72psxq000fslw85p0sy8g8"},{"name":"閩南語","_id":"cki72psxt000hslw8d513rwdg"},{"name":"日本語","_id":"cki72psxt000islw8qy180xe5"},{"name":"潮州話","_id":"cki72psxu000oslw8nba94w91"},{"name":"潮劇","_id":"cki72psxv000qslw8skdfznrk"},{"name":"Chinese","_id":"cki72psyg0010slw8r3xhr4yn"},{"name":"Hhonorific","_id":"cki72psyi0011slw8sit80w7s"},{"name":"Mail","_id":"cki72psyj0012slw8vbrkpzdx"},{"name":"中文","_id":"cki72psyj0013slw8hsqurfj3"},{"name":"敬语","_id":"cki72psyj0014slw81vagz216"},{"name":"邮件","_id":"cki72psyj0015slw8zwad6hrk"},{"name":"JS","_id":"cki72psyx001dslw8nmilqibu"}]}}